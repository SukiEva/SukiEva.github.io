{"pages":[{"title":"关于","text":"Stats Pinned Contributions","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"comment-policy","text":"评论政策 被认为是垃圾邮件或纯属促销性质的评论将被删除。 包括相关内容的链接是允许的，但评论应与帖子主题相关。 包括亵渎在内的评论将被删除。 包含可能被视为冒犯的语言或概念的评论将被删除。 请注意，这可能包括辱骂性，威胁性，色情，冒犯性，误导性或诽谤性的语言。 直接攻击个人的评论将被删除。 骚扰其他人员的评论将被删除。 请尊重其他贡献者。 匿名评论将被删除。 此博客的所有者保留在未通知的情况下编辑或删除提交到博客的任何评论的权利。 此评论政策随时可能更改。 如果您对评论政策有任何疑问，请通过dev.suki@outlook.com告知我们。","link":"/comment-policy/index.html"}],"posts":[{"title":"Android——ViewBinding","text":"通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。 在大多数情况下，视图绑定会替代 findViewById。 参考自： 视图绑定 | Android 开发者 | Android Developers Android | ViewBinding 与 Kotlin 委托双剑合璧 - 掘金 (juejin.cn) 1、实现原理在 Android 开发更新迭代中，Kotlin 逐渐取代 Java 成为主流开发语言，原来一些旧的使用方法也随之被取代。Android-Kotlin-Extensions 因为安全问题被官方废弃，随之就有了view binding（视图绑定）来继承对findViewById的替换。 用于更加轻量地实现视图绑定（视图与变量的绑定），可以理解为轻量版本的 DataBinding。 Android Gradle 插件会为每个 XML 布局文件创建一个绑定类，绑定类中包含布局文件中每个定义了android:id属性的 View 引用。假设布局文件为fragment_test.xml，则生成绑定类FragmentTestBinding.java； 2、使用方法1、开启视图绑定在模块的build.gradle/.kts中加入以下内容开启： 123456android { ... buildFeatures { viewBinding = true }} 如果希望生成绑定类时忽略某个布局文件，在相应的XML里加入： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 2、Activity中使用在 Activity 的 onCreate() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 将根视图传递到 setContentView()，使其成为屏幕上的活动视图。 123456789101112 private lateinit var binding: ResultProfileBinding override fun onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view) }// 后续通过以下方法引用viewbinding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 3、Fragment中使用在 Fragment 的 onCreateView() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。 注意：inflate() 方法会要求您传入布局膨胀器。如果布局已膨胀，可以调用绑定类的静态 bind() 方法。如需了解详情，请查看视图绑定 GitHub 示例中的例子。 1234567891011121314151617181920212223 private var _binding: ResultProfileBinding? = null // This property is only valid between onCreateView and // onDestroyView. private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view }// Fragment 的存在时间比其视图长。请务必在 Fragment 的 onDestroyView() 方法中清除对绑定类实例的所有引用。 override fun onDestroyView() { super.onDestroyView() _binding = null }// 后续使用binding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 为什么 Fragment#onDestroyView() 里需要置空绑定类对象，而 Activity 里不需要？ 答：Activity 实例和 Activity 视图的生命周期是同步的，而 Fragment 实例和 Fragment 视图的生命周期并不是完全同步的，因此需要在 Fragment 视图销毁时，手动回收绑定类对象，否则造成内存泄露。 例如：detach Fragment，或者 remove Fragment 并且事务进入返回栈，此时 Fragment 视图销毁但 Fragment 实例存在。 总之，在视图销毁但是控制类对象实例还存活的时机，你就需要手动回收绑定类对象，否则造成内存泄露。 3、与其他方案对比 角度 findViewById ButterKnife Kotlin Synthetics DataBinding ViewBinding 简洁性 ✖ ✖ ✔ ✔ ✔ 编译期检查 ✖ ✖ ✖ ✔ ✔ 编译速度 ✔ ✖ ✔ ✖ ✔ 支持 Kotlin &amp; Java ✔ ✔ ✖ ✔ ✔ 收敛模板代码 ✖ ✖ ✔ ✖ ✖ 简洁性： findViewById 和 ButterKnife 需要在代码中声明很多变量，其他几种方案代码简洁读较好； 编译检查： 编译期间主要有两个方面的检查：类型检查 + 只能访问当前布局中的 id。findViewById、ButterKnife 和 Kotlin Synthetics 在这方面表现较差； 编译速度： findViewById 的编译速度是最快的，而 ButterKnife 和 DataBinding 中存在注解处理，编译速度略逊色于 Kotlin Synthetics 和 ViewBinding； 支持 Kotlin &amp; Java： Kotlin Synthetics 只支持 Kotlin 语言； 收敛模板代码： 基本上每种方案都带有一定量的模板代码，只有 Kotlin Synthetics 的模板代码是较少的。","link":"/Android/Android%E2%80%94ViewBinding/"},{"title":"Android四大组件——Activity","text":"Activity 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 main() 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。 参考： Activity 简介 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期状态每个 Activity 至多有4种状态： 运行状态：Activity 位于返回栈栈顶（系统不回收） 暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收） 停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收） 销毁状态：Activity 从返回栈移除（系统回收） 生存期为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()，另有一个onRestart()。当 Activity 进入新状态时，系统会调用其中每个回调。 onCreate()：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 onStart() 和 onResume() 方法 onStart()：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入onResume() onResume()：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态 onPause()：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据 onStop() ：当完全不可见时调用。与onPause() 的区别在于：如果新活动是对话框，onPause()执行，它不执行 onDestroy()：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态 onRestart()：由停止到运行时调用，即活动被重启 以上除了onRestart()两两对应，即： 完整生存期：onCreate()→onDestroy() 可见生存期：onStart()→onStop() 前台生存期：onResume()→onPause() 2、启动模式通过AndroidManifest.xml中为&lt;activity&gt;指定android:launchMode standard默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 singleTop在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。 singleTask在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。 Activity 一次只能有一个实例存在。 注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。 singleInstance与 &quot;singleTask&quot; 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。 该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。 即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。 用于其他应用中调用此 Activity。 3、意图显示 intent12val intent = Intent(this, SecondActivity::class.java)startActivity(intent) 隐式 intent在&lt;activity&gt;下配置&lt;intent-filter&gt;，在&lt;action&gt;中指名可以相应的action，&lt;category&gt;中添加附加信息，只有&lt;action&gt;和&lt;category&gt;同时匹配，当前活动才会响应 intent 123456&lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 12val intent = Intent(com.example.activitytest.ACTION_START) // default 默认添加categorystartActivity(intent) 向下一个 Activity 传递数据在显示 intent 中添加：intent.putExtra() 向上一个Activity 传递数据SecondActivity.kt 1234567override fun onBackPressed() { super.onBackPressed() val intent = Intent() intent.putExtra(&quot;data_return&quot;,&quot;msg...&quot;) setResult(RESULT_OK, intent) finish()} FirstActivity.ky 1234567891011val intent = ...startActivityForResult(intent, 1) // 参数2是请求码，唯一值即可override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { 1 -&gt; if (requestCode = RESULT_OK) { val retrunedData = data?.getStringExtra(&quot;data_return&quot;) } }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Activity/"},{"title":"Android四大组件——BroadcastReceiver","text":"Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似。这些广播会在所关注的事件发生时发送。 一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。 参考： 广播概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、广播类型 标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。 优点：效率高 缺点：无法被截断 系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。 优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播 缺点：效率没有标准广播高 2、系统广播Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。 可以在&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt中查看 1、动态注册程序启动之后才能接收广播 1234567891011121314151617181920212223242526lateinit var timeChangeReceiver: TimeChangeReceiveroverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) // 系统广播动作 timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) // 动态注册}override fun onDestroy() { super.onDestroy() unregisterReceiver(timeChangeReceiver) // 取消注册}// 内部类注册inner class TimeChangeReceiver : BroadcastReceiver() { // 继承 BroadcastReceiver override fun onReceive(p0: Context?, p1: Intent?) { // 不允许多线程，所以不能执行耗时操作 p0?.let { &quot;Time has changed&quot;.showToast(it) } }} 2、静态注册由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。 Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。 例外情况见 隐式广播例外情况 | Android 开发者 | Android Developers 注意：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器 1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3、自定义广播1、发送标准广播创建 BroadcastReceiver12345class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 }} 注册广播12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播123val intent = Intent(&quot;com.example.MY_BROADCAST&quot;)intent.setPackage(packageName) // 指定包名，使其成为显示广播sendBroadcast(intent) 2、发送有序广播前面与标准广播相同，发送广播时选择 sendOrderedBroadcast(intent,null) （参数2是与权限相关的字符串） 设置优先级因为有序广播可以被截断，在静态注册时指定优先级： &lt;intent-filter android:priority=&quot;100&quot;&gt; 截断使用 abortBroadcast() 123456class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 abortBroadcast() }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94BroadcastReceiver/"},{"title":"Android四大组件——ContentProvider","text":"内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。 参考： 内容提供程序 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 todo","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94ContentProvider/"},{"title":"Android四大组件——Service","text":"Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。 参考： 服务概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、多线程一般耗时的服务都需要放在子线程中运行，否则会造成主线程阻塞，从而影响用户使用。 基本用法 继承Thread 1234567class MyThread : Thread(){ override fun fun(){ // ... }}// 开始运行MyThread().start() 上面的方法耦合性过高，一般使用Runnable接口 12345678class MyThread : Runnable{ override fun fun(){ // ... }}// 开始运行val myThread = MyThread()Thread(myThread).start() 更为常见的方法是使用Lambda表达式，不需要专门定义一个类 123456789Thread { // ...}.start()// 在Kotlin中可以写为： 不需要调用 start()thread{ // ...} 子线程更新UIAndroid 的 UI 是线程不安全的，直接在子线程中进行 UI 操作会出现异常。不过，Android 提供了异步消息处理机制Handler。 主要包含以下部分： Message：线程间传递的消息，可以在内部携带少量消息 Handler：处理者，用于发送和处理消息 MessageQueue：消息队列，用于存放通过Handler发送的消息，每个线程只有一个 Looper：每个线程中MessageQueue的管家，调用Looper的loop()后开始循环取出MessageQueue中的消息，并传递到Handler的handleMessage()中，每个线程只有一个 12345678910111213141516val updateText = 1val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) when (msg.what) { updateText -&gt; //... // ... } } }thread{ val msg = Message() msg.what = updateText handler.sendMessage(msg) // 发送消息} AsyncTask 在 API30 被Google废弃，转而推荐使用 将 Kotlin 协程与生命周期感知型组件一起使用 | Android 开发者 | Android Developers 2、Service生命周期最常使用的回调方法是：onBind()、onCreate、onStartCommand、onDestroy onCreate：在 Service 创建（仅第一次）的时候调用 onStartCommand：在 Service 启动（每次）的时候调用 onDestroy：在 Service 销毁时调用 每个 Service 只会存在一个实例 3、Service基本用法启动和停止123val intent = Intent(this, MyService::class.java)startService(intent) // 启动stopService(intent) // 停止 与Activity通信在活动中控制服务的具体执行，而不是启动后就无法控制。 通过Bind实现： 123456789101112131415class MyService : Service() { private val mBinder = DownloadBinder() override fun onBind(intent: Intent): IBinder { return mBinder } class DownloadBinder : Binder() { fun startDownload() { //... } }} 在活动中创建： 1234567891011121314151617var downloadBinder = MyService.DownloadBinder()private val connection = object:ServiceConnection{ // 匿名类 override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) { // 绑定时调用 downloadBinder = p1 as MyService.DownloadBinder downloadBinder.startDownload() // 可自由选择 Service 中的方法 } override fun onServiceDisconnected(p0: ComponentName?) { // 进程崩溃或被杀掉时调用，不常用 TODO(&quot;Not yet implemented&quot;) }}val intent = Intent(this, MyService::class.java)bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service// BIND_AUTO_CREATE: 自动创建Service，调用 onCreate，忽略 onStartCommamdunbindService(connection) // 解绑Service 任何 Service 可以和任意 Activity 绑定，且绑定后获得相同实例 4、前台服务前台服务是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，将其放在运行中的标题下方。这意味着除非将服务停止或从前台移除，否则不能清除该通知。 从 Android 9.0 开始需要申请权限 android.permission.FOREGROUND_SERVICE 在onCreate中： 1234567891011121314val pendingIntent: PendingIntent = Intent(this, ExampleActivity::class.java).let { notificationIntent -&gt; PendingIntent.getActivity(this, 0, notificationIntent, 0) }val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build()startForeground(ONGOING_NOTIFICATION_ID, notification) 5、IntentService用来执行耗时操作的 Service 的子类。 实现 onHandleIntent()，该方法会接收每个启动请求的 Intent，以便您执行后台工作。 1234567891011121314151617181920212223/** * A constructor is required, and must call the super [android.app.IntentService.IntentService] * constructor with a name for the worker thread. */class HelloIntentService : IntentService(&quot;HelloIntentService&quot;) { /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ override fun onHandleIntent(intent: Intent?) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } }} 重写其他回调方法，（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现 例如，onStartCommand() 必须返回默认实现，即如何将 Intent 传递给 onHandleIntent()： 1234override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() return super.onStartCommand(intent, flags, startId)} 启动 123Intent(this, HelloService::class.java).also { intent -&gt; startService(intent)} 扩展服务类借助 IntentService，您可以非常轻松地实现启动服务。但是，若要求服务执行多线程（而非通过工作队列处理启动请求），则可通过扩展 Service 类来处理每个 Intent。 为进行比较，以下示例代码展示了 Service 类的实现，该类执行的工作与上述使用 IntentService 的示例完全相同。换言之，对于每个启动请求，其均使用工作线程来执行作业，且每次仅处理一个请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class HelloService : Service() { private var serviceLooper: Looper? = null private var serviceHandler: ServiceHandler? = null // Handler that receives messages from the thread private inner class ServiceHandler(looper: Looper) : Handler(looper) { override fun handleMessage(msg: Message) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1) } } override fun onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND).apply { start() // Get the HandlerThread's Looper and use it for our Handler serviceLooper = looper serviceHandler = ServiceHandler(looper) } } override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job serviceHandler?.obtainMessage()?.also { msg -&gt; msg.arg1 = startId serviceHandler?.sendMessage(msg) } // If we get killed, after returning from here, restart return START_STICKY } override fun onBind(intent: Intent): IBinder? { // We don't provide binding, so return null return null } override fun onDestroy() { Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show() }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Service/"},{"title":"Gradle——Android Build 构建配置","text":"Android 构建系统会编译应用资源和源代码，然后将它们打包到 APK 或 Android App Bundle 中，供测试、部署、签名和分发。Android Studio 会使用高级构建工具包 Gradle 自动执行和管理构建流程，同时也允许定义灵活的自定义 build 配置。 参考: 配置 build | Android 开发者 | Android Developers 史上最全Android build.gradle配置详解，你懂的！ - 掘金 (juejin.cn) 1、构建流程典型 Android 应用模块的构建流程按照以下常规步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。 打包器将 DEX 文件和编译后的资源组合成 APK 或 AAB（具体取决于所选的 build 目标）。 必须先为 APK 或 AAB 签名，然后才能将应用安装到 Android 设备或分发到 Google Play 等商店。 打包器使用调试或发布密钥库为 APK 或 AAB 签名： 如果您构建的是调试版应用（即专门用来测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库（您需要进行配置）为应用签名。如需创建发布密钥库，请参阅在 Android Studio 中为应用签名。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，您将获得应用的调试版或发布版 APK/AAB，以用于部署、测试或向外部用户发布。 2、配置文件1、Gradle 设置文件settings.gradle 文件位于项目的根目录下，用于指示 Gradle 在构建应用时应将哪些模块包含在内。 123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;hhuer&quot;include(&quot;:app&quot;) 2、项目 build 文件顶层 build.gradle 文件位于项目的根目录下，用于定义适用于项目中所有模块的构建配置。 默认情况下，顶层 build 文件使用 buildscript 代码块定义项目中所有模块共用的 Gradle 代码库和依赖项。 1234567891011121314151617buildscript { // gradle脚本执行所需依赖 repositories { // 配置远程仓库 google() // 引用google上的开源项目 mavenCentral() // 引用 jcenter上的开源项目，现已经替换为 mavenCenter } dependencies { // 配置构建工具 classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0-M1&quot;) }}// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 配置项目全局属性 项目包含多个模块时，可以在文件中添加公用配置。 123456789101112buildscript {...}allprojects {...}// 使用mapextra[&quot;compileSdkVersion&quot;] = 28// You can also create properties to specify versions for dependencies.// Having consistent versions between modules can avoid conflicts with behavior.extra[&quot;supportLibVersion&quot;] = &quot;28.0.0&quot;// 或者使用 Kotlin 委托 https://www.runoob.com/kotlin/kotlin-delegated.htmlval compileSdkVersion by extra(31)val supportLibVersion by extra(&quot;28.0.0&quot;) 在模块中使用以下代码引用即可： 123val sdkVersion: Int by rootProject.extra...compileSdkVersion(sdkVersion) 注意：虽然 Gradle 可让您在模块级别定义项目全局属性，但您应避免这样做，因为这样会导致共享这些属性的模块相互结合。模块结合使得以后将模块作为独立项目导出更加困难，并实际妨碍 Gradle 利用并行项目执行加快多模块构建。 3、模块 build 文件模块级 build.gradle 文件位于每个 project/module/ 目录下，用于为其所在的特定模块配置构建设置。您可以通过配置这些 build 设置提供自定义打包选项（如额外的 build 类型和产品变种），以及替换 main/ 应用清单或顶层 build.gradle 文件中的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}// 上面全局配置的引用val androidTargetSdkVersion: Int by rootProject.extra// 配置项目构建的各种属性android { compileSdk = androidCompileSdkVersion //设置编译时用的Android版本 ... defaultConfig { // app 相关 applicationId = defaultManagerPackageName // 包名 minSdk = androidMinSdkVersion // 最低兼容版本 targetSdk = androidTargetSdkVersion // 目标安卓版本 versionCode = verCode // 版本号 versionName = verName // 版本名称 //若使用AndroidJUnitRunner进行单元测试 //testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } //指定生成安装文件的主要配置，一般包含两个子闭包: //一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写； //另一个是release闭包，用于指定生成正式版安装文件的配置。 buildTypes { release { // 一般使用如下两项 isMinifyEnabled = false //是否对代码进行混淆 proguardFiles(&quot;proguard-rules.pro&quot;) //指定混淆的规则文件 } } compileOptions { sourceCompatibility(androidSourceCompatibility) targetCompatibility(androidTargetCompatibility) } kotlinOptions { jvmTarget = &quot;1.8&quot; } packagingOptions{//打包时的相关配置 //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' }}dependencies { // 项目的依赖 // Dependency on a local library module implementation project(&quot;:mylibrary&quot;) // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3' ...}configurations.all { exclude(group = &quot;androidx.appcompat&quot;, module = &quot;appcompat&quot;)} 4、更多模块配置项设置应用 ID添加构建依赖项Android Gradle 插件可以使用的原生依赖项优化构建速度排查构建性能问题分析构建性能配置 build 变体构建多个 APK合并多个清单文件将构建变量注入清单缩减、混淆处理和优化应用为方法数超过 64K 的应用启用 MultiDex 使用 APK 分析器分析您的 build使用 Maven Publish 插件Gradle 提示与诀窍将构建配置从 Groovy 迁移到 KTS 此部分可以参考 Gradle—从Groovy迁移到KTS - Sakurasou (sukiu.top)","link":"/Android/Gradle%E2%80%94Build%E6%9E%84%E5%BB%BA/"},{"title":"Gradle——从Groovy迁移到KTS","text":"在Android Studio中将Gradle配置从 Groovy 迁移到 KTS，即用 Kotlin 代替 Groovy 编写Gradle脚本。 参考： 官方文档 将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers 知乎 快速迁移 Gradle 脚本至 KTS - 知乎 (zhihu.com) 1、转换规则 Groovy 允许使用单引号来定义字符串，而 Kotlin 则要求使用双引号： 即include ':app' -&gt; include &quot;:app&quot; // '(.*?[^\\\\])' 正则替换 &quot;$1&quot; 在 Groovy 中使用 $ 前缀来表示基于句点表达式的字符串插值，但在 Kotlin 中需要使用大括号括住整个变量： 即myRootDirectory = &quot;$project.rootDir/tools&quot; 改为：myRootDirectory = &quot;${project.rootDir}/tools&quot; 显式和隐式 buildTypes：在 KTS 中，仅 debug 和 release buildTypes 是隐式提供的，而 staging 则必须手动创建 12345678910buildTypes getByName(&quot;debug&quot;) { ... } getByName(&quot;release&quot;) { ... } create(&quot;staging&quot;) { ... } 使用 plugins 代码块：给方法调用加上括号 1234567// (\\w+) (([^=\\{\\s]+)(.*)) 正则替换 $1($2)plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;) id(&quot;kotlin-kapt&quot;) id(&quot;androidx.navigation.safeargs.kotlin&quot;)} 更多请参考 Gradle | Kotlin (kotlinlang.org) 2、逐个迁移按上述转换规则逐个迁移以下文件，每迁移一个文件，都 sync 一遍查看是否出现问题。 下列每个迁移前，先把文件扩展名添加为 *.gradle.kts 1、迁移 setting.gradle123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;your app name&quot;include(&quot;:app&quot;) 2、迁移项目的 build.gradle1234567891011121314buildscript { repositories { google() mavenCentral() } dependencies { classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20&quot;) }}tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 3、迁移模块的 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}android { compileSdk = 30 defaultConfig { applicationId = &quot;github.sukieva.hhuer&quot; minSdk = 24 targetSdk = 30 versionCode = 1 versionName = &quot;1.0&quot; } buildTypes { release { isMinifyEnabled = false proguardFiles(&quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility(JavaVersion.VERSION_1_8) targetCompatibility(JavaVersion.VERSION_1_8) } kotlinOptions { jvmTarget = &quot;1.8&quot; }}dependencies { implementation(&quot;androidx.core:core-ktx:1.6.0&quot;) implementation(&quot;androidx.appcompat:appcompat:1.3.1&quot;) implementation(&quot;com.google.android.material:material:1.4.0&quot;) implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.0&quot;) testImplementation(&quot;junit:junit:4.+&quot;) androidTestImplementation(&quot;androidx.test.ext:junit:1.1.3&quot;) androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.4.0&quot;)} 3、代码优化可以在项目的build.gradle.kts里添加定义属性，在其他配置文件可直接访问。 12345678910val defaultManagerPackageName by extra(&quot;github.sukieva.hhuer&quot;)val verCode by extra(20210924)val verName by extra(&quot;1.0&quot;)val androidTargetSdkVersion by extra(31)val androidMinSdkVersion by extra(27)val androidBuildToolsVersion by extra(&quot;31.0.0&quot;)val androidCompileSdkVersion by extra(31)val androidCompileNdkVersion by extra(&quot;23.0.7599858&quot;)val androidSourceCompatibility by extra(JavaVersion.VERSION_11)val androidTargetCompatibility by extra(JavaVersion.VERSION_11) 3、可能出现的问题1、code insight unavailable因为期间重启过几次Android Studio不太确定怎么排除的，可能切换kotlin到dev版能解决此问题。","link":"/Android/Gradle%E2%80%94Gradle%E8%BF%81%E7%A7%BBkts/"},{"title":"Jetpack——Compose","text":"使用 JetpackCompose 的一些笔记。 关键术语 - 组合：Jetpack Compose 在执行可组合项时构建的界面描述。 初始组合：通过首次运行可组合项创建组合。 重组：在数据发生变化时重新运行可组合项以更新组合。 'Surface' A surface container using the 'background' color from the theme 'Divider' is a provided composable function that creates a horizontal divider. 可组合项中的状态可组合函数可以使用 remember 可组合项记住单个对象。 系统会在初始组合期间将由 remember 计算的值存储在组合中，并在重组期间返回存储的值。 remember 既可用于存储可变对象，又可用于存储不可变对象。 mutableStateOf会创建可观察的 MutableState 会创建可观察的 MutableState，后者是与 Compose 运行时集成的可观察类型。 在可组合项中声明 MutableState 对象的方法有三种（等价）： val mutableState = remember { mutableStateOf(default) } var value by remember { mutableStateOf(default) } val (value, setValue) = remember { mutableStateOf(default) } 1234567@Composablefun Counter() { val count = remember { mutableStateOf(0) } Button(onClick = { count.value++ }) { Text(&quot;I've been clicked ${count.value} times&quot;) }} Color primary：main brand color secondary：provide accents Typography","link":"/Android/Jetpack%E2%80%94Compose/"},{"title":"Jetpack——Lifecycle","text":"Lifecycle组件可以让任何一个类都能轻松感知到Activity的生命周期，同时不需要再Activity中编写太多额外的逻辑。 参考： Lifecycle | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期生命周期和状态事件如图所示：","link":"/Android/Jetpack%E2%80%94Lifecycle/"},{"title":"Jetpack——ViewModel","text":"ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。 参考： ViewModel 概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期ViewModel的一个重要作用是帮助Activity分担部分工作，专门用来存放与界面相关的数据，减轻Activity负担。 另外，如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。而ViewModel的生命周期和Activity不同，只有Activity退出时才会跟着一起销毁。 ViewModel对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失： 对于 activity，是在 activity 完成时； 对于 fragment，是在 fragment 分离时。 通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel","link":"/Android/Jetpack%E2%80%94ViewModel/"},{"title":"KMP","text":"KMP主要应用在字符串匹配上。 KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 说明借用了这篇博客的一些插图和理解 next数组就是一个前缀表（prefix table）：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 假设 匹配串 S， 模式串 T 最长公共前后缀 ：ABCAB 公共前后缀 是 ABABABA 公共前后缀 是 ABAABCABC 公共前后缀 是 ABC 如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图 又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2 将 j 移到 2 （i=5，j=2） 所以，重点要求 next 数组： next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值（最长公共前后缀的长度） 考虑四种情况： ① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1 ② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0 ③ X [ k ] = X [ j ]匹配到这个位置说明失配位置前 公共前后缀相等，即X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度）那么，X [ 0…k ] = X [ j-k…j ]所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1) ④ X [ k ] != X [ j ]next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀)此时，将前缀移到后缀位置，即指针前移到最长公共前后缀的长度位置，可以得出：k = next [ k ] 不过，这样求得的 next 数组还有缺陷： 按照前述，j 移到 最长公共前后缀长度 1 的位置： 这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 X[ j ] = X[ next[ j ] ] 的情况没有意义 代码随想录动图示例： 代码GO12345678910111213141516171819202122232425262728293031323334353637383940func getNext(next []int, s string) { i, j := 0, -1 next[0] = j for i &lt; len(s) { for j !=-1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ if i &gt;= len(s) || j &gt;= len(s) { return } if s[i] == s[j] { // 优化去重 next[i] = next[j] } else { next[i] = j } }}func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) i, j := 0, 0 for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) { for j !=-1 &amp;&amp; haystack[i] != needle[j] { j = next[j] } i++ j++ } if j == len(needle) { return i - j } else { return -1 }} C++123456789101112131415161718192021222324252627int nx[maxn];void getnx(string x){ int m=x.size(); int i,j; j=nx[0]=-1; i=0; while (i&lt;m){ while (-1!=j &amp;&amp; x[i]!=x[j]) j=nx[j]; if (x[++i]==x[++j]) nx[i]=nx[j]; else nx[i]=j; }}//输出第一次出现的位置int kmp(string s, string t) { //s为匹配串，t为模式串 int n=s.size(); int m=t.size(); int i=0,j=0; getnx(t); while (i&lt;n &amp;&amp; j&lt;m) { while (-1!=j &amp;&amp; s[i]!=t[j]) j=nx[j]; i++; j++; } if (j==m) return i-j; else return -1;} 性质数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 即最小的循环节 12345678910111213141516171819202122232425func getNext(next []int, s string) { // 计算后缀，不需要去重 i, j := 0, -1 next[0] = j for i &lt; len(s) { for j != -1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ next[i] = j }}func repeatedSubstringPattern(s string) bool { // if len(s) == 0 { return false } next := make([]int, len(s)+1) // 多+1 计算末位最长前后缀 getNext(next, s) l := len(s) if next[l] != 0 &amp;&amp; l%(l-next[l]) == 0 { return true } return false}","link":"/Algorithm/KMP/"},{"title":"Language——Kotlin","text":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 用了Kotlin就不想回到Java，本文主要记录一些高级用法 参考： Android 上的 Kotlin 协程 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 更多细节可查看：基本语法 - Kotlin 语言中文站 (kotlincn.net) 1、基本知识区间 左闭右闭：0..10 左闭右开：0 unitil 10 (step 2) 降序（左闭右闭）：10 downto 1 类主构造函数12345class Examle(...){ init{ ... }} 次构造函数不常用，一般直接指定默认值 1234class Examle(...){ constructor(...) : this(...){} sonstructor() : this (...){}} 修饰符 public：（默认）对所有类可见 private：对当前类内部可见 protected：对当前类和子类可见 internal：对同一模块的类可见 数据类和单例类 数据类：data class，等同于 Java 中一长串的 bean 单例类：object，等同于 Java 中的单例模式（全局至多只有一个实例） Lambda简而言之，就是可以作为参数传递的代码。 太常用也太多了，写写就会了 2、标准函数只介绍最常用的3个 with一个非扩展函数：上下文对象作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（this）使用。 返回值是 lambda 表达式结果。 接收2个参数： 任意类型的对象 Lambda表达式 12345678910val result = with(obj){ // obj 上下文 &quot;value&quot; // with 返回值}val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)with(numbers) { println(&quot;'with' is called with argument $this&quot;) println(&quot;It contains $size elements&quot;)} run上下文对象 作为接收者（this）来访问。 返回值 是 lambda 表达式结果。 run 和 with 做同样的事情，但是调用方式和 let 一样——作为上下文对象的扩展函数. 当 lambda 表达式同时包含对象初始化和返回值的计算时，run 很有用。 12345678910val result = service.run { port = 8080 query(prepareRequest() + &quot; to port $port&quot;)}// 同样的代码如果用 let() 函数来写:val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)} apply上下文对象 作为接收者（this）来访问。 返回值 是上下文对象本身。 对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用 apply。apply 的常见情况是对象配置。这样的调用可以理解为“将以下赋值操作应用于对象”。 12345val adam = Person(&quot;Adam&quot;).apply { age = 32 city = &quot;London&quot; }println(adam) 函数选择为了选择合适的作用域函数，它们之间的主要区别表。 函数 对象引用 返回值 是否是扩展函数 let it Lambda 表达式结果 是 run this Lambda 表达式结果 是 run - Lambda 表达式结果 不是：调用无需上下文对象 with this Lambda 表达式结果 不是：把上下文对象当做参数 apply this 上下文对象 是 also it 上下文对象 是 3、拓展函数和运算符重载拓展函数基本格式： 123fun ClassName.methodName(pararm: Int):Int{ return 0} 例子： 123fun String.showToast(duration: Int = Toast.LENGTH_SHORT) { Toast.makeToast(MyApp.context, this, duration).show()} 运算符重载例子： 12345class Money(val value:Int){ operator fun plus(money:Money):Money{ return Money(value+money.value) }} 4、高阶函数和内联函数高阶函数如果一个函数接收另一个函数作为参数，或者韩非子的类型是另一个函数，则称之为高阶函数。 基本规则：() -&gt; Unit 例子如下，相当于能嵌套函数 123fun CardItem( onClick: () -&gt; Unit = {}) 内联函数高阶函数实现的 Lambda 表达式在底层被转换为匿名类，每次调用都会创建一个新的匿名类实例，造成额外开销 函数前添加inline可消除开销：inline fun example(){} 5、泛型和委托泛型一般编程模式下，需要给任何一个变量指定具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样的代码会有更好的拓展性。 泛型类： 12345678class MyClass&lt;T&gt;{ fun method(param: T): T{ return param }}val myClass = MyClass&lt;Int&gt;() // 指定 Int 泛型val result = myClass.method(123) // 得到 Int 返回值 泛型方法： 1234567891011class MyClass{ fun &lt;T&gt; method(param: T): T{ return param }}val myClass = MyClass()val result = myClass.method&lt;Int&gt;(123)// kotlin 可以自动识别val result = myClass.method(123) 范围： 可通过 &lt;T : Number&gt;的形式指定范围，此时只允许数字类型，字符串会报错 默认类型可空，即Any?，不想为空可改为Any 委托委托是一种设计模式，操作对象自己不会去处理某段逻辑，而是把工作委托给另外一个辅助对象处理。 类委托： 借助委托可以轻松自己实现类，以下通过Hashset自定义一个类：by是实现委托的关键字 1234class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet{ fun helloworld() = println(&quot;hello world&quot;) override fun isEmpty = false} 属性委托： 将一个属性（字段）的具体实现委托给另一个类去完成 1234567891011121314151617181920class MyClass{ val p by Delegate()}// 调用 p 时，自动调用 Delegate类的 getValue 方法，赋值时调用 setValue 方法// 以下是标准的实现class Delegate{ var propValue: Any? = null // 参数1: 指定该类的委托在什么类可以使用 // 参数2: Kotlin属性操作类，可用于获取各种属性相关的值 operator fun getValue(myClass: MyClass, prop: Kproperty&lt;*&gt;): Any?{ return propValue } operator fun setValue(myClass: MyClass, prop: Kproperty&lt;*&gt;, value: Any?): Any?{ propValue = value } } 泛型实化指定泛型的实际类型 inline fun &lt;reified T&gt; start(block: Intent.() -&gt; Unit = {}){} 此时就可以得到T::class.java类型： 1val intent = Intent(context, T::class.java) 泛型协变和逆变 Todo 6、协程可以理解为轻量级的线程，可以在单线程中模拟多线程效果，与线程不同点在于： 线程依靠操作系统调度实现不同线程切换 协程在编程语言层面实现不同协程切换，大大提高并发编程的运行效率 特点：协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的特点包括： 轻量：可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。 内存泄漏更少：使用结构化并发机制在一个作用域内执行多项操作。 内置取消支持：取消操作会自动在运行中的整个协程层次结构内传播。 Jetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。 作用域构建器Tips： delay()：让当前协程延迟指定时间再运行，会阻塞挂起函数，只会挂起当前协程，不会影响其他协程执行 suspend：将任意函数声明为挂起函数，挂起函数间可以互相调用 作用域 GlobalScope.launch{}：顶层协程（不建议用） runBlocking{}：作用域内所有代码和子协程没有全部执行完之前一直阻塞当前线程（测试用，生产可能有性能问题） launch：在作用域内创建多个协程 coroutineScope{}：继承外部协程作用域并创建一个子协程，配合suspend使用，和runBlocking类似，用于生产环境 123suspend fun printDot() = coroutineScope{ launch{}} 常用写法 123456val job = Job()val scope = CoroutineScope(job)scope.launch{ //...}job.cancel() // 取消作用域内所有协程 获取执行结果调用async后，代码立即执行，如果调用await()时还没执行完，则会阻塞当前协程，直到获得async执行结果 12345runBlocking{ val result = async{ 5+5 }.await()} withContext是一个挂起函数，可以理解为async的一种简化版写法： 12345runBlocking{ val result = withContext(Dispatchers.Default){ 5+5 }} 线程参数除了coroutineScope，其他函数都可以指定线程参数，withContext必须，其他可选 Dispatchers.Default：默认低并发线程策略 Dispatchers.IO：较高并发的线程策略 Dispatchers.Main：不会开启子线程，在 Android 主线程执行（只在安卓中使用） Android 中要求网络请求必须在线程执行，定义协程也不行","link":"/Language/Language%E2%80%94Kotlin/"},{"title":"MonotoneQueue 单调队列","text":"“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 参考： 代码随想录 (programmercarl.com) 1、介绍单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下： 2、实现 保证队列里单调递减或递增的原则，所以叫做单调队列。 以下不是固定写法： 12345678910111213141516171819202122232425262728293031323334type MonotoneQueue struct { queue []int}func Constructor() MonotoneQueue { return MonotoneQueue{ queue: make([]int, 0), }}func (this *MonotoneQueue) Front() int { return this.queue[0]}func (this *MonotoneQueue) Back() int { return this.queue[len(this.queue)-1]}func (this *MonotoneQueue) Empty() bool { return len(this.queue) == 0}func (this *MonotoneQueue) Push(x int) { for !this.Empty() &amp;&amp; x &gt; this.Back() { this.queue = this.queue[:len(this.queue)-1] } this.queue = append(this.queue, x)}func (this *MonotoneQueue) Pop(x int) { if !this.Empty() &amp;&amp; this.Front() == x { this.queue = this.queue[1:] }}","link":"/Data-structure/MonotoneQueue/"},{"title":"PriorityQueue Go 优先队列","text":"论如何在 Go 语言中使用优先队列。 参考： Go标准库中文文档 (cngolib.com) 1、介绍Go 提供了 container/heap 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 index = 0 的值是最小的，即最小堆。 堆也是实现优先队列 Priority Queue 的常用方式。 堆中元素的类型需要实现 heap.Interface 这个接口： 12345type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1.} 其中 sort.Interface 包括 Len(), Less, Swap 方法。 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041type IntHeap [][2]int // 0 key 1 valuefunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i][1] &lt; h[j][1] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.([2]int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 347. 前 K 个高频元素// https://leetcode-cn.com/problems/top-k-frequent-elements/func topKFrequent(nums []int, k int) []int { m := make(map[int]int) ans := make([]int, k) h := &amp;IntHeap{} heap.Init(h) for _, v := range nums { m[v]++ } for key, value := range m { heap.Push(h, [2]int{key, value}) if h.Len() &gt; k { heap.Pop(h) } } for k &gt; 0 { k-- ans[k] = heap.Pop(h).([2]int)[0] } return ans}","link":"/Data-structure/PriorityQueue/"},{"title":"Queue","text":"与栈类似，队列是一种先进先出的容器适配器。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 1、定义 在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。 2、实现为了实现队列，我们可以使用动态数组和指向队列头部的索引。 简单的参考实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;class MyQueue { private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() {p_start = 0;} /** Insert an element into the queue. Return true if the operation is successful. */ bool enQueue(int x) { data.push_back(x); return true; } /** Delete an element from the queue. Return true if the operation is successful. */ bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; /** Get the front item from the queue. */ int Front() { return data[p_start]; }; /** Checks whether the queue is empty or not. */ bool isEmpty() { return p_start &gt;= data.size(); }};int main() { MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; }} 缺点上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。 所以应该规定数组的长度，一组一组队列的进行使用。","link":"/Data-structure/Queue/"},{"title":"Stack","text":"栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。 STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 代码随想录 (programmercarl.com) 1、介绍在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。 与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。 2、实现从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 动态数组实现参考： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack { private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) { data.push_back(x); } /** Checks whether the queue is empty or not. */ bool isEmpty() { return data.empty(); } /** Get the top item from the queue. */ int top() { return data.back(); } /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; }};int main() { MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) { if (!s.isEmpty()) { cout &lt;&lt; s.top() &lt;&lt; endl; } cout &lt;&lt; (s.pop() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl; }}","link":"/Data-structure/Stack/"},{"title":"二叉树遍历","text":"二叉树遍历主要包括： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 参考： 代码随想录 (programmercarl.com) 1、递归遍历递归三要素： 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历即 根-左-右 1234567891011121314func preorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var preOrder func(root *TreeNode) preOrder = func(root *TreeNode) { if root == nil { return } ans = append(ans, root.Val) preOrder(root.Left) preOrder(root.Right) } preOrder(root) return ans} 中序遍历即 左-根-右 1234567891011121314func inorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var inOrder func(root *TreeNode) inOrder = func(root *TreeNode) { if root == nil { return } inOrder(root.Left) ans = append(ans, root.Val) inOrder(root.Right) } inOrder(root) return ans} 后序遍历即 左-右-根 1234567891011121314func postorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var postorder func(root *TreeNode) postorder = func(root *TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) ans = append(ans, root.Val) } postorder(root) return ans} 2、迭代遍历要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 通过这种标记法实现二叉树的统一迭代遍历。 前序遍历12345678910111213141516171819202122232425262728func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } stack.PushBack(node) // 根 stack.PushBack(nil) } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 中序遍历12345678910111213141516171819202122232425262728func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } stack.PushBack(node) // 根 stack.PushBack(nil) if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 后序遍历12345678910111213141516171819202122232425262728func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 stack.PushBack(node) // 根 stack.PushBack(nil) if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 3、层序遍历12345678910111213141516171819202122232425func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := list.New() queue.PushBack(root) t := make([]int, 0) for queue.Len() &gt; 0 { l := queue.Len() for i := 0; i &lt; l; i++ { node := queue.Remove(queue.Front()).(*TreeNode) t = append(t, node.Val) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } } ans = append(ans, t) t = []int{} } return ans}","link":"/Algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"title":"常见容器底层","text":"各种语言下，常见容器底层整理。 参考： C++ STL容器底层数据结构总结 - 简书 (jianshu.com) C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com) 1、C++vector其底层数据结构是数组，由于能动态扩容，所以也称动态数组 特点： 随机访问：$O(1)$ 随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删 扩容规则： 新建时初始化一片空间 插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据 释放原来空间 在进行迭代器相关的修改操作时（包括扩容），所有迭代器和指针引用都会失效 map &amp; multimap &amp; set &amp; multisetmap提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。 与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。 底层数据结构均为红黑树，可以参考[教你透彻了解红黑树](The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com))。 特点： 访问、查找、删除：$O(logn)$ unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset顾名思义，以上容器是无序的，所以底层实现为哈希表，因此其查找时间复杂度理论上达到了O(n) 特点： 访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题 2、GoGo 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现 map底层数据结构是哈希表 特点： 访问、查找、删除：$O(1)$","link":"/Data-structure/%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Container","slug":"Container","link":"/tags/Container/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Data structure","slug":"Data-structure","link":"/categories/Data-structure/"}]}