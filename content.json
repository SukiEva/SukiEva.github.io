{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"comment-policy","text":"评论政策 被认为是垃圾邮件或纯属促销性质的评论将被删除。 包括相关内容的链接是允许的，但评论应与帖子主题相关。 包括亵渎在内的评论将被删除。 包含可能被视为冒犯的语言或概念的评论将被删除。 请注意，这可能包括辱骂性，威胁性，色情，冒犯性，误导性或诽谤性的语言。 直接攻击个人的评论将被删除。 骚扰其他人员的评论将被删除。 请尊重其他贡献者。 匿名评论将被删除。 此博客的所有者保留在未通知的情况下编辑或删除提交到博客的任何评论的权利。 此评论政策随时可能更改。 如果您对评论政策有任何疑问，请通过dev.suki@outlook.com告知我们。","link":"/comment-policy/index.html"},{"title":"About","text":"To do","link":"/about/index.html"}],"posts":[{"title":"Android四大组件——Activity","text":"Activity 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 main() 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。 参考： Activity 简介 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期状态每个 Activity 至多有4种状态： 运行状态：Activity 位于返回栈栈顶（系统不回收） 暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收） 停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收） 销毁状态：Activity 从返回栈移除（系统回收） 生存期为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()，另有一个onRestart()。当 Activity 进入新状态时，系统会调用其中每个回调。 onCreate()：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 onStart() 和 onResume() 方法 onStart()：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入onResume() onResume()：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态 onPause()：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据 onStop() ：当完全不可见时调用。与onPause() 的区别在于：如果新活动是对话框，onPause()执行，它不执行 onDestroy()：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态 onRestart()：由停止到运行时调用，即活动被重启 以上除了onRestart()两两对应，即： 完整生存期：onCreate()→onDestroy() 可见生存期：onStart()→onStop() 前台生存期：onResume()→onPause() 2、启动模式通过AndroidManifest.xml中为&lt;activity&gt;指定android:launchMode standard默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 singleTop在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。 singleTask在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。 Activity 一次只能有一个实例存在。 注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。 singleInstance与 &quot;singleTask&quot; 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。 该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。 即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。 用于其他应用中调用此 Activity。 3、意图显示 intent12val intent = Intent(this, SecondActivity::class.java)startActivity(intent) 隐式 intent在&lt;activity&gt;下配置&lt;intent-filter&gt;，在&lt;action&gt;中指名可以相应的action，&lt;category&gt;中添加附加信息，只有&lt;action&gt;和&lt;category&gt;同时匹配，当前活动才会响应 intent 123456&lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 12val intent = Intent(com.example.activitytest.ACTION_START) // default 默认添加categorystartActivity(intent) 向下一个 Activity 传递数据在显示 intent 中添加：intent.putExtra() 向上一个Activity 传递数据SecondActivity.kt 1234567override fun onBackPressed() { super.onBackPressed() val intent = Intent() intent.putExtra(&quot;data_return&quot;,&quot;msg...&quot;) setResult(RESULT_OK, intent) finish()} FirstActivity.ky 1234567891011val intent = ...startActivityForResult(intent, 1) // 参数2是请求码，唯一值即可override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { 1 -&gt; if (requestCode = RESULT_OK) { val retrunedData = data?.getStringExtra(&quot;data_return&quot;) } }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Activity/"},{"title":"Android四大组件——BroadcastReceiver","text":"Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似。这些广播会在所关注的事件发生时发送。 一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。 参考： 广播概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、广播类型 标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。 优点：效率高 缺点：无法被截断 系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。 优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播 缺点：效率没有标准广播高 2、系统广播Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。 可以在&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt中查看 1、动态注册程序启动之后才能接收广播 1234567891011121314151617181920212223242526lateinit var timeChangeReceiver: TimeChangeReceiveroverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) // 系统广播动作 timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) // 动态注册}override fun onDestroy() { super.onDestroy() unregisterReceiver(timeChangeReceiver) // 取消注册}// 内部类注册inner class TimeChangeReceiver : BroadcastReceiver() { // 继承 BroadcastReceiver override fun onReceive(p0: Context?, p1: Intent?) { // 不允许多线程，所以不能执行耗时操作 p0?.let { &quot;Time has changed&quot;.showToast(it) } }} 2、静态注册由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。 Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。 例外情况见 隐式广播例外情况 | Android 开发者 | Android Developers 注意：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器 1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3、自定义广播1、发送标准广播创建 BroadcastReceiver12345class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 }} 注册广播12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播123val intent = Intent(&quot;com.example.MY_BROADCAST&quot;)intent.setPackage(packageName) // 指定包名，使其成为显示广播sendBroadcast(intent) 2、发送有序广播前面与标准广播相同，发送广播时选择 sendOrderedBroadcast(intent,null) （参数2是与权限相关的字符串） 设置优先级因为有序广播可以被截断，在静态注册时指定优先级： &lt;intent-filter android:priority=&quot;100&quot;&gt; 截断使用 abortBroadcast() 123456class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 abortBroadcast() }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94BroadcastReceiver/"},{"title":"Android四大组件—ContentProvider","text":"内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。 参考： 内容提供程序 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 todo","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94ContentProvider/"},{"title":"Android Build 构建配置","text":"Android 构建系统会编译应用资源和源代码，然后将它们打包到 APK 或 Android App Bundle 中，供测试、部署、签名和分发。Android Studio 会使用高级构建工具包 Gradle 自动执行和管理构建流程，同时也允许定义灵活的自定义 build 配置。 参考: 配置 build | Android 开发者 | Android Developers 史上最全Android build.gradle配置详解，你懂的！ - 掘金 (juejin.cn) 1、构建流程典型 Android 应用模块的构建流程按照以下常规步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。 打包器将 DEX 文件和编译后的资源组合成 APK 或 AAB（具体取决于所选的 build 目标）。 必须先为 APK 或 AAB 签名，然后才能将应用安装到 Android 设备或分发到 Google Play 等商店。 打包器使用调试或发布密钥库为 APK 或 AAB 签名： 如果您构建的是调试版应用（即专门用来测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库（您需要进行配置）为应用签名。如需创建发布密钥库，请参阅在 Android Studio 中为应用签名。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，您将获得应用的调试版或发布版 APK/AAB，以用于部署、测试或向外部用户发布。 2、配置文件1、Gradle 设置文件settings.gradle 文件位于项目的根目录下，用于指示 Gradle 在构建应用时应将哪些模块包含在内。 123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;hhuer&quot;include(&quot;:app&quot;) 2、项目 build 文件顶层 build.gradle 文件位于项目的根目录下，用于定义适用于项目中所有模块的构建配置。 默认情况下，顶层 build 文件使用 buildscript 代码块定义项目中所有模块共用的 Gradle 代码库和依赖项。 1234567891011121314151617buildscript { // gradle脚本执行所需依赖 repositories { // 配置远程仓库 google() // 引用google上的开源项目 mavenCentral() // 引用 jcenter上的开源项目，现已经替换为 mavenCenter } dependencies { // 配置构建工具 classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0-M1&quot;) }}// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 配置项目全局属性 项目包含多个模块时，可以在文件中添加公用配置。 123456789101112buildscript {...}allprojects {...}// 使用mapextra[&quot;compileSdkVersion&quot;] = 28// You can also create properties to specify versions for dependencies.// Having consistent versions between modules can avoid conflicts with behavior.extra[&quot;supportLibVersion&quot;] = &quot;28.0.0&quot;// 或者使用 Kotlin 委托 https://www.runoob.com/kotlin/kotlin-delegated.htmlval compileSdkVersion by extra(31)val supportLibVersion by extra(&quot;28.0.0&quot;) 在模块中使用以下代码引用即可： 123val sdkVersion: Int by rootProject.extra...compileSdkVersion(sdkVersion) 注意：虽然 Gradle 可让您在模块级别定义项目全局属性，但您应避免这样做，因为这样会导致共享这些属性的模块相互结合。模块结合使得以后将模块作为独立项目导出更加困难，并实际妨碍 Gradle 利用并行项目执行加快多模块构建。 3、模块 build 文件模块级 build.gradle 文件位于每个 project/module/ 目录下，用于为其所在的特定模块配置构建设置。您可以通过配置这些 build 设置提供自定义打包选项（如额外的 build 类型和产品变种），以及替换 main/ 应用清单或顶层 build.gradle 文件中的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}// 上面全局配置的引用val androidTargetSdkVersion: Int by rootProject.extra// 配置项目构建的各种属性android { compileSdk = androidCompileSdkVersion //设置编译时用的Android版本 ... defaultConfig { // app 相关 applicationId = defaultManagerPackageName // 包名 minSdk = androidMinSdkVersion // 最低兼容版本 targetSdk = androidTargetSdkVersion // 目标安卓版本 versionCode = verCode // 版本号 versionName = verName // 版本名称 //若使用AndroidJUnitRunner进行单元测试 //testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } //指定生成安装文件的主要配置，一般包含两个子闭包: //一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写； //另一个是release闭包，用于指定生成正式版安装文件的配置。 buildTypes { release { // 一般使用如下两项 isMinifyEnabled = false //是否对代码进行混淆 proguardFiles(&quot;proguard-rules.pro&quot;) //指定混淆的规则文件 } } compileOptions { sourceCompatibility(androidSourceCompatibility) targetCompatibility(androidTargetCompatibility) } kotlinOptions { jvmTarget = &quot;1.8&quot; } packagingOptions{//打包时的相关配置 //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' }}dependencies { // 项目的依赖 // Dependency on a local library module implementation project(&quot;:mylibrary&quot;) // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3' ...}configurations.all { exclude(group = &quot;androidx.appcompat&quot;, module = &quot;appcompat&quot;)} 4、更多模块配置项设置应用 ID添加构建依赖项Android Gradle 插件可以使用的原生依赖项优化构建速度排查构建性能问题分析构建性能配置 build 变体构建多个 APK合并多个清单文件将构建变量注入清单缩减、混淆处理和优化应用为方法数超过 64K 的应用启用 MultiDex 使用 APK 分析器分析您的 build使用 Maven Publish 插件Gradle 提示与诀窍将构建配置从 Groovy 迁移到 KTS 此部分可以参考 Gradle—从Groovy迁移到KTS - Sakurasou (sukiu.top)","link":"/Android/Build%E6%9E%84%E5%BB%BA/"},{"title":"Gradle—从Groovy迁移到KTS","text":"在Android Studio中将Gradle配置从 Groovy 迁移到 KTS，即用 Kotlin 代替 Groovy 编写Gradle脚本。 参考： 官方文档 将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers 知乎 快速迁移 Gradle 脚本至 KTS - 知乎 (zhihu.com) 1、转换规则 Groovy 允许使用单引号来定义字符串，而 Kotlin 则要求使用双引号： 即include ':app' -&gt; include &quot;:app&quot; // '(.*?[^\\\\])' 正则替换 &quot;$1&quot; 在 Groovy 中使用 $ 前缀来表示基于句点表达式的字符串插值，但在 Kotlin 中需要使用大括号括住整个变量： 即myRootDirectory = &quot;$project.rootDir/tools&quot; 改为：myRootDirectory = &quot;${project.rootDir}/tools&quot; 显式和隐式 buildTypes：在 KTS 中，仅 debug 和 release buildTypes 是隐式提供的，而 staging 则必须手动创建 12345678910buildTypes getByName(&quot;debug&quot;) { ... } getByName(&quot;release&quot;) { ... } create(&quot;staging&quot;) { ... } 使用 plugins 代码块：给方法调用加上括号 1234567// (\\w+) (([^=\\{\\s]+)(.*)) 正则替换 $1($2)plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;) id(&quot;kotlin-kapt&quot;) id(&quot;androidx.navigation.safeargs.kotlin&quot;)} 更多请参考 Gradle | Kotlin (kotlinlang.org) 2、逐个迁移按上述转换规则逐个迁移以下文件，每迁移一个文件，都 sync 一遍查看是否出现问题。 下列每个迁移前，先把文件扩展名添加为 *.gradle.kts 1、迁移 setting.gradle123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;your app name&quot;include(&quot;:app&quot;) 2、迁移项目的 build.gradle1234567891011121314buildscript { repositories { google() mavenCentral() } dependencies { classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20&quot;) }}tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 3、迁移模块的 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}android { compileSdk = 30 defaultConfig { applicationId = &quot;github.sukieva.hhuer&quot; minSdk = 24 targetSdk = 30 versionCode = 1 versionName = &quot;1.0&quot; } buildTypes { release { isMinifyEnabled = false proguardFiles(&quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility(JavaVersion.VERSION_1_8) targetCompatibility(JavaVersion.VERSION_1_8) } kotlinOptions { jvmTarget = &quot;1.8&quot; }}dependencies { implementation(&quot;androidx.core:core-ktx:1.6.0&quot;) implementation(&quot;androidx.appcompat:appcompat:1.3.1&quot;) implementation(&quot;com.google.android.material:material:1.4.0&quot;) implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.0&quot;) testImplementation(&quot;junit:junit:4.+&quot;) androidTestImplementation(&quot;androidx.test.ext:junit:1.1.3&quot;) androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.4.0&quot;)} 3、代码优化可以在项目的build.gradle.kts里添加定义属性，在其他配置文件可直接访问。 12345678910val defaultManagerPackageName by extra(&quot;github.sukieva.hhuer&quot;)val verCode by extra(20210924)val verName by extra(&quot;1.0&quot;)val androidTargetSdkVersion by extra(31)val androidMinSdkVersion by extra(27)val androidBuildToolsVersion by extra(&quot;31.0.0&quot;)val androidCompileSdkVersion by extra(31)val androidCompileNdkVersion by extra(&quot;23.0.7599858&quot;)val androidSourceCompatibility by extra(JavaVersion.VERSION_11)val androidTargetCompatibility by extra(JavaVersion.VERSION_11) 3、可能出现的问题1、code insight unavailable因为期间重启过几次Android Studio不太确定怎么排除的，可能切换kotlin到dev版能解决此问题。","link":"/Android/Gradle%E8%BF%81%E7%A7%BBkts/"},{"title":"Android ViewBinding","text":"通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。在大多数情况下，视图绑定会替代 findViewById。 参考自： 视图绑定 | Android 开发者 | Android Developers Android | ViewBinding 与 Kotlin 委托双剑合璧 - 掘金 (juejin.cn) 1、实现原理在 Android 开发更新迭代中，Kotlin 逐渐取代 Java 成为主流开发语言，原来一些旧的使用方法也随之被取代。Android-Kotlin-Extensions 因为安全问题被官方废弃，随之就有了view binding（视图绑定）来继承对findViewById的替换。 用于更加轻量地实现视图绑定（视图与变量的绑定），可以理解为轻量版本的 DataBinding。 Android Gradle 插件会为每个 XML 布局文件创建一个绑定类，绑定类中包含布局文件中每个定义了android:id属性的 View 引用。假设布局文件为fragment_test.xml，则生成绑定类FragmentTestBinding.java； 2、使用方法1、开启视图绑定在模块的build.gradle/.kts中加入以下内容开启： 123456android { ... buildFeatures { viewBinding = true }} 如果希望生成绑定类时忽略某个布局文件，在相应的XML里加入： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 2、Activity中使用在 Activity 的 onCreate() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 将根视图传递到 setContentView()，使其成为屏幕上的活动视图。 123456789101112 private lateinit var binding: ResultProfileBinding override fun onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view) }// 后续通过以下方法引用viewbinding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 3、Fragment中使用在 Fragment 的 onCreateView() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。 注意：inflate() 方法会要求您传入布局膨胀器。如果布局已膨胀，可以调用绑定类的静态 bind() 方法。如需了解详情，请查看视图绑定 GitHub 示例中的例子。 1234567891011121314151617181920212223 private var _binding: ResultProfileBinding? = null // This property is only valid between onCreateView and // onDestroyView. private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view }// Fragment 的存在时间比其视图长。请务必在 Fragment 的 onDestroyView() 方法中清除对绑定类实例的所有引用。 override fun onDestroyView() { super.onDestroyView() _binding = null }// 后续使用binding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 为什么 Fragment#onDestroyView() 里需要置空绑定类对象，而 Activity 里不需要？ 答：Activity 实例和 Activity 视图的生命周期是同步的，而 Fragment 实例和 Fragment 视图的生命周期并不是完全同步的，因此需要在 Fragment 视图销毁时，手动回收绑定类对象，否则造成内存泄露。 例如：detach Fragment，或者 remove Fragment 并且事务进入返回栈，此时 Fragment 视图销毁但 Fragment 实例存在。 总之，在视图销毁但是控制类对象实例还存活的时机，你就需要手动回收绑定类对象，否则造成内存泄露。 3、与其他方案对比 角度 findViewById ButterKnife Kotlin Synthetics DataBinding ViewBinding 简洁性 ✖ ✖ ✔ ✔ ✔ 编译期检查 ✖ ✖ ✖ ✔ ✔ 编译速度 ✔ ✖ ✔ ✖ ✔ 支持 Kotlin &amp; Java ✔ ✔ ✖ ✔ ✔ 收敛模板代码 ✖ ✖ ✔ ✖ ✖ 简洁性： findViewById 和 ButterKnife 需要在代码中声明很多变量，其他几种方案代码简洁读较好； 编译检查： 编译期间主要有两个方面的检查：类型检查 + 只能访问当前布局中的 id。findViewById、ButterKnife 和 Kotlin Synthetics 在这方面表现较差； 编译速度： findViewById 的编译速度是最快的，而 ButterKnife 和 DataBinding 中存在注解处理，编译速度略逊色于 Kotlin Synthetics 和 ViewBinding； 支持 Kotlin &amp; Java： Kotlin Synthetics 只支持 Kotlin 语言； 收敛模板代码： 基本上每种方案都带有一定量的模板代码，只有 Kotlin Synthetics 的模板代码是较少的。","link":"/Android/ViewBinding/"}],"tags":[{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"}]}