{"pages":[{"title":"关于","text":".article-licensing{ display:none; } Stats Pinned Contributions","link":"/about/index.html"},{"title":"评论政策","text":"您需要注意： 被认为是垃圾邮件或纯属促销性质的评论将被删除。 包括相关内容的链接是允许的，但评论应与帖子主题相关。 包括亵渎在内的评论将被删除。 包含可能被视为冒犯的语言或概念的评论将被删除。 请注意，这可能包括辱骂性，威胁性，色情，冒犯性，误导性或诽谤性的语言。 直接攻击个人的评论将被删除。 骚扰其他人员的评论将被删除。 请尊重其他贡献者。 此博客的所有者保留在未通知的情况下编辑或删除提交到博客的任何评论的权利。 此评论政策随时可能更改。 如果您对评论政策有任何疑问，请通过dev.suki@outlook.com告知我们。","link":"/comment-policy/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"赞赏","text":".article-licensing{ display:none; } 如果喜欢我的博客和文章，可以考虑请我喝个茶噢~ 非常感激！","link":"/donate/index.html"},{"title":"友链","text":".article-licensing{ display:none; } 申请友链须知： 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://blog.sukiu.top/img/avatar.jpg 网站名称：千反田 网站地址：https://blog.sukiu.top/ 网站简介：我很好奇~ Github 默认给每个讨论者发送邮件通知，有两种方式忽略： 前往 Issue 点击右侧的 Unsubscribe 在收到邮件后，点击邮件中的 Unsubscribe 加载中，稍等几秒...","link":"/friends/index.html"}],"posts":[{"title":"排序","text":"常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 稳定性是指排序过程中，原来相同的元素保持原来的相对位置比如 a[i] = a[j] ，且 i&lt;j , 排序后 i&lt;j 依然成立 1、插入排序(1) 直接插入排序 时间复杂度：O(n^2)，最好 O(n)空间复杂度：O(1)稳定性：稳定 思路： 将开头元素视作已排序 执行下述过程，直到未排序过程消失： 取出未排序部分的开头元素赋给变量 v 在已排序部分，将所有比 v 大的元素向后移动一位 将已取出的元素 v 插入空位 12345678void InsertSort(int a[], int len) { for (int i=1; i&lt;len; i++) { int v=a[i]; for (int j=i-1; v&lt;a[j];j--) a[j+1]=a[j]; // 后移 a[j+1]=v; }} (2) 希尔排序 时间复杂度：平均 O(n^1.3)，最坏 O(n^2)空间复杂度：O(1)稳定性：不稳定 缩小增量法 n 个记录，增量为 di，则分组 下标 0, di, 2di, 3di, …… 为 1 组 下标 1, di +1, 2di +1, 3di +1, …… 为 1 组 下标 2, di +2, 2di +2, 3di +2, …… 为 1 组 …… …… …… …… 下标 di-1, di+di -1, 2di+di -1, …… 为 1 组 思路： 增量为 d1 时，在各组内，进行排序 减小增量，重新分组，组内排序 减小增量：初始：d1 = n/2，则模式：di+1 = di /2 重复第 2 步， 直到 di==1，所有记录在同一组，组内排序 排序均为直接插入排序 12345678910111213141516171819202122232425262728// ? 按照 ShellSort 定义写出void shellSort1(int a[], int n) { int i, j, k, gap; for (gap = n / 2; gap &gt; 0; gap /= 2) for (i = 0; i &lt; gap; i++) // 分组 for (int j = i + gap; j &lt; n; j += gap) // 组内插入排序 if (a[j] &lt; a[j - gap]) { // 直接插入排序 int v = a[j]; for (int k = j - gap; k &gt;= 0 &amp;&amp; a[k] &gt; v; k -= gap) a[k + gap] = a[k]; // 后移 a[k + gap] = v; }}// ? 优化// - 上述 i 的作用是为了确认 j 的位置，并与组内元素比较// - 明显每次 gap 与 j-gap 就是组内比较，不需要再分组void shellSort(int a[], int n) { int j, k, gap; for (gap = n / 2; gap &gt; 0; gap /= 2) for (j = gap; j &lt; n; j++) if (a[j] &lt; a[j - gap]) { int v = a[j]; for (int k = j - gap; k &gt;= 0 &amp;&amp; a[k] &gt; v; k -= gap) a[k + gap] = a[k]; // 后移 a[k + gap] = v; }} 2、交换排序(3) 冒泡排序 时间复杂度：平均 O(n^2)，最坏 O(n^2)，最好 O(n)空间复杂度：O(1)稳定性：稳定 思路： 重复执行下述处理，直到数组中不包含顺序相反的相邻元素： 1、从数组开头开始依次比较相邻两个元素，如果大小关系相反则交换位置 1234567891011void BubbleSort(int a[], int len){ for (int i=0; i&lt;len; i++){ for (int j=i+1; j&lt;len; j++){ if (a[i]&gt;a[j]){ int temp=a[i]; a[i]=a[j]; a[j]=temp; } } }} (4) 快速排序 时间复杂度：平均 O(nlogn)，最坏 O(n^2)空间复杂度：平均 O(logn)，最坏 O(n)稳定性：不稳定 思路： 以整个数组为对象执行 QuickSort QuickSort 流程如下： 1、通过分割将对象局部数组分割为前后两个局部数组 2、对前半部分的局部数组执行 QuickSort 3、对后半部分的局部数组执行 QuickSort 第 1 趟快排： 从待排序码中，选出 1 个 K（如 R0.key ） 将小于 k 的记录移动到左边（左子表）， 大于 k 的记录移动到右边（右子表）， 将 k 放在左、右两个子表的分界处 左游历下标：i=0， 右游历下标：j=n-1, 取出分区基准：temp=R[0] 初始空位 R[0]：在左表中，即 R[i] 重复以下两种扫描，直到 i==j （空位置在左，则 j 扫描；空位置在右，则 i 扫描) j 向左扫描，直到 R[j].key &lt; temp.key， 将 R[j]移动到空位 R[i]中，则 R[j]为空，令 i++ i 向右扫描，直到 R[i].key &gt; temp.key， 将 R[i]移动到空位 R[ j]中，则 R[i]为空，令 j - - 将“分区基准” temp，放到空位 R[i]中 第 2 趟快排： 对 K 左、右两个字表，分别执行 1 趟快排 - 4 个子表 … … 直到：各子表长度 ≤1 12345678910111213141516171819202122232425262728293031323334353637383940// ? 快排划分int Partition(int a[], int l, int r) { int p = a[l]; while (l &lt; r) { // l != r while (l &lt; r &amp;&amp; a[r] &gt;= p) --r; // r 向左扫描 a[l] = a[r]; while (l &lt; r &amp;&amp; a[l] &lt;= p) ++l; // l 向右扫描 a[r] = a[l]; } a[l] = p; return l;}// ? 快速排序void QuickSort(int a[], int l, int r) { if (l &lt; r) { int p = Partition(a, l, r); QuickSort(a, l, p - 1); QuickSort(a, p + 1, r); }}// ? 三数取中优化，此版本快的飞起// https://www.cnblogs.com/chengxiao/p/6262208.html// - 左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值void QuickSort(int a[], int l, int r) { int mid = a[(l + r) / 2]; int i = l, j = r; do { while (a[i] &lt; mid) i++; while (a[j] &gt; mid) j--; if (i &lt;= j) { swap(a[i], a[j]); i++; j--; } } while (i &lt;= j); if (l &lt; j) QuickSort(a, l, j); if (i &lt; r) QuickSort(a, i, r);} 3、选择排序(5) 简单选择排序 时间复杂度：平均 O(n^2)，最坏 O(n^2)空间复杂度：O(1)稳定性：不稳定 思路： 重复执行 N-1 次 下述处理： 找出未排序部分最小值的位置 minj 将 minj 位置的元素与未排序部分的起始元素交换 123456789void SelectSort(int a[], int len){ for (int i=0; i&lt;len-1; i++){ int k=i; for (int j=i+1; j&lt;len; j++){ if (a[j]&lt;a[k]) k=j; } if (i!=k) swap(a[i],a[k]); }} (6) 堆排序 时间复杂度：平均 O(nlogn)，最坏 O(nlogn)，最好 n(nlogn)空间复杂度：O(1)稳定性：不稳定 思路： 将待排序数据建立成大根堆 将待排序记录建成 1 个完全二叉树（从左往右插入），再“从后向前”依次调整 sift 1&lt;img src=&quot;https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192153994.png&quot; style=&quot;zoom:50%;&quot; /&gt; sift（待调整：x）：就是让其满足大根堆 判断“待调整 x”是否 &gt;左孩子 &amp;&amp; &gt;右孩子 是，则无需调整，结束 否，继续“调整 x”，即：重复，直到 x 与孩子满足堆序性，或 x 成为叶子 从最后结点的父亲开始，最后结点下标：n-1 父亲下标 p= (n-1-1)/2 “从后向前”：依次调整 p, p-1, p-2, …, 0 之后 sift (3)，sift(2)，sift(1)，sift(0)，构成大根堆 重复：选出最大值（堆顶）、并调整剩余部分（较大的孩子上升，空位置下降 以此类推，直到堆无剩余元素 123456789101112131415161718192021222324252627282930// - 图解 https://www.cnblogs.com/chengxiao/p/6129630.html// ? 调整以 k 为根的子树，即 shift 操作// - 大孩子上升，空位置下降void HeadAdjust(int a[], int k, int len) { int t = a[k]; for (int i = k * 2 + 1; i &lt; len; i = i * 2 + 1) { // 如果左子结点小于右子结点，i指向右子结点 if (i + 1 &lt; len &amp;&amp; a[i] &lt; a[i + 1]) i++; // 如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） if (a[i] &gt; t) { a[k] = a[i]; k = i; } else break; } a[k] = t; // t 放在最终位置}// ? 堆排序void HeapSort(int a[], int len) { int i; // - 建立大根堆 for (i = len / 2 - 1; i &gt;= 0; i--) HeadAdjust(a, i, len); // - 交换堆顶堆低元素 + 调整堆结构 for (i = len - 1; i &gt;= 0; i--) { swap(a[i], a[0]); HeadAdjust(a, 0, i); }} 4、其他排序(7) 归并排序 时间复杂度： O(nlogn) (好、坏、平均)空间复杂度：O(n)稳定性：稳定 思路： 以整个数组为对象执行 mergeSort mergeSort： 将给定包含 n 个元素的局部数组分割成两个局部数组 对局部数组分别 mergeSort 通过 merge 将两个已排序的数组整合为一个数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Merge(int a[], int begin, int mid, int end) { int left = begin, right = mid + 1, k = 0; int *temp = new int[end - begin + 1]; //顺序选取两个有序区的较小元素，存储到t数组中 while (left &lt;= mid &amp;&amp; right &lt;= end) { //较小的先存入temp中 if (a[left] &lt;= a[right]) temp[k++] = a[left++]; else temp[k++] = a[right++]; } //若比较完之后，有序区仍有剩余，则直接复制到t数组中 while (left &lt;= mid) temp[k++] = a[left++]; while (right &lt;= end) temp[k++] = a[right++]; //将排好序的存回arr中 for (int i = begin, k = 0; i &lt;= end; i++, k++) a[i] = temp[k]; //删除指针，释放空间 delete[] temp;}// ? 递归void MergeSort(int a[], int begin, int end) { if (begin &lt; end) { int mid = (begin + end) / 2; MergeSort(a, begin, mid); // 左侧递归 MergeSort(a, mid + 1, end); // 右侧递归 Merge(a, begin, mid, end); // 归并 }}// ? 非递归void MergeSort2(int a[], int n) { int size = 1, begin, mid, end; while (size &lt;= n - 1) { begin = 0; while (begin + size &lt;= n - 1) { mid = begin + size - 1; end = mid + size; if (end &gt; n - 1) //第二个序列个数不足size end = n - 1; Merge(a, begin, mid, end); begin = end + 1; //下一次归并时第一关序列的下界 } size *= 2; //扩大范围 }} (8) 基数排序 时间复杂度： O(d(n+r)) d: d 趟分配和收集空间复杂度：O(r) r: r 个队列稳定性：稳定 看图理解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// ? 辅助函数，求数据的最大位数 int maxbit(int data[], int n) { int maxData = data[0]; ///&lt; 最大数 /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。 for (int i = 1; i &lt; n; ++i) { if (maxData &lt; data[i]) maxData = data[i]; } int d = 1; int p = 10; while (maxData &gt;= p) { // p *= 10; // Maybe overflow maxData /= 10; ++d; } return d; /* int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i &lt; n; ++i){ while(data[i] &gt;= p){ p *= 10; ++d; } } return d;*/ } // ? 基数排序 void Radixsort(int data[], int n) { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for (i = 1; i &lt;= d; i++) //进行d次排序 { for (j = 0; j &lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for (j = 0; j &lt; n; j++) { k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; } for (j = 1; j &lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for (j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for (j = 0; j &lt; n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; } delete[] tmp; delete[] count; } 5、排序比较","link":"/Algorithm/All-Sort/"},{"title":"Android四大组件——ContentProvider","text":"内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。 参考： 内容提供程序 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 todo","link":"/Android/Android-ContentProvider/"},{"title":"Android四大组件——Activity","text":"Activity 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 main() 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。 参考：Activity 简介 | Android 开发者 | Android Developers《第一行代码 Android 第3版》 1、生命周期状态每个 Activity 至多有4种状态： 运行状态：Activity 位于返回栈栈顶（系统不回收） 暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收） 停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收） 销毁状态：Activity 从返回栈移除（系统回收） 生存期为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()，另有一个onRestart()。当 Activity 进入新状态时，系统会调用其中每个回调。 onCreate()：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 onStart() 和 onResume() 方法 onStart()：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入onResume() onResume()：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态 onPause()：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据 onStop() ：当完全不可见时调用。与onPause() 的区别在于：如果新活动是对话框，onPause()执行，它不执行 onDestroy()：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态 onRestart()：由停止到运行时调用，即活动被重启 以上除了onRestart()两两对应，即： 完整生存期：onCreate()→onDestroy() 可见生存期：onStart()→onStop() 前台生存期：onResume()→onPause() 2、启动模式通过AndroidManifest.xml中为&lt;activity&gt;指定android:launchMode standard默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 singleTop在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。 singleTask在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。 Activity 一次只能有一个实例存在。 注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。 singleInstance与 &quot;singleTask&quot; 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。 该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。 即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。 用于其他应用中调用此 Activity。 3、意图显示 intent12val intent = Intent(this, SecondActivity::class.java)startActivity(intent) 隐式 intent在&lt;activity&gt;下配置&lt;intent-filter&gt;，在&lt;action&gt;中指名可以相应的action，&lt;category&gt;中添加附加信息，只有&lt;action&gt;和&lt;category&gt;同时匹配，当前活动才会响应 intent 123456&lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 12val intent = Intent(com.example.activitytest.ACTION_START) // default 默认添加categorystartActivity(intent) 向下一个 Activity 传递数据在显示 intent 中添加：intent.putExtra() 向上一个Activity 传递数据SecondActivity.kt 1234567override fun onBackPressed() { super.onBackPressed() val intent = Intent() intent.putExtra(&quot;data_return&quot;,&quot;msg...&quot;) setResult(RESULT_OK, intent) finish()} FirstActivity.ky 1234567891011val intent = ...startActivityForResult(intent, 1) // 参数2是请求码，唯一值即可override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { 1 -&gt; if (requestCode = RESULT_OK) { val retrunedData = data?.getStringExtra(&quot;data_return&quot;) } }}","link":"/Android/Android-Activity/"},{"title":"Android四大组件——Service","text":"Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。 参考： 服务概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、多线程一般耗时的服务都需要放在子线程中运行，否则会造成主线程阻塞，从而影响用户使用。 基本用法 继承Thread 1234567class MyThread : Thread(){ override fun fun(){ // ... }}// 开始运行MyThread().start() 上面的方法耦合性过高，一般使用Runnable接口 12345678class MyThread : Runnable{ override fun fun(){ // ... }}// 开始运行val myThread = MyThread()Thread(myThread).start() 更为常见的方法是使用Lambda表达式，不需要专门定义一个类 123456789Thread { // ...}.start()// 在Kotlin中可以写为： 不需要调用 start()thread{ // ...} 子线程更新UIAndroid 的 UI 是线程不安全的，直接在子线程中进行 UI 操作会出现异常。不过，Android 提供了异步消息处理机制Handler。 主要包含以下部分： Message：线程间传递的消息，可以在内部携带少量消息 Handler：处理者，用于发送和处理消息 MessageQueue：消息队列，用于存放通过Handler发送的消息，每个线程只有一个 Looper：每个线程中MessageQueue的管家，调用Looper的loop()后开始循环取出MessageQueue中的消息，并传递到Handler的handleMessage()中，每个线程只有一个 12345678910111213141516val updateText = 1val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) when (msg.what) { updateText -&gt; //... // ... } } }thread{ val msg = Message() msg.what = updateText handler.sendMessage(msg) // 发送消息} AsyncTask 在 API30 被Google废弃，转而推荐使用 将 Kotlin 协程与生命周期感知型组件一起使用 | Android 开发者 | Android Developers 2、Service生命周期最常使用的回调方法是：onBind()、onCreate、onStartCommand、onDestroy onCreate：在 Service 创建（仅第一次）的时候调用 onStartCommand：在 Service 启动（每次）的时候调用 onDestroy：在 Service 销毁时调用 每个 Service 只会存在一个实例 3、Service基本用法启动和停止123val intent = Intent(this, MyService::class.java)startService(intent) // 启动stopService(intent) // 停止 与Activity通信在活动中控制服务的具体执行，而不是启动后就无法控制。 通过Bind实现： 123456789101112131415class MyService : Service() { private val mBinder = DownloadBinder() override fun onBind(intent: Intent): IBinder { return mBinder } class DownloadBinder : Binder() { fun startDownload() { //... } }} 在活动中创建： 1234567891011121314151617var downloadBinder = MyService.DownloadBinder()private val connection = object:ServiceConnection{ // 匿名类 override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) { // 绑定时调用 downloadBinder = p1 as MyService.DownloadBinder downloadBinder.startDownload() // 可自由选择 Service 中的方法 } override fun onServiceDisconnected(p0: ComponentName?) { // 进程崩溃或被杀掉时调用，不常用 TODO(&quot;Not yet implemented&quot;) }}val intent = Intent(this, MyService::class.java)bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service// BIND_AUTO_CREATE: 自动创建Service，调用 onCreate，忽略 onStartCommamdunbindService(connection) // 解绑Service 任何 Service 可以和任意 Activity 绑定，且绑定后获得相同实例 4、前台服务前台服务是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，将其放在运行中的标题下方。这意味着除非将服务停止或从前台移除，否则不能清除该通知。 从 Android 9.0 开始需要申请权限 android.permission.FOREGROUND_SERVICE 在onCreate中： 1234567891011121314val pendingIntent: PendingIntent = Intent(this, ExampleActivity::class.java).let { notificationIntent -&gt; PendingIntent.getActivity(this, 0, notificationIntent, 0) }val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build()startForeground(ONGOING_NOTIFICATION_ID, notification) 5、IntentService用来执行耗时操作的 Service 的子类。 实现 onHandleIntent()，该方法会接收每个启动请求的 Intent，以便您执行后台工作。 1234567891011121314151617181920212223/** * A constructor is required, and must call the super [android.app.IntentService.IntentService] * constructor with a name for the worker thread. */class HelloIntentService : IntentService(&quot;HelloIntentService&quot;) { /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ override fun onHandleIntent(intent: Intent?) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } }} 重写其他回调方法，（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现 例如，onStartCommand() 必须返回默认实现，即如何将 Intent 传递给 onHandleIntent()： 1234override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() return super.onStartCommand(intent, flags, startId)} 启动 123Intent(this, HelloService::class.java).also { intent -&gt; startService(intent)} 扩展服务类借助 IntentService，您可以非常轻松地实现启动服务。但是，若要求服务执行多线程（而非通过工作队列处理启动请求），则可通过扩展 Service 类来处理每个 Intent。 为进行比较，以下示例代码展示了 Service 类的实现，该类执行的工作与上述使用 IntentService 的示例完全相同。换言之，对于每个启动请求，其均使用工作线程来执行作业，且每次仅处理一个请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class HelloService : Service() { private var serviceLooper: Looper? = null private var serviceHandler: ServiceHandler? = null // Handler that receives messages from the thread private inner class ServiceHandler(looper: Looper) : Handler(looper) { override fun handleMessage(msg: Message) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1) } } override fun onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND).apply { start() // Get the HandlerThread's Looper and use it for our Handler serviceLooper = looper serviceHandler = ServiceHandler(looper) } } override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job serviceHandler?.obtainMessage()?.also { msg -&gt; msg.arg1 = startId serviceHandler?.sendMessage(msg) } // If we get killed, after returning from here, restart return START_STICKY } override fun onBind(intent: Intent): IBinder? { // We don't provide binding, so return null return null } override fun onDestroy() { Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show() }}","link":"/Android/Android-Service/"},{"title":"Android四大组件——BroadcastReceiver","text":"Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似。这些广播会在所关注的事件发生时发送。 一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。 参考： 广播概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、广播类型 标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。 优点：效率高 缺点：无法被截断 系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。 优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播 缺点：效率没有标准广播高 2、系统广播Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。 可以在&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt中查看 1、动态注册程序启动之后才能接收广播 1234567891011121314151617181920212223242526lateinit var timeChangeReceiver: TimeChangeReceiveroverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) // 系统广播动作 timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) // 动态注册}override fun onDestroy() { super.onDestroy() unregisterReceiver(timeChangeReceiver) // 取消注册}// 内部类注册inner class TimeChangeReceiver : BroadcastReceiver() { // 继承 BroadcastReceiver override fun onReceive(p0: Context?, p1: Intent?) { // 不允许多线程，所以不能执行耗时操作 p0?.let { &quot;Time has changed&quot;.showToast(it) } }} 2、静态注册由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。 Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。 例外情况见 隐式广播例外情况 | Android 开发者 | Android Developers 注意：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器 1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3、自定义广播1、发送标准广播创建 BroadcastReceiver12345class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 }} 注册广播12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播123val intent = Intent(&quot;com.example.MY_BROADCAST&quot;)intent.setPackage(packageName) // 指定包名，使其成为显示广播sendBroadcast(intent) 2、发送有序广播前面与标准广播相同，发送广播时选择 sendOrderedBroadcast(intent,null) （参数2是与权限相关的字符串） 设置优先级因为有序广播可以被截断，在静态注册时指定优先级： &lt;intent-filter android:priority=&quot;100&quot;&gt; 截断使用 abortBroadcast() 123456class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 abortBroadcast() }}","link":"/Android/Android-BroadcastReceiver/"},{"title":"Android——ViewBinding","text":"通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。 在大多数情况下，视图绑定会替代 findViewById。 参考自： 视图绑定 | Android 开发者 | Android Developers Android | ViewBinding 与 Kotlin 委托双剑合璧 - 掘金 (juejin.cn) 1、实现原理在 Android 开发更新迭代中，Kotlin 逐渐取代 Java 成为主流开发语言，原来一些旧的使用方法也随之被取代。Android-Kotlin-Extensions 因为安全问题被官方废弃，随之就有了view binding（视图绑定）来继承对findViewById的替换。 用于更加轻量地实现视图绑定（视图与变量的绑定），可以理解为轻量版本的 DataBinding。 Android Gradle 插件会为每个 XML 布局文件创建一个绑定类，绑定类中包含布局文件中每个定义了android:id属性的 View 引用。假设布局文件为fragment_test.xml，则生成绑定类FragmentTestBinding.java； 2、使用方法1、开启视图绑定在模块的build.gradle/.kts中加入以下内容开启： 123456android { ... buildFeatures { viewBinding = true }} 如果希望生成绑定类时忽略某个布局文件，在相应的XML里加入： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 2、Activity中使用在 Activity 的 onCreate() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 将根视图传递到 setContentView()，使其成为屏幕上的活动视图。 123456789101112 private lateinit var binding: ResultProfileBinding override fun onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view) }// 后续通过以下方法引用viewbinding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 3、Fragment中使用在 Fragment 的 onCreateView() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。 注意：inflate() 方法会要求您传入布局膨胀器。如果布局已膨胀，可以调用绑定类的静态 bind() 方法。如需了解详情，请查看视图绑定 GitHub 示例中的例子。 1234567891011121314151617181920212223 private var _binding: ResultProfileBinding? = null // This property is only valid between onCreateView and // onDestroyView. private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view }// Fragment 的存在时间比其视图长。请务必在 Fragment 的 onDestroyView() 方法中清除对绑定类实例的所有引用。 override fun onDestroyView() { super.onDestroyView() _binding = null }// 后续使用binding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 为什么 Fragment#onDestroyView() 里需要置空绑定类对象，而 Activity 里不需要？ 答：Activity 实例和 Activity 视图的生命周期是同步的，而 Fragment 实例和 Fragment 视图的生命周期并不是完全同步的，因此需要在 Fragment 视图销毁时，手动回收绑定类对象，否则造成内存泄露。 例如：detach Fragment，或者 remove Fragment 并且事务进入返回栈，此时 Fragment 视图销毁但 Fragment 实例存在。 总之，在视图销毁但是控制类对象实例还存活的时机，你就需要手动回收绑定类对象，否则造成内存泄露。 3、与其他方案对比 角度 findViewById ButterKnife Kotlin Synthetics DataBinding ViewBinding 简洁性 ✖ ✖ ✔ ✔ ✔ 编译期检查 ✖ ✖ ✖ ✔ ✔ 编译速度 ✔ ✖ ✔ ✖ ✔ 支持 Kotlin &amp; Java ✔ ✔ ✖ ✔ ✔ 收敛模板代码 ✖ ✖ ✔ ✖ ✖ 简洁性： findViewById 和 ButterKnife 需要在代码中声明很多变量，其他几种方案代码简洁读较好； 编译检查： 编译期间主要有两个方面的检查：类型检查 + 只能访问当前布局中的 id。findViewById、ButterKnife 和 Kotlin Synthetics 在这方面表现较差； 编译速度： findViewById 的编译速度是最快的，而 ButterKnife 和 DataBinding 中存在注解处理，编译速度略逊色于 Kotlin Synthetics 和 ViewBinding； 支持 Kotlin &amp; Java： Kotlin Synthetics 只支持 Kotlin 语言； 收敛模板代码： 基本上每种方案都带有一定量的模板代码，只有 Kotlin Synthetics 的模板代码是较少的。","link":"/Android/Android-ViewBinding/"},{"title":"应用层","text":"应用层（Application layer）位于 OSI模型的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。 应用层的功能： 文件传输、访问和管理 电子邮件 虚拟终端 查询服务和远程作业登录 应用层的重要协议： HTTP（HyperText Transfer Protocol）超文本传输协议 FTP（File Transfer Protocol）文件传输协议 TFTP（Trivial File Transfer Protocol）简单文件传输协议 DNS（Domain Name System）域名系统 SMTP（Simple Mail Transfer Protocol）简单邮件传输协议 POP3（Post Office Protocol - Version 3）邮局协议 DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议 SNMP（Simple Network Management Protocol）简单网络管理协议 参考：力扣HTTP Headers - HTTP | MDN 1、HTTPHTTP 头部HTTP 头字段根据实际用途被分为以下 4 种类型： 通用头字段(General Header Fields) 请求头字段(Request Header Fields) 响应头字段(Response Header Fields) 实体头字段(Entity Header Fields) 通用头部同时适用于请求和响应消息（客户端和服务器都可以使用），但与最终消息主体中传输的数据无关的消息头。 可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。 协议头 说明 举例 Cache-Control 用来指定当前的请求/回复中是否使用缓存机制 Cache-Control: no-store Connection 客户端（浏览器）想要优先使用的连接类型 Connection: keep-alive (Upgrade) Date 报文创建时间 Date: Dec, 26 Dec 2015 17: 30: 00 GMT Trailer 会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时 Trailer: Expiress Transfer-Encoding 用来改变报文格式 Transfer-Encoding: chunked Upgrade 要求服务器升级到一个高版本协议 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 Via 告诉服务器，这个请求是由哪些代理发出的 Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1) Warning 一个一般性的警告，表示在实体内容中可能存在错误 Warning: 199 Miscellaneous warning 请求头部包含更多有关要获取的资源或客户端本身信息的消息头，如Accept头部。 协议头 说明 举例 Accept 告诉服务器自己允许哪些媒体类型 Accept: text/plain Accept-Charset 浏览器申明可接受的字符集 Accept-Charset: utf-8 Accept-Encoding 浏览器申明自己接收的编码方法 Accept-Encoding: gzip, deflate Accept-Language 浏览器可接受的响应内容语言列表 Accept-Language: en-US Authorization 用于表示 HTTP 协议中需要认证资源的认证信息 Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE== Expect 表示客户端要求服务器做出特定的行为 Expect: 100-continue From 发起此请求的用户的邮件地址 From: user@itbilu.com Host 表示服务器的域名以及服务器所监听的端口号 Host: www.itbilu.com:80 If-XXX 条件请求 If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT Max-Forwards 限制该消息可被代理及网关转发的次数 Max-Forwards: 10 Range 表示请求某个实体的一部分，字节偏移以 0 开始 Range: bytes=500-999 Referer 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面 Referer: http://itbilu.com/nodejs User-Agent 浏览器的身份标识字符串 User-Agent: Mozilla/…… 响应头部包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头，如Server头部。 协议头 说明 举例 Accept-Ranges 字段的值表示可用于定义范围的单位 Accept-Ranges: bytes Age 创建响应的时间 Age：5744337 ETag 唯一标识分配的资源 Etag：W/\"585cd998-7c0f\" Location 表示重定向后的 URL Location: http://www.zcmhi.com/archives/94.html Retry-After 告知客户端多久后再发送请求 Retry-After: 120 Server 告知客户端服务器信息 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Vary 缓存控制 Vary: Origin 实体头部请求/响应报文中实体部分的首部，包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型，如Content-Type头部。 协议头 说明 举例 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Content-encoding 返回内容的编码方式 Content-Encoding: gzip Content-Length 返回内容的字节长度 Content-Length: 348 Content-Language 响应体的语言 Content-Language: en,zh Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT HTTP 连接持久连接非Keep-alive：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。Keep-alive：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。 长连接 or 短链接http的长连接和短连接（史上最通俗！）以及应用场景_luzhensmart的专栏-CSDN博客_长连接和短连接的使用场景 长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。 短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。 报文长度长度在响应报文中有两种表现形式。 对于小点的文件，直接给出 content-length，也就是本次返回的数据长度 对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分块传输，这也是订好了协议，客户端收到了会进行组装，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。 曾经用 py 写过下载脚本，就利用了分块传输的方法： 1234567file_size = int(r.headers['content-length'])with tqdm(total=file_size, unit='B', unit_scale=True, unit_divisor=1024, ascii=True,desc=filename) as bar: with open(file_path, 'wb') as fp: for chunk in r.iter_content(chunk_size=512): if chunk: fp.write(chunk) bar.update(len(chunk)) HTTP 方法HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。 HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。 感觉实际生产中很少会用那6种方法，极大的复杂化了api 方法 描述 GET 请求指定的页面信息，并返回具体内容，通常只用于读取数据。 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。 PUT 替换指定的资源，没有的话就新增。 DELETE 请求服务器删除 URL 标识的资源数据。 CONNECT 将服务器作为代理，让服务器代替用户进行访问。 OPTIONS 向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。 TRACE 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新。 GET or POST get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。 get 请求只支持 URL 编码，post 请求支持多种编码格式。 get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。 get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制 get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。 get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个） 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。 操作方式 数据位置 明文密文 数据安全 长度限制 应用场景 GET HTTP包头如果数据是中文或其它字符，则进行BASE64编码。 明文 不安全 长度较小 查询数据 POST HTTP正文 可明可密 安全 支持较大数据传输 修改数据 长度限制： GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。 HTTP 状态HTTP 协议是无连接无状态的，并不保存关于客户端的任何信息。通常有两种方法保持会话： Session服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。 优点：安全性高，因为状态信息保存在服务器端。缺点：由于大型网站往往采用的是分布式服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。【解决方法】：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息 Cookie服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。 优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据；每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。 Cookie 被禁用若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。 HTTP 状态码HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。 HTTP 状态码共有 5 种类型： 分类 分类描述 1XX 指示信息--表示请求正在处理 2XX 成功--表示请求已被成功处理完毕 3XX 重定向--要完成的请求需要进行附加操作 4XX 客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求 5XX 服务器端错误--服务器处理请求出现错误 常见的状态码有如下几种： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 更多可见 HTTP 状态码_w3cschool 面试对状态码常见问法状态码 301 和 302 的区别 301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。 302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。 HTTP 异常状态码该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。 2、HTTPSHTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。 加密方式HTTPS 采用对称加密和非对称加密相结合的方式：首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性。通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。 工作方式 协议 特点 工作方式 HTTP 明文传输，数据未加密，安全性较差 默认 80 端口 3 次握手建立连接 客户端请求服务器 80 端口，建立 TCP 连接 客户端从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文 服务端从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文 通信结束，客户端与服务器关闭连接 HTTPS 加密，安全性较好 默认 443 端口 需数字认证机构（Certificate Authority, CA）的证书 除 TCP 的 3 次握手，还需要 SSL 协商 客户端请求服务器 443 端口，建立 TCP 连接（包括支持算法，密钥长度等） 服务端从双方共同支持的加密算法列表中选择一种返回给客户端（包括密钥组件） 服务器返回自身 CA 证书的报文（包含证书的颁发机构、过期时间、服务端的公钥等信息） 服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成 客户端用本地证书库的根证书校验CA证书，生成随机密码串，用公钥加密发送给服务器，即回应报文 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用密码串加密的 客户端发送一个 finish 报文（包含第一次握手至今所有报文的整体校验值） 服务端同样发送与第 6 步中相同作用的报文，最后发送 finish 报文告诉客户端自己能够正确解密报文 SSL 连接建立 CA 证书防止的方式：（为什么可以信任 CA 证书）篡改：加密签名与原文签名对比调包：请求域名与证书域名对比 另附 HTTP 版本演变： 直接造访 HTTP x.x 3、DNSDNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，提供了主机名和 IP 地址之间相互转换的服务。 查询方式 递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。帮你查 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。自己查 传输方式DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。 大多数情况下 DNS 使用 UDP 进行传输，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。 在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据 因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。 DNS 劫持DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。 域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。 预防手段 直接使用IP访问 直接指定DNS服务器（如谷歌的 8.8.8.8） 4、MoreSocket 套接字 Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。 套接字主要有以下三种类型： 流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。 数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。 原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。 URI 和 URL URL，即统一资源定位符 ( Uniform Resource Locator )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。 URI，即统一资源标识符（ Uniform Resource Identifier ），只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL 抓包工具 其实就是将抓包工具视为中间人，其对于本地而言相当于服务端；而对于真正的服务端而言则相当于客户端； 抓包工具分别和本地以及服务器都进行TLS握手协商； 这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书） 网页解析全过程 这部分可以看看： 当···时发生了什么？what-happens-when DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。 TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了 发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。 负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。 断开连接：客户端和服务器通过四次挥手终止 TCP 连接。","link":"/Computer-network/Application-Layer/"},{"title":"B Tree","text":"B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。 特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围； 把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。 转载： 平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 1、B 树(B-tree) 注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树; 1、概念B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构 规则： （1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则 （2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉） （3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2) （4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子 例子： 来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） 2、B 树的查询如上图我要从上图中找到 E 字母，查找流程如下 （1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）； （2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点； （3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）； 3、B 树的插入定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来; （1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）； （2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则; 先插入 3、8、31、11 再插入 23、29 再插入 50、28 3、B 树的删除 （1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）； （2）满足节点本身比左边节点大，比右边节点小的排序规则; （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 2、B+树1、概念B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别 （1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加； （2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样； （3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。 （4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）; 2、特点1、B+树的层级更少：相较于 B 树 B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快； 2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定; 3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。 4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B 树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B 树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。 3、总结1、相同思想和策略从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度； 2、不同的方式的磁盘空间利用不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；","link":"/Data-structure/B-Tree/"},{"title":"Binary Search Tree 二叉搜索树","text":"简称 BST，也称二叉排序树或二叉查找树。 特点： 任一结点 &gt; 其左子树的所有结点， 并且&lt; 其右子树的所有结点； 结点的左、右子树，也是二叉排序树； 每个结点键值唯一（不能重复） 重要性质： 中序遍历二叉排序树得到递增序列 所以判断 1 棵二叉树是否是二叉排序树？只要中序遍历，得到递增序列才是。 插入 若当前树为空，则新结点为根 若当前树不空， 将待插入 x 与根比较； 若 x 等于根，不用插入 若 x 大于根，则去右子树(找位置)； 若 x 小于根，则去左子树(找位置)； 可以总结为： 插入之前，先查找： 若找到，不用插入 若找不到，则在到达的空位置处，放入 x； 所以最新插入的结点，一定是叶子； 1234567891011121314func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return &amp;TreeNode{ Val: val, } } if root.Val &gt; val { root.Left = insertIntoBST(root.Left, val) } if root.Val &lt; val { root.Right = insertIntoBST(root.Right, val) } return root} 查找 从根结点开始，如果树为空，则返回 NULL 如果非空，从根结点开始，比较待检索的键值 若相等，则成功； 若小于根， 则去根的左子树； 若大于根， 则去根的右子树， 迭代123456789101112func searchBST(root *TreeNode, val int) *TreeNode { for root != nil { if root.Val &gt; val { root = root.Left } else if root.Val &lt; val { root = root.Right } else { return root } } return nil} 删除考虑三种情况： ① 要删除叶子结点 直接删除，并将父结点指针置为 NULL ② 删除只有 1 个孩子的结点 将父结点指针指向要删除结点的孩子结点 ③ 删除有左右子树的结点 用另一个结点替代删除的结点： 右子树的最小元素 或者 左子树的最大元素 12345678910111213141516171819202122232425262728func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return root } if root.Val &gt; key { root.Left = deleteNode(root.Left, key) return root } if root.Val &lt; key { root.Right = deleteNode(root.Right, key) return root } // 情况 1 : 以下两个 if 已经处理 if root.Left == nil { // 情况 2 左 return root.Right } if root.Right == nil { // 情况 2 右 return root.Left } // 情况 3 ： 使用右子树最小元素 minNode := root.Right for minNode.Left != nil { minNode = minNode.Left } root.Val = minNode.Val root.Right = deleteNode(root.Right, minNode.Val) return root} 平均检索长度 ASL比较次数：不大于树的深度 最坏平均查找长度 ASL：(n+1)/2 最好 ASL：$log2(n)$ (参考二分查找) 所有操作的复杂度都是 $O(logn)$","link":"/Data-structure/Binary-Search-Tree/"},{"title":"回溯算法","text":"回溯的本质是穷举，穷举所有可能，然后选出想要的答案，如果想让回溯法高效一些，需要进行剪枝操作。 回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 组合不强调元素顺序，排列强调元素顺序： 即 不同顺序的同样元素集合 算作排列，但不算组合 参考：代码随想录 1、前言看到回溯，感觉和 DFS（深度优先搜索）区别不太大，两者其实是包含关系。 回溯搜索是 DFS 的一种，对于某一个搜索树来说（搜索树记录路径和状态判断），其主要的区别是： 回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种方法使得深度优先搜索法与回溯法没什么区别 2、组合问题 N个数里面按一定规则找出k个数的集合。 直接 DFS 暴搜，如果满足条件返回，再加上适当剪枝即可。 如果是一个集合来求组合的话，就需要startIndex，例如：回溯算法：求组合问题！ (opens new window)，回溯算法：求组合总和！ (opens new window)。如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：回溯算法：电话号码的字母组合 例题：77. 组合 - 力扣（LeetCode） 12345678910111213141516171819202122class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; void dfs(int n, int k, int idx) { if (tmp.size() == k) { ans.push_back(tmp); return; } for (int i = idx; i &lt;= n - (k - tmp.size()) + 1; i++) { tmp.push_back(i); dfs(n, k, i + 1); tmp.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { dfs(n, k, 1); return ans; }}; 3、切割问题 一个字符串按一定规则有几种切割方式 具体算法类似组合问题，判断函数比较复杂。 例题：131. 分割回文串 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930class Solution { public: vector&lt;vector&lt;string&gt;&gt; ans; vector&lt;string&gt; tmp; bool check(string s, int start, int end) { for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) return false; } return true; } void dfs(string s, int idx) { if (idx &gt;= s.size()) { ans.push_back(tmp); return; } for (int i = idx; i &lt; s.size(); i++) { if (!check(s, idx, i)) continue; tmp.push_back(s.substr(idx, i - idx + 1)); dfs(s, i + 1); tmp.pop_back(); } } vector&lt;vector&lt;string&gt;&gt; partition(string s) { dfs(s, 0); return ans; }}; 4、子集问题 一个N个数的集合里有多少符合条件的子集 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。 例题：78. 子集 - 力扣（LeetCode） 1234567891011121314151617181920class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; void dfs(vector&lt;int&gt;&amp; nums, int idx) { ans.push_back(tmp); if (idx &gt;= nums.size()) return; for (int i = idx; i &lt; nums.size(); i++) { tmp.push_back(nums[i]); dfs(nums, i + 1); tmp.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { dfs(nums, 0); return ans; }}; 5、排列问题 N个数按一定规则全排列，有几种排列方式 排列是区分顺序的，不同顺序的集合算不同排列 和组合问题区别在每次循环的起始位置都是 0，同时用 vis 数组来记录状态。 1234567891011121314151617181920212223242526class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; vis) { if (tmp.size() == nums.size()) { ans.push_back(tmp); return; } for (int i = 0; i &lt; nums.size(); i++) { if (vis[i]) continue; tmp.push_back(nums[i]); vis[i] = true; dfs(nums, vis); vis[i] = false; tmp.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; vis(nums.size(), false); dfs(nums, vis); return ans; }}; 6、棋盘问题 N皇后，解数独等等 给回溯函数加上 bool 返回值，找到一组成功解则返回。 例题：51. N 皇后 - 力扣（LeetCode） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public: vector&lt;vector&lt;string&gt;&gt; ans; /* * 递归遍历行 * 循环遍历列 */ void dfs(int row, int n, vector&lt;string&gt;&amp; chess) { if (row == n) { ans.push_back(chess); return; } for (int col = 0; col &lt; n; col++) { if (check(row, col, n, chess)) { chess[row][col] = 'Q'; dfs(row + 1, n, chess); chess[row][col] = '.'; } } } /* *不能同行（递归过程中进行了同行检查） *不能同列 *不能同斜线 （45度和135度角） */ bool check(int row, int col, int n, vector&lt;string&gt;&amp; chess) { // 检查列，剪枝 for (int i = 0; i &lt; row; i++) { if (chess[i][col] == 'Q') return false; } // ∠45° for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if (chess[i][j] == 'Q') return false; } // ∠135° for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) { if (chess[i][j] == 'Q') return false; } return true; } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; chess(n, string(n, '.')); dfs(0, n, chess); return ans; }}; 例题：37. 解数独 - 力扣（LeetCode） 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public: bool check(int row, int col, int val, vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int j = 0; j &lt; 9; j++) { // 检查列 if (board[row][j] == val) return false; } for (int i = 0; i &lt; 9; i++) { // 检查行 if (board[i][col] == val) return false; } // 检查 3x3 int nRow = (row / 3) * 3; int nCol = (col / 3) * 3; for (int i = nRow; i &lt; nRow + 3; i++) { for (int j = nCol; j &lt; nCol + 3; j++) if (board[i][j] == val) return false; } return true; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; board.size(); i++) { for (int j = 0; j &lt; board[0].size(); j++) { if (board[i][j] != '.') continue; for (char k = '1'; k &lt;= '9'; k++) { if (check(i, j, k, board)) { board[i][j] = k; if (dfs(board)) return true; board[i][j] = '.'; } } return false; // 9 个数都不行 } } return true; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { dfs(board); }};","link":"/Algorithm/Backtracking/"},{"title":"二叉树遍历","text":"二叉树遍历主要包括： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 参考： 代码随想录 (programmercarl.com) 1、递归遍历递归三要素： 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历即 根-左-右 1234567891011121314func preorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var preOrder func(root *TreeNode) preOrder = func(root *TreeNode) { if root == nil { return } ans = append(ans, root.Val) preOrder(root.Left) preOrder(root.Right) } preOrder(root) return ans} 中序遍历即 左-根-右 1234567891011121314func inorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var inOrder func(root *TreeNode) inOrder = func(root *TreeNode) { if root == nil { return } inOrder(root.Left) ans = append(ans, root.Val) inOrder(root.Right) } inOrder(root) return ans} 后序遍历即 左-右-根 1234567891011121314func postorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var postorder func(root *TreeNode) postorder = func(root *TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) ans = append(ans, root.Val) } postorder(root) return ans} 2、迭代遍历要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 通过这种标记法实现二叉树的统一迭代遍历。 前序遍历12345678910111213141516171819202122232425262728func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } stack.PushBack(node) // 根 stack.PushBack(nil) } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 中序遍历12345678910111213141516171819202122232425262728func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } stack.PushBack(node) // 根 stack.PushBack(nil) if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 后序遍历12345678910111213141516171819202122232425262728func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 stack.PushBack(node) // 根 stack.PushBack(nil) if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 3、层序遍历12345678910111213141516171819202122232425func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := list.New() queue.PushBack(root) t := make([]int, 0) for queue.Len() &gt; 0 { l := queue.Len() for i := 0; i &lt; l; i++ { node := queue.Remove(queue.Front()).(*TreeNode) t = append(t, node.Val) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } } ans = append(ans, t) t = []int{} } return ans}","link":"/Algorithm/Binary-Tree-Traversal/"},{"title":"Binary Search 二分查找","text":"二分查找也称折半查找，它是一种效率较高的查找方法。 前提数组为有序数组，数组中无重复元素。 因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。 二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。 到底是 while(left &lt; right) 还是 while(left &lt;= right)？ 到底是right = middle呢，还是要right = middle - 1呢？ 区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 写法1、左闭右闭定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码： 12345678910111213int search(vector&lt;int&gt;&amp; nums, int target) { // 左闭右闭 int left = 0, right = nums.size() - 1; while (left &lt;= right) { int middle = left + ((right - left) &gt;&gt; 1); // 防止溢出 if (nums[middle] &gt; target) right = middle - 1; else if (nums[middle] &lt; target) left = middle + 1; else return middle; } return -1;} Go 1234567891011121314func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left &lt;= right { middle := left + (right-left)&gt;&gt;1 if nums[middle] &gt; target { right = middle - 1 } else if nums[middle] &lt; target { left = middle + 1 } else { return middle } } return -1} 2、左闭右开定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 代码： 12345678910111213141516int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size(); // 左闭右开 while (left &lt; right) { // left == right在[left, right)是无效的空间 int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) { right = middle; // target 在左区间，在[left, middle)中 } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，在[middle + 1, right)中 } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1;}","link":"/Algorithm/Binary-Search/"},{"title":"常见容器底层","text":"各种语言下，常见容器底层整理。 参考： C++ STL容器底层数据结构总结 - 简书 (jianshu.com) C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com) 1、C++vector其底层数据结构是数组，由于能动态扩容，所以也称动态数组 特点： 随机访问：$O(1)$ 随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删 扩容规则： 新建时初始化一片空间 插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据 释放原来空间 在进行迭代器相关的修改操作时（包括扩容），所有迭代器和指针引用都会失效 map &amp; multimap &amp; set &amp; multisetmap提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。 与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。 底层数据结构均为红黑树，可以参考[教你透彻了解红黑树](The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com))。 特点： 访问、查找、删除：$O(logn)$ unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset顾名思义，以上容器是无序的，所以底层实现为哈希表，因此其查找时间复杂度理论上达到了O(n) 特点： 访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题 2、GoGo 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现 map底层数据结构是哈希表 特点： 访问、查找、删除：$O(1)$","link":"/Data-structure/Common-Container/"},{"title":"位运算","text":"计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。 位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。 上述位运算中，只有取反是一元运算，其余的都是二元运算。 参考：位运算符的概念和性质 1、与、或、异或和取反 与运算的符号是 $\\And$ ，运算规则是：全 1 为 1，有 0 为 0 或运算的符号是 $∣$ ，运算规则是：有 1 为 1，全 0 为 0 异或运算的符号是 $\\oplus$（在代码中用 $\\wedge$ 表示异或），运算规则是：相同为 0 ，不同为 1 取反运算的符号是 $\\sim$，运算规则是：0 变 1， 1 变 0 2、移位运算移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。 左移运算的符号是 $&lt;&lt;$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。 右移运算的符号是 $&gt;&gt;$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定： 算术右移时，高位补最高位； 逻辑右移时，高位补 0。 C++ 中：对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。Java 中：不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。算术右移的符号是 $&gt;&gt;$，逻辑右移的符号是 $&gt;&gt;&gt;$Go 中：只有算数移位 3、位运算与乘除法使用移位运算实现乘除法的效率显著高于直接乘除法的效率。 左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$ 例如，$29 &lt;&lt; 2 = 116$，等价于 $ 29 \\times 4 $ 当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和： 例如，$a \\times 6$ 等价于 $(a&lt;&lt;2)+(a&lt;&lt;1)$ 对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。 算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$ 例如，$50 &gt;&gt; 2 = 12$ ，等价于 $50 / 4$，结果向下取整 一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是不等价的（只对0和正数成立） 同时，位运算也能用来替代取模运算判断奇偶： 奇数：$整数&amp;1==1$（二进制最低位是1，就是奇数 偶数：$整数&amp;1==0$（二进制最低位是0，就是偶数 4、位运算性质此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。 幂等律：$a \\And a = a$ ，$a ∣ a=a$ （注意异或不满足幂等律） 交换律：$a \\And b = b \\And a$，$a ∣ b = b ∣ a$，$a \\oplus b = b \\oplus a$ 结合律：$(a \\And b) \\And c = a \\And (b \\And c)$，$(a ∣ b) ∣ c = a ∣ (b ∣ c)$，$(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$ 分配律：$(a \\And b) ∣ c = (a ∣ c) \\And (b ∣ c)$，$(a ∣ b) \\And c = (a \\And c) ∣ (b \\And c)$，$(a ⊕ b) \\And c = (a \\And c) ⊕ (b \\And c)$ 德·摩根律：$\\sim (a \\And b) = ( \\sim a) ∣ (\\sim b)$ ，$\\sim(a ∣ b) = (\\sim a) \\And (\\sim b)$ 取反运算性质：$-1 = \\sim 0，-a = \\sim (a-1)$ 与运算性质：$a \\And 0 = 0$，$a \\And (-1) = a$，$a \\And (\\sim a) = 0$ 或运算性质：$a ∣ 0 = a$，$a ∣ (\\sim a) = -1$ 异或运算性质：$a \\oplus 0 = a$，$a \\oplus a = 0$ 其他性质： $a \\And (a-1)$ 的结果：将 a 的二进制表示的最后一个 1 变成 0 $a \\And (-a)$（与 $a \\And (\\sim (a-1))$ 等价）的结果：只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0","link":"/Knowledge/Bit-Operation/"},{"title":"数据库","text":"数据库（Database） 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 数据库管理系统（DataBase- Management System，DBMS） 创建和操纵的容器。 DBMS 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。 参考： 数据库知识手册 1、概念数据库有两种类型，分别是 关系型数据库 和 非关系型数据库。 数据库类型 定义 优点 缺点 常见 关系型数据库 建立在关系模型基础上，由多张能互相连接的 表 组成的数据库 使用表结构，格式一致，易于维护； 使用 SQL 语句，可用于复杂查询； 数据存储在磁盘中，安全性高 读写性能比较差； 建立在关系模型上，不可避免空间浪费； 固定的表结构，灵活度较低 MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等 非关系型数据库 非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 对象 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛； 可轻松进行海量数据的维护和处理； 具有可扩展、高并发、高稳定性、成本低的优势； 可以实现数据的分布式处理 不提供 SQL 支持； 无事务处理，无法保证数据的完整性和安全性； 功能没有关系型数据库完善 Neo4j，Redis，MongoDB 等 SQL 是 结构化查询语言（Structured Query Language） 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。 MySQL 是一个 关系数据库管理系统（RDBMS），使用 SQL 执行所有数据库操作。 函数依赖 部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB 完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB 传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A 范式数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。 常用的数据库三大范式为： 第一范式（1NF）：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。关系模式的基本要求 第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。消除部分依赖 第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。消除传递依赖 2、索引索引是一种 数据结构。数据库索引是 DBMS 中一个 排序的数据结构，以 协助快速查询、更新 数据库表中数据。 索引的实现通常使用 B 树以及变种 B+ 树。 以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。 优点 缺点 通过创建 唯一性索引 ，可以保证数据库表中每一行数据的唯一性； 可以加快数据的 检索速度 ，这也是创建索引的主要原因； 可以加速表和表之间的连接，特别是在实现 数据的参考完整性 方面特别有意义； 通过使用索引，可以在查询的过程中，使用 优化隐藏器 ，提高系统性能。 时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度； 空间上，索引需要占 物理空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 索引分类数据库索引根据结构分类，主要有 B 树索引（使用最频繁）、Hash 索引 和 位图索引 三种。 关于 B 树可以参考：B Tree 使用 B+ 树的优点： 由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。 B+ 树的叶结点由一条链相连，因此当需要进行一次 全数据遍历 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 大于某个关键字或者小于某个关键字的数据 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。 Hash 索引和 B+ 树索引的区别： Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询； Hash 索引不支持使用索引进行排序； Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测； Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询； Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。 聚簇索引聚簇索引指将 数据存储 和 索引 放到一起，找到索引也就找到了数据。 3、事务数据库的 事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。 如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。 因此，事务是保持 逻辑数据一致性 和 可恢复性 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性 特性事务具有 4 个特性，通常简称为 ACID，关系型数据库 需要遵循 ACID 规则。 原子性（Atomicity） 事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。 以银行转账事务为例： 如果该事务提交了，则这两个账户的数据将会更新； 如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 撤销 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。 一致性（Consistency） 当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。 以银行转账事务事务为例： 在事务开始之前，所有 账户余额的总额处于一致状态。 在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。 因此，所有账户余额的总额处于不一致状态。 但是当事务完成以后，账户余额的总额再次恢复到一致状态。 隔离性（Isolation） 并发访问数据库 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。 修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。 持久性（Durability） 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现DBMS 采用 日志 来保证事务的 原子性、一致性 和 持久性。 日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。 DBMS 采用 锁机制 来实现事务的隔离性。 当多个事务同时更新数据库中相同的数据时，只允许 持有锁的事务 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。 相应的原理 原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql 一致性：一般由代码层面来保证 隔离性：由MVCC来保证 持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复 冲突 脏读（Dirty Read） 一个事务读取了另一个事务未提交的数据。 不可重复读（Non-repeatable Read） 就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。 幻读（Phantom Read） 幻读是指当事务 不是独立执行时 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 插入一行新数据。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。 丢失更新（Lost Update） 两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。 隔离级别SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 并发事务对同一资源的读取深度层次。 由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE） 隔离级别 读数据一致性 脏读 不可重复读 幻读 未提交(RU) 只能保证不读取物理上的损坏 √ √ √ 已提交(RC) 语句级 × √ √ 可重复读(RR) 事务级 × × √ 串行化(SR) 最高级别，事务级 × × × 4、锁从数据库系统的角度，锁模式可分为以下6 种类型： 共享锁（S）：又叫 他读锁。 可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。 排它锁（X）：又叫 独占锁、写锁。 对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。 更新锁（U）： 防止出现 死锁 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。 资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。 意向锁： 表示 SQL Server 需要在 层次结构中的某些底层资源上 获取共享锁或排它锁。 例如，放置在 表级 的 共享意向锁 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。 意向锁可以提高性能，因为 SQL Server 仅在 表级 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 架构锁： 在执行 依赖于表架构的操作 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。 大容量更新锁（BU）： 向表中大容量复制数据并指定了 TABLOCK 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。 关系 在 读取未提交 隔离级别下，读取数据不需要加 共享锁，这样就不会跟被修改的数据上的 排他锁 冲突； 在 读取已提交 隔离级别下，读操作需要加 共享锁，但是在语句执行完以后释放共享锁； 在 可重复读 隔离级别下，读操作需要加 共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁； 可串行化 是限制性最强的隔离级别，因为该级别 锁定整个范围的键，并一直持有锁，直到事务完成。 死锁死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 常见的解决死锁的方法 如果不同程序并发存取多个表，尽量约定 以相同的顺序访问表，可以大大降低死锁机会； 在同一个事务中，尽可能做到 一次锁定所需要的所有资源，减少死锁产生概率； 对于非常容易产生死锁的业务部分，可以尝试使用 升级锁定颗粒度，通过 表级锁 定来减少死锁产生的概率。 乐/悲观锁DBMS 中的 并发控制 的任务是确保在 多个事务同时存取数据库中同一数据 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 读多写少 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。","link":"/Database/Database-Introduction/"},{"title":"数据链路层","text":"数据链路层 是OSI参考模型中的第二层，介乎于物理层和网络层之间。 功能：在物理层提供服务的基础上向网络层提供服务 最基本的服务：将源自于物理层的数据可靠地传输到相邻结点到目标机网络层 主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 为网络层提供服务： 无确认的无连接服务 有确认的无连接服务 有确认的面向连接服务 重要协议： PPP（Point to Point Protocol）点-点协议 链路层设备： 交换机 网桥 参考：王道考研 1、基本问题封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 透明传输透明表示一个实际存在的事物看起来好像不存在一样。针对用户是透明的；首尾是界定帧，转义字符去除数据部分和首尾相同引起歧义。 差错控制链路层编码针对一组比特，通过冗余码的技术实现一组二进制比特串在传输过程中是否出现差错。 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 主要包括： 检错编码 奇偶校验码 循环冗余码 纠错编码 海明码 2、流量控制主要通过滑动窗口协议，根据窗口大小分为： 停止-等待协议：发送窗口 = 1，接收窗口 = 1 后退N帧协议（GBN）：发送窗口 &gt; 1，接收窗口 = 1 选择重传协议（SR）：发送窗口 &gt; 1，接收窗口 &gt; 1 3、介质访问控制 CSMA/CD CSMA/CD 为载波侦听多路访问/冲突检测，是像以太网这种广播网络采用的一种机制，我们知道在以太网中多台主机在同一个信道中进行数据传输，CSMA/CD 很好的解决了共享信道通信中出现的问题，它的工作原理主要包括两个部分： 载波监听：当使用 CSMA/CD 协议时，总线上的各个节点都在监听信道上是否有信号在传输，如果有的话，表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据。 冲突检测：当两个或两个以上节点同时监听到信道空闲，便开始发送数据，此时就会发生碰撞（数据的传输延迟也可能引发碰撞）。当两个帧发生冲突时，数据帧就会破坏而失去了继续传输的意义。在数据的发送过程中，以太网是一直在监听信道的，当检测到当前信道冲突，就立即停止这次传输，避免造成网络资源浪费，同时向信道发送一个「冲突」信号，确保其它节点也发现该冲突。之后采用一种二进制退避策略让待发送数据的节点随机退避一段时间之后重新。 CSMA/CD的工作流程可以概括为： 先听后发 边发边听 冲突停发 随机重发 CSMA/CD: 载波监听多路访问 / 碰撞检测（Detect），用于有线局域网（LAN）CSMA/CA: 载波监听多路访问 / 碰撞避免（Avoid），用于无线局域网（WIFI） 4、PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP（点对点） 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 5、MAC 地址MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。 MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。 为什么需要 MAC 地址只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。 为什么需要 IP 地址光有MAC地址的话，寻址困难。IP地址和地域有关，可以分区域寻址，效率更高。","link":"/Computer-network/Data-Link-Layer/"},{"title":"设备管理","text":"磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。 早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。 电脑外设就是除主机外的大部分硬件设备都可称作外部设备，或叫外围设备，简称外设。计算机系统没有输入输出设备，就如计算机系统没有软件一样，是毫无意义的。 参考：八股文（星球精华汇总）设备管理 - 力扣 1、磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 先来先服务 FCFS, First Come First Served 按照磁盘请求的顺序进行调度。 优点是公平和简单。 缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道时间优先 SSTF, Shortest Seek Time First 优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。 如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。 具体来说，两端的磁道请求更容易出现饥饿现象。 电梯算法 SCAN 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。 2、外设如何让外设动起来 CPU 向外设的控制器发送指令，即 out 指令 形成 ⽂件视图（为了统⼀ out 指令的形式） 中断（外设处理完事后，需要通知 cpu 继续接手下⼀步处理） 显示器如何工作 Printf 函数的工作流程 键盘如何工作 中断处理（根据扫描码获取 对应的 ascii 码） 将对应的 ascii 码加入缓冲队列 read_que 中，等待上层程序调用","link":"/Operating-System/Device-Management/"},{"title":"文件管理","text":"文件系统是操作系统中负责管理持久数据的子系统，即负责把用户的文件存到磁盘硬件中。 因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。 文件是对长期存储介质的抽象。 参考：八股文（星球精华汇总）理解文件系统 - 掘金 1、文件文件是⼀种抽象机制，它提供了⼀种在磁上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘⼯作方式等有关细节。 win95、win98用的都是MS-DOS的文件系统，即FAT-16， win98扩展了FAT-16成为FAT-32。较新版的操作系统NTFS，win8配备ReFS。微软优化FAT,叫作exFAT。prog.c，圆点后面的部分称为文件扩展名。 文件结构 字节结构：把文件看成字节序列为操作系统提供了最大的灵活度 记录序列：文件结构上的第⼀步改进，这种模型中，文件是具有固定长度记录的序列 树：文件在这种结构中由⼀棵记录树构成，每个记录不必具有相同的长度，记录的固定位置上有⼀个键字段。这棵树按“键”字段进行排序，从而可以对特定“键”进行快速查找。 文件类型 普通文件 目录 字符特殊文件（UNIX） 块特殊文件（UNIX） 文件属性除了文件名和数据外，文件还具有属性来对文件本身做更具体的描述，这类信息也称为元数据。这些属性会存于文件结构中的某些区域中，具体要视该文件的类型而定。 举例： 创建时间、修改时间、存取时间、文件大小、当前大小、所有者等 保护：对文件的访问限制，谁可以访问文件 口令：访问文件需要的密码 只读标志、隐藏标志、系统标志（普通文件或系统文件）、加锁标志、存档标志 最大长度：文件可能增长到的字节数 文件操作使用文件的目的是存储信息并方便以后检索。对于存储和检索，不同系统提供了不同的操作。 文件系统大多都会提供如下的文件操作： create()：创建不包含任何数据的文件。 delte()：删除该文件以释放磁盘空间。 open()：在使用文件之前，先打开文件，目的是把文件属性和磁盘地址表装入内存，以便后续调用的快速访问。 close()：文件访问结束之后，关闭文件并释放内部空间表空间。 write()：向文件写数据，如果当前位置是文件尾，那么数据长度会增加；如果当前位置是其中某个位置，那么写入位置的数据将会被覆盖。 append()：相当于write()在尾部添加数据。 seek()：随机访问文件，需要指定相对于文件数据开始的位置。 getAttribute()：读取文件的属性。 setAttribute()：设置文件的属性。 rename()：重命名文件。 一般来说，打开文件将会获得一个文件描述符(一个小整数)，通过文件描述符，就可以操作文件。 2、目录文件系统通常提供目录或文件夹用于记录文件的位置，在很多操作系统中目录本身也是文件 现在的文件目录结构，大多采用文件树结构。这里的路径，用路径名表示，分为绝对路径名和相对路径名，路径每往下一层，使用分隔符进行分隔。 分隔符视系统而定，如下： 123&gt; Windows：\\usr\\ast\\maibox&gt; Linux: /usr/ast/mailbox&gt; MULTICS: &gt;usr&gt;ast&gt;mailbox 目录操作对于目录，也提供了相应的操作： create(): 创建目录 delete(): 删除目录 opendir(): 打开目录 closedir(): 关闭目录，释放内部表空间 readdir(): 返回一个目录项，在内存中，以目录项来表达一个目录 rename(): 重命名 link(): 链接一个文件，之后能使同一个文件，能通过多个文件路径访问到(后续会提到) unlink(): 解除文件的链接 3、文件系统以上内容是以用户（即使用者）的角度看待文件。那么，从文件系统实现者的角度来看，文件系统应该如何实现？ 文件系统存放在磁盘上，磁盘被划分为一个或者多个分区，每个分区中有一个独立的文件系统。磁盘的0号扇区称为主引导记录（Master Boot Record, MBR），用来引导计算机。紧接着，是分区表，用来标记每个分区的起始和结束位置，表中的一个分区被标记为活动分区。 当计算机被引导时，BIOS读入并执行MBR。MBR会确定活动分区，读入并执行它的引导块（boot block）。引导块中的程序将装载该分区中的系统。超级块（superblock）包含文件系统的所有关键参数，会被读入内存，其中的信用可用来确定文件系统的魔数、文件系统中的块的数量和其他重要的管理信息。 空闲块的信息可以用位图或者指针的形式指出，随后跟随的是一组i节点（一种数据结构，用来说明文件的方方面面）。最后，存放了所有其他的文件和目录。 文件的实现连续分配最简单的分配是把每个文件作为⼀连串连续数据块存储在磁盘 优点： 实现简单，只需记住开始位置，文件的块数。 读操作性能好，单个操作就能从磁盘中读出整个文件。只需要一次寻找，之后不再有寻道和旋转延迟。 缺点： 尾部会浪费一些空间，以块为存储单位时，无论是否完全使用完块大小，都会占用整个块 需要知道文件的最终大小，然后，在维护的连续空闲表找到合适的位置存入文件，并且知道文件的最终大小这一问题不可回避。 随时间迁移，将会产生大量碎片块，使磁盘变得零碎，当一个较大的新文件要加入时，将找不到合适的连续位置，此时要压缩磁盘空间（把文件复制到新位置，以得到更多的连续空间），代价极高。 新建文件时要知道文件的最终大小，使得这一存储方式难以应用于实际场景，但是在一些情形下是可行的。 如在CD-ROM、DVD、BD（蓝光光盘）上，在它们的场景里，所有的文件的大小是事先知道的，并且在后续的使用中，这些文件的大小也不会改变。 链表分配可以为每个文件构造磁盘块链表，每一块的第一个字指向下块，块的其他部分存放数据。 优点： 不会因为磁盘碎片浪费存储空间，充分利用磁盘块。 只需要第一块的磁盘地址，就能找到其他的块。 缺点： 随机方法访问很慢，访问块n总是要先访问其面的n-1块。 指向下一块的指针占据了一些字节，每个磁盘块存储的字节数不再是2的整次幂，因大多数程序以长度为2的整次幂来读写磁盘块，降低了实际系统的运行效率。 要读出一个完成的文件块时，要从两个磁盘块中获得和拼接信息，带来额外的开销 内存中的表进行链表分配弥补链表分配的不足，可以在内存中建立磁盘块的指针表。 表项中，使用一个特殊的标记（如-1）表示结束。这样，沿着表就可以文件的所有块。 这样的表也称为 FAT（File Allocation Table） 。 优点： 整个块都可以存放数据。 随机访问也简单得多，虽然仍要顺着链表寻找偏移量（但减少了可能的寻到和旋转延迟） 不需要磁盘引用 缺点： 必须把整个表都放在内存中。假设1TB的磁盘和1KB的块大小，则表需要10亿项，每一项至少要3个字节，则表大小要占用2.4GB内存。因此FAT的应用场景有限，不太实用。 i 节点最普遍的方式，是为每个文件创建一个中数据结构以表示此文件的关键描述，这种数据结构也称为i节点（index-node）。 一个可能的inode结构，记录了文件属性，以及每个文件块对应的磁盘块地址，并能指向其他的inode来记录更多的存储数据。 这样的机制有很大的优势： 给定inode，就能找到所有的文件块。 只有在文件打开时，inode才会存在于内存中，如果每个i节点有n字节，那么k个文件同时打开，inode总共占据kn字节，只需提前保留这么多的空间即可。也就是说，内存中inode占据的大小和文件大小无关，只和同时使用的文件数有关。 如果一个inode不够存储一个文件占用的所有磁盘块，可以通过最后一个地址之前其他inode得以解决。甚至可以指向其他存放地址的磁盘的磁盘块。 目录的实现在读文件之前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应的目录项。 简单目录：包含固定大⼩的目录，在目录项中有磁盘地址和属性 采用i节点的系统：把文件属性存放在i节点中而不是目录项中。这种情形下，目录项会更短。 共享文件共享文件与目录的联系称为⼀个链接（link）。这样文件系统本身就是⼀个有向⽆环图（DAG），而不是⼀棵树。 硬链接：指向目标数据对象的链接，可以看作是一个既有文件的别名 当目标被删除时，硬链接继续存在，且可以正常打开、编辑。因为他具备一个完整的文件结构。 当硬链接被删除时，目标文件继续存在，不受影响。 只有当一个文件 ID 对应的所有硬链接被删除时，数据才真正被标记为删除。 符号链接：指向目标路径的链接，会跳转到符号链接所指向的目标中去，而不改变此时的文件路径 当目标被删除时，符号链接继续存在，但会成为死链，无法打开。 当符号链接被删除时，它指向的目标不受影响。 虚拟文件系统将多个文件系统整合到⼀个统⼀的结构中。 ⼀个Linux系统可以用ext2作为根文件系统，ext3分区装载在/usr下，另⼀块采用ReiserFS文件系统的硬盘装载在/home下，以及⼀个ISO 9660的CD-ROM临时装载在/mnt下。 从用户的观点来看，只有⼀个文件系统层级。但它们事实上是多种文件系统，对于用户和进程是不可见的。 绝大多数Unix操作系统都在使用虚拟文件系统（VirtualFile System, VFS） 文件系统面对的问题磁盘空间管理几乎所有的文件系统将文件分割成固定大小的块来存储，各块之间不一定相邻。 块大小块大小将直接影响此消彼长的两个指标空间利用率和磁盘数据率。 从历史的观点上来说，文件系统将大⼩设在1~4KB之间。 但现在随着磁盘超过了1TB，还是将块的大⼩提升到64KB 并且接受浪费的磁盘孔空间，这样也许更好。磁盘空间⼏乎不再会短缺。 空闲块记录确定了块大小，需要考虑空闲块如何记录。 链表记录：链表的每个块中包含尽可能多的空闲磁盘块号。（通常情况下，采用空闲块存放空闲表，这样不会影响存储器） 位图记录：在位图中，空闲块用1表示，已分配块用0表示。 文件备份做磁盘备份主要是处理好两个潜在问题中的⼀个： 从意外的灾难中恢复 从错误的操作中恢复 将文件从磁盘转储到磁带，有两种方法，物理转储和逻辑转储。 文件系统的一致性文件进行修改后，需将所有的修改都写回磁盘，如果在所有的磁盘块都写回磁盘前，系统崩溃，一些被修改的信息可能未被写回磁盘，那么文件系统将不一致。 因此，文件系统一般都有独立的程序可检查其一致性。 致性检查分为两种块的一致性检查和文件的一致性检查 文件系统的性能磁盘访问的速度比内存访问的速度慢得多，如果每次读文件时，都从磁盘块中读取，那么IO时间将是大大拖累程序效率。 主要通过以下方法提高性能： 高速缓存：减少磁盘访问次数技术是块高速缓存（block cache）或者缓冲区高速缓存（buffer cache） 块预读：在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。 减少磁盘臂运动：把可能顺序访问的块放⼀起，当然最好是同⼀柱面上，从而减少磁盘臂的移动次数。 磁盘碎片整理：移动文件使它们相邻，并把所有的空闲空间放在⼀个或多个大的连续区域内。","link":"/Operating-System/File-Management/"},{"title":"动态规划","text":"动态规划（Dynamic Programming，简称DP），如果某一问题有很多重叠子问题，使用动态规划是最有效的。 和贪心的区别在于： 动态规划中每一个状态一定是由上一个状态推导出来的 贪心没有状态推导，而是从局部直接选最优的， 参考：代码随想录 卡子哥的DP五部曲： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 1、背包问题 对于面试，掌握01背包和完全背包就够用了，最多可以再来一个多重背包。 01背包有N件物品和一个最多能背重量为 W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 二维 dp[i][j]：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少 有两个方向推出来dp[i][j]： 不放物品 i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值 放物品 i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] ，就是背包放物品i得到的最大价值 动态转移公式：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])$ 初始化：由递推公式看出，必须初始化dp[0][j]（存放编号0的物品的时候，各个容量的背包所能存放的最大价值） 1234vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagWeight + 1, 0));for (int j = weight[0]; j &lt;= bagWeight; j++) { dp[0][j] = value[0];} 遍历顺序：先遍历物品和先遍历背包重量都可，先遍历物品更好理解 1234567891011121314151617181920212223/* 01背包- 动态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])*/func bagProblem(weight, value []int, bagWeight int) int { dp := make([][]int, len(weight)) for i := range dp { dp[i] = make([]int, bagWeight+1) } // 初始化, dp[0][j] for j := weight[0]; j &lt;= bagWeight; j++ { dp[0][j] = value[0] } for i := 1; i &lt; len(weight); i++ { for j := 0; j &lt;= bagWeight; j++ { if j &lt; weight[i] { // 放不下 dp[i][j] = dp[i-1][j] } else { dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]) } } } return dp[len(weight)-1][bagWeight]} 一维滚动数组：把二维 dp 降为一维 dp 对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]) 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组） 倒叙遍历是为了保证物品i只被放入一次 1234567891011// 滚动数组优化 一维// - dp[j] = max(dp[j], dp[j - weight[i]] + value[i])func bagProblemBetter(weight, value []int, bagWeight int) int { dp := make([]int, bagWeight+1) for i := range weight { for j := bagWeight; j &gt;= weight[i]; j-- { // 倒序，正序会状态重复 dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } return dp[bagWeight]} 完全背包有 N 件物品和一个最多能背重量为 W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 每件物品能用无数次，求解将哪些物品装入背包里物品价值总和最大。 01背包和完全背包唯一不同就是体现在遍历顺序上： 01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。 完全背包的物品是可以添加多次的，所以要从小到大去遍历 为什么遍历物品在外层循环，遍历背包容量在内层循环？ 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓 12345678910111213141516171819202122232425// 先遍历物品, 再遍历背包// ! 如果求组合数就是外层for循环遍历物品，内层for遍历背包。func bagProblem(weight, value []int, bagWeight int) int { dp := make([]int, bagWeight+1) for i := 0; i &lt; len(weight); i++ { for j := weight[i]; j &lt;= bagWeight; j++ { dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } return dp[bagWeight]}// 先遍历背包, 再遍历物品// ! 如果求排列数就是外层for遍历背包，内层for循环遍历物品func bagProblem2(weight, value []int, bagWeight int) int { dp := make([]int, bagWeight+1) for j := 0; j &lt;= bagWeight; j++ { for i := 0; i &lt; len(weight); i++ { if j &gt;= weight[i] { dp[j] = max(dp[j], dp[j-weight[i]]+value[i]) } } } return dp[bagWeight]} 多重背包有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 $M_i$ 件可用，每件耗费的空间是 $C_i$ ，价值是 $W_i$ 。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 每件物品最多有 $M_i$ 件可用，把 $M_i$ 件摊开，其实就是一个01背包问题了 123456789101112131415// ! 转换成 01 背包// - O(m*n*k)func bagProblem(weight, value, nums []int, bagweight int) int { dp := make([]int, bagweight+1) for i := range weight { for j := bagweight; j &gt;= weight[i]; j-- { // 遍历背包个数 for k := 1; k &lt;= nums[i] &amp;&amp; j-k*weight[i] &gt;= 0; k++ { dp[j] = max(dp[j], dp[j-k*weight[i]]+k*value[i]) } } //fmt.Println(dp) } return dp[bagweight]} 2、打家劫舍一条边 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i] 那么需要考虑2种情况： i 偷：$dp[i]=dp[i-2]+nums[i]$ i 不偷：$dp[i]=dp[i-1]$ 所以动态转移公式为：$dp[i]=max(dp[i-2]+nums[i],dp[i-1])$ 12345678910111213class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; }}; 围成圈 在一条边的基础上，收尾相连形成圈 只要比较 首和尾存一个 的两种情况即可。 12345678910111213141516171819class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return nums[0]; return max(robrob(nums, 0, nums.size() - 2), robrob(nums, 1, nums.size() - 1)); } int robrob(vector&lt;int&gt;&amp; nums, int start, int end) { if (start == end) return nums[start]; vector&lt;int&gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; }}; 形成树 变成一棵二叉树，树形dp 1234567891011输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. dp数组记录2个状态： dp[0]：记录不偷该节点所得到的的最大金钱 dp[1]：记录偷该节点所得到的的最大金钱 长度为2的数组怎么标记树中每个节点的状态呢？ 在递归的过程中，系统栈会保存每一层递归的参数 左右根顺序（后序）遍历，那么分为 2 种情况： 根偷：两个子结点不偷 $ = left[0] + right[0] + root-&gt;val$ 根不偷：考虑两个子结点偷 $ = max(left[0], left[1]) + max(right[0], right[1])$ 12345678910111213141516class Solution { public: int rob(TreeNode* root) { vector&lt;int&gt; ans = robTree(root); return max(ans[0], ans[1]); } vector&lt;int&gt; robTree(TreeNode* root) { if (root == nullptr) return {0, 0}; vector&lt;int&gt; left = robTree(root-&gt;left); vector&lt;int&gt; right = robTree(root-&gt;right); int v1 = max(left[0], left[1]) + max(right[0], right[1]); int v2 = left[0] + right[0] + root-&gt;val; return {v1, v2}; }}; 3、股票问题主要通过二维数组记录各个状态，分析好每个状态的转移公式即可。 也可以滚动数组优化到一维，相当于覆盖前面的状态，不过不容易理解。 买卖1次给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 虽然有动态规划的思想，但第一感觉还是这样写 123456789101112class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int minn = prices[0]; int ans = 0; for (int i = 1; i &lt; prices.size(); i++) { if (prices[i] - minn &gt; 0) ans = max(ans, prices[i] - minn); minn = min(minn, prices[i]); } return ans; }}; 买卖多次 你可以尽可能地完成更多的交易 二维数组记录2个状态： dp[i][0] ：表示第i天持有股票所得最多现金 dp[i][1] ：表示第i天不持有股票所得最多现金 1234567891011121314151617class Solution { public: // dp[i][0] 持有股票 // dp[i][1] 不持有股票 int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]); } return dp[prices.size() - 1][1]; }}; 最多买卖2次 你最多可以完成 两笔 交易。 二维数组记录5个状态： dp[i][0]：无操作 dp[i][1]：第一次买入状态 dp[i][2]：第一次卖出状态 dp[i][3]：第二次买入状态 dp[i][4]：第二次卖出状态 上面的状态不一定是第 i 天买入卖出，只是维持这种状态 12345678910111213141516class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return dp[prices.size() - 1][4]; }}; 最多买卖k次 你最多可以完成 k 笔交易。 照着上面那个维护 $2*k+1$ 个状态即可 1234567891011121314151617181920class Solution { public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2 * k + 1)); for (int i = 1; i &lt;= 2 * k; i += 2) { dp[0][i] = -prices[0]; } for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = dp[i - 1][0]; for (int j = 1; j &lt;= 2 * k; j++) { if (j &amp; 1) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]); else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]); } } return dp[prices.size() - 1][2 * k]; }}; 含冷却期 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票） 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天) 二维数组记录4个状态： dp[i][0]：买入状态 dp[i][1]：卖出状态（非冷却期） dp[i][2]：卖出状态（刚卖出） dp[i][3]：卖出状态（冷却期） 1234567891011121314151617class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(4)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][1], dp[i - 1][3]) - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; } return max(dp[prices.size() - 1][1], max(dp[prices.size() - 1][2], dp[prices.size() - 1][3])); }}; 含手续费 每笔交易你只需要为支付一次手续费。 跟买卖多次差不多，添上手续费即可 1234567891011121314class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]); // 这里减去手续费 } return dp[prices.size() - 1][1]; }}; 4、子序列问题子序列不连续 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列 那么分为两种情况： text1[i - 1] 与 text2[j - 1]相同 text1[i - 1] 与 text2[j - 1]不相同 123456789101112131415class Solution { public: int longestCommonSubsequence(string text1, string text2) { vector&lt;vector&lt;int&gt;&gt; dp(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1)); for (int i = 1; i &lt;= text1.size(); i++) { for (int j = 1; j &lt;= text2.size(); j++) { if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[text1.size()][text2.size()]; }}; 类似题目：不相交的线 只是换了种题目说法，解法一模一样，转换过来就是最长公共子序列 子序列连续 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 dp[i][j]：以下标i - 1结尾的字符串A与以下标j - 1结尾的字符串B的最长重复子数组 那么只要考虑nums1[i - 1] 与 nums2[j - 1]相同时，更新长度 12345678910111213141516class Solution { public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1)); int ans = 0; for (int i = 1; i &lt;= nums1.size(); i++) { for (int j = 1; j &lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; // else 无事发生，即 dp[i][j] = 0 ans = max(ans, dp[i][j]); } } return ans; }}; 编辑距离 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2的最近编辑距离 那么需要维护以下4种状态： 123456if (word1[i - 1] == word2[j - 1]) 不操作if (word1[i - 1] != word2[j - 1]) 增 删 换 操作一：word1删除一个元素，那么就是以下标 i - 2 为结尾的word1 与 j-1 为结尾的word2的最近编辑距离 再加上一个操作 即 dp[i][j] = dp[i - 1][j] + 1; 操作二：word2删除一个元素，那么就是以下标 i - 1 为结尾的word1 与 j-2 为结尾的word2的最近编辑距离 再加上一个操作 即 dp[i][j] = dp[i][j - 1] + 1; word2添加一个元素，相当于word1删除一个元素，即增删等同 操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。 即 dp[i][j] = dp[i - 1][j - 1] + 1; 123456789101112131415161718class Solution { public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; // 删除 i 个 for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; // 删除 j 个 for (int i = 1; i &lt;= word1.size(); i++) { for (int j = 1; j &lt;= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min({dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1}); } } return dp[word1.size()][word2.size()]; }}; 回文回文子串 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 dp[i][j]：表示区间范围[i,j] （左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false 当s[i]与s[j]不相等，dp[i][j]一定是false。 当s[i]与s[j]相等时， 情况一：下标 i 与 j 相同，同一个字符例如 a，当然是回文子串 情况二：下标 i 与 j 相差为1，例如aa，也是文子串 情况三：下标 i 与 j 相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看 i 到 j 区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true 一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的 123456789101112131415161718class Solution { public: int countSubstrings(string s) { int n = s.size(); int ans = 0; vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); for (int i = n - 1; i &gt;= 0; i--) { for (int j = i; j &lt; n; j++) { if (s[i] != s[j]) continue; if (j - i &lt;= 1 || dp[i + 1][j - 1]) { dp[i][j] = true; ans++; } } } return ans; }}; 回文子序列 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 dp[i][j]：字符串 s 在[i, j]范围内最长的回文子序列的长度 如果s[i]与s[j]相同，那么 $dp[i][j] = dp[i + 1][j - 1] + 2$ 如果s[i]与s[j]不相同，那么 $dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])$ 12345678910111213141516class Solution { public: int longestPalindromeSubseq(string s) { vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size())); for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt; s.size(); j++) { if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } return dp[0][s.size() - 1]; }};","link":"/Algorithm/Dynamic-Programming/"},{"title":"Go Module","text":"从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。 在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。 一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。 go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。 参考： 06｜构建模式：Go是怎么解决包依赖管理问题的？ (geekbang.org) 1、Go Module 构建模式语义导入版本机制在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成 按照语义版本规范， 主版本号不同的两个版本是相互不兼容的； 在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本； 补丁版本号也不影响兼容性。 Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。 12345678910// 通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本// 假如这是 v1.x.x 版本import &quot;github.com/sirupsen/logrus&quot; // 如果要导入 v2.x.x 版本import &quot;github.com/sirupsen/logrus/v2&quot;// 甚至可以同时依赖一个包的两个不兼容版本import ( &quot;github.com/sirupsen/logrus&quot; logv2 &quot;github.com/sirupsen/logrus/v2&quot;) Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径 最小版本选择原则依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？ 当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。 不过，Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本” 这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。 2、Go module 版本管理（1）Go Module 创建创建一个 Go Module，通常有如下几个步骤： 通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module； 通过 go mod tidy 命令自动更新当前 module 的依赖信息； 执行 go build，执行新 module 的构建。 （2）为当前 module 添加一个依赖12345# 手动添加$ go get github.com/google/uuid# 自动添加$ go mod tidy （3）升级 / 降级依赖的版本12# 选定指定版本即可$go get github.com/sirupsen/logrus@v1.7.0 （4）移除一个依赖仅从源码中删除对依赖项的导入语句还不够，还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。 go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。 （5）vendorvendor 机制可以对 vendor 目录下缓存的依赖包进行自动管理。 在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非 go build 传入 -mod=mod 的参数。 12345678910$go mod vendor$tree -LF 2 vendorvendor├── github.com/│ ├── google/│ ├── magefile/│ └── sirupsen/├── golang.org/│ └── x/└── modules.txt 3、空导入像下面代码这样的包导入方式被称为“空导入”：import _ &quot;foo&quot; 空导入也是导入，意味着我们将依赖foo这个路径下的包。 由于是空导入，我们并没有显式使用这个包中的任何语法元素。 通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。","link":"/Language/Go-Module/"},{"title":"Gradle——从Groovy迁移到KTS","text":"在Android Studio中将Gradle配置从 Groovy 迁移到 KTS，即用 Kotlin 代替 Groovy 编写Gradle脚本。 参考： 官方文档 将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers 知乎 快速迁移 Gradle 脚本至 KTS - 知乎 (zhihu.com) 1、转换规则 Groovy 允许使用单引号来定义字符串，而 Kotlin 则要求使用双引号： 即include ':app' -&gt; include &quot;:app&quot; // '(.*?[^\\\\])' 正则替换 &quot;$1&quot; 在 Groovy 中使用 $ 前缀来表示基于句点表达式的字符串插值，但在 Kotlin 中需要使用大括号括住整个变量： 即myRootDirectory = &quot;$project.rootDir/tools&quot; 改为：myRootDirectory = &quot;${project.rootDir}/tools&quot; 显式和隐式 buildTypes：在 KTS 中，仅 debug 和 release buildTypes 是隐式提供的，而 staging 则必须手动创建 12345678910buildTypes getByName(&quot;debug&quot;) { ... } getByName(&quot;release&quot;) { ... } create(&quot;staging&quot;) { ... } 使用 plugins 代码块：给方法调用加上括号 1234567// (\\w+) (([^=\\{\\s]+)(.*)) 正则替换 $1($2)plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;) id(&quot;kotlin-kapt&quot;) id(&quot;androidx.navigation.safeargs.kotlin&quot;)} 更多请参考 Gradle | Kotlin (kotlinlang.org) 2、逐个迁移按上述转换规则逐个迁移以下文件，每迁移一个文件，都 sync 一遍查看是否出现问题。 下列每个迁移前，先把文件扩展名添加为 *.gradle.kts 1、迁移 setting.gradle123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;your app name&quot;include(&quot;:app&quot;) 2、迁移项目的 build.gradle1234567891011121314buildscript { repositories { google() mavenCentral() } dependencies { classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20&quot;) }}tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 3、迁移模块的 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}android { compileSdk = 30 defaultConfig { applicationId = &quot;github.sukieva.hhuer&quot; minSdk = 24 targetSdk = 30 versionCode = 1 versionName = &quot;1.0&quot; } buildTypes { release { isMinifyEnabled = false proguardFiles(&quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility(JavaVersion.VERSION_1_8) targetCompatibility(JavaVersion.VERSION_1_8) } kotlinOptions { jvmTarget = &quot;1.8&quot; }}dependencies { implementation(&quot;androidx.core:core-ktx:1.6.0&quot;) implementation(&quot;androidx.appcompat:appcompat:1.3.1&quot;) implementation(&quot;com.google.android.material:material:1.4.0&quot;) implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.0&quot;) testImplementation(&quot;junit:junit:4.+&quot;) androidTestImplementation(&quot;androidx.test.ext:junit:1.1.3&quot;) androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.4.0&quot;)} 3、代码优化可以在项目的build.gradle.kts里添加定义属性，在其他配置文件可直接访问。 12345678910val defaultManagerPackageName by extra(&quot;github.sukieva.hhuer&quot;)val verCode by extra(20210924)val verName by extra(&quot;1.0&quot;)val androidTargetSdkVersion by extra(31)val androidMinSdkVersion by extra(27)val androidBuildToolsVersion by extra(&quot;31.0.0&quot;)val androidCompileSdkVersion by extra(31)val androidCompileNdkVersion by extra(&quot;23.0.7599858&quot;)val androidSourceCompatibility by extra(JavaVersion.VERSION_11)val androidTargetCompatibility by extra(JavaVersion.VERSION_11) 3、可能出现的问题1、code insight unavailable因为期间重启过几次Android Studio不太确定怎么排除的，可能切换kotlin到dev版能解决此问题。","link":"/Android/Gradle-Gradle2kts/"},{"title":"Gradle——Android Build 构建配置","text":"Android 构建系统会编译应用资源和源代码，然后将它们打包到 APK 或 Android App Bundle 中，供测试、部署、签名和分发。Android Studio 会使用高级构建工具包 Gradle 自动执行和管理构建流程，同时也允许定义灵活的自定义 build 配置。 参考: 配置 build | Android 开发者 | Android Developers 史上最全Android build.gradle配置详解，你懂的！ - 掘金 (juejin.cn) 1、构建流程典型 Android 应用模块的构建流程按照以下常规步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。 打包器将 DEX 文件和编译后的资源组合成 APK 或 AAB（具体取决于所选的 build 目标）。 必须先为 APK 或 AAB 签名，然后才能将应用安装到 Android 设备或分发到 Google Play 等商店。 打包器使用调试或发布密钥库为 APK 或 AAB 签名： 1. 如果您构建的是调试版应用（即专门用来测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 2. 如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库（您需要进行配置）为应用签名。如需创建发布密钥库，请参阅[在 Android Studio 中为应用签名](https://developer.android.com/studio/publish/app-signing#studio)。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，您将获得应用的调试版或发布版 APK/AAB，以用于部署、测试或向外部用户发布。 2、配置文件1、Gradle 设置文件settings.gradle 文件位于项目的根目录下，用于指示 Gradle 在构建应用时应将哪些模块包含在内。 123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;hhuer&quot;include(&quot;:app&quot;) 2、项目 build 文件顶层 build.gradle 文件位于项目的根目录下，用于定义适用于项目中所有模块的构建配置。 默认情况下，顶层 build 文件使用 buildscript 代码块定义项目中所有模块共用的 Gradle 代码库和依赖项。 1234567891011121314151617buildscript { // gradle脚本执行所需依赖 repositories { // 配置远程仓库 google() // 引用google上的开源项目 mavenCentral() // 引用 jcenter上的开源项目，现已经替换为 mavenCenter } dependencies { // 配置构建工具 classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0-M1&quot;) }}// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 配置项目全局属性项目包含多个模块时，可以在文件中添加公用配置。 123456789101112buildscript {...}allprojects {...}// 使用mapextra[&quot;compileSdkVersion&quot;] = 28// You can also create properties to specify versions for dependencies.// Having consistent versions between modules can avoid conflicts with behavior.extra[&quot;supportLibVersion&quot;] = &quot;28.0.0&quot;// 或者使用 Kotlin 委托 https://www.runoob.com/kotlin/kotlin-delegated.htmlval compileSdkVersion by extra(31)val supportLibVersion by extra(&quot;28.0.0&quot;) 在模块中使用以下代码引用即可： 123val sdkVersion: Int by rootProject.extra...compileSdkVersion(sdkVersion) 注意：虽然 Gradle 可让您在模块级别定义项目全局属性，但您应避免这样做，因为这样会导致共享这些属性的模块相互结合。模块结合使得以后将模块作为独立项目导出更加困难，并实际妨碍 Gradle 利用并行项目执行加快多模块构建。 3、模块 build 文件模块级 build.gradle 文件位于每个 project/module/ 目录下，用于为其所在的特定模块配置构建设置。您可以通过配置这些 build 设置提供自定义打包选项（如额外的 build 类型和产品变种），以及替换 main/ 应用清单或顶层 build.gradle 文件中的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}// 上面全局配置的引用val androidTargetSdkVersion: Int by rootProject.extra// 配置项目构建的各种属性android { compileSdk = androidCompileSdkVersion //设置编译时用的Android版本 ... defaultConfig { // app 相关 applicationId = defaultManagerPackageName // 包名 minSdk = androidMinSdkVersion // 最低兼容版本 targetSdk = androidTargetSdkVersion // 目标安卓版本 versionCode = verCode // 版本号 versionName = verName // 版本名称 //若使用AndroidJUnitRunner进行单元测试 //testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } //指定生成安装文件的主要配置，一般包含两个子闭包: //一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写； //另一个是release闭包，用于指定生成正式版安装文件的配置。 buildTypes { release { // 一般使用如下两项 isMinifyEnabled = false //是否对代码进行混淆 proguardFiles(&quot;proguard-rules.pro&quot;) //指定混淆的规则文件 } } compileOptions { sourceCompatibility(androidSourceCompatibility) targetCompatibility(androidTargetCompatibility) } kotlinOptions { jvmTarget = &quot;1.8&quot; } packagingOptions{//打包时的相关配置 //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' }}dependencies { // 项目的依赖 // Dependency on a local library module implementation project(&quot;:mylibrary&quot;) // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3' ...}configurations.all { exclude(group = &quot;androidx.appcompat&quot;, module = &quot;appcompat&quot;)} 4、更多模块配置项设置应用 ID添加构建依赖项Android Gradle 插件可以使用的原生依赖项优化构建速度排查构建性能问题分析构建性能配置 build 变体构建多个 APK合并多个清单文件将构建变量注入清单缩减、混淆处理和优化应用为方法数超过 64K 的应用启用 MultiDex 使用 APK 分析器分析您的 build使用 Maven Publish 插件Gradle 提示与诀窍将构建配置从 Groovy 迁移到 KTS 此部分可以参考 Gradle——从Groovy迁移到KTS - Sakurasou","link":"/Android/Gradle-Build/"},{"title":"Jetpack——Lifecycle","text":"Lifecycle组件可以让任何一个类都能轻松感知到Activity的生命周期，同时不需要再Activity中编写太多额外的逻辑。 参考： Lifecycle | Android 开发者 | Android Developers Android官方架构组件:Lifecycle详解&amp;原理分析_却把清梅嗅的博客-CSDN博客_lifecycle原理 1、生命周期生命周期和状态事件如图所示： ## 2、Lifecycles 的最佳实践 一般在 ViewModel中观察和控制界面。 保持 UI 控制器（Activity 和 Fragment）尽可能的精简。它们不应该试图去获取它们所需的数据；相反，要用 ViewModel来获取，并且观察 LiveData将数据变化反映到视图中。 尝试编写数据驱动（data-driven）的 UI，即 UI 控制器的责任是在数据改变时更新视图或者将用户的操作通知给 ViewModel。 将数据逻辑放到 ViewModel 类中。ViewModel 应该作为 UI 控制器和应用程序其它部分的连接服务。注意：不是由 ViewModel 负责获取数据（例如：从网络获取）。相反，ViewModel 调用相应的组件获取数据，然后将数据获取结果提供给 UI 控制器。 使用Data Binding来保持视图和 UI 控制器之间的接口干净。这样可以让视图更具声明性，并且尽可能减少在 Activity 和 Fragment 中编写更新代码。如果你喜欢在 Java 中执行该操作，请使用像Butter Knife 这样的库来避免使用样板代码并进行更好的抽象化。 如果 UI 很复杂，可以考虑创建一个 Presenter 类来处理 UI 的修改。虽然通常这样做不是必要的，但可能会让 UI 更容易测试。 不要在 ViewModel 中引用View或者 Activity的 context。因为如果ViewModel存活的比 Activity 时间长（在配置更改的情况下），Activity 将会被泄漏并且无法被正确的回收。","link":"/Android/Jetpack-Lifecycle/"},{"title":"Jetpack——ViewModel","text":"ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。 参考： ViewModel 概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期ViewModel的一个重要作用是帮助Activity分担部分工作，专门用来存放与界面相关的数据，减轻Activity负担。 另外，如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。而ViewModel的生命周期和Activity不同，只有Activity退出时才会跟着一起销毁。 ViewModel对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失： 对于 activity，是在 activity 完成时； 对于 fragment，是在 fragment 分离时。 通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel","link":"/Android/Jetpack-ViewModel/"},{"title":"Jetpack——Compose","text":"使用 JetpackCompose 的一些笔记。 关键术语 - 组合：Jetpack Compose 在执行可组合项时构建的界面描述。 初始组合：通过首次运行可组合项创建组合。 重组：在数据发生变化时重新运行可组合项以更新组合。 'Surface' A surface container using the 'background' color from the theme 'Divider' is a provided composable function that creates a horizontal divider. 可组合项中的状态可组合函数可以使用 remember 可组合项记住单个对象。 系统会在初始组合期间将由 remember 计算的值存储在组合中，并在重组期间返回存储的值。 remember 既可用于存储可变对象，又可用于存储不可变对象。 mutableStateOf会创建可观察的 MutableState 会创建可观察的 MutableState，后者是与 Compose 运行时集成的可观察类型。 在可组合项中声明 MutableState 对象的方法有三种（等价）： val mutableState = remember { mutableStateOf(default) } var value by remember { mutableStateOf(default) } val (value, setValue) = remember { mutableStateOf(default) } 1234567@Composablefun Counter() { val count = remember { mutableStateOf(0) } Button(onClick = { count.value++ }) { Text(&quot;I've been clicked ${count.value} times&quot;) }} Color primary：main brand color secondary：provide accents Typography","link":"/Android/Jetpack-Compose/"},{"title":"Linux指令——文件与权限","text":"Linux系统中常用的文件目录管理和文件权限管理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文件目录管理命令tree ：以树状图列出目录的内容命令描述：tree命令用于以树状图列出目录的内容。 tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装： 1yum install -y tree 命令使用示例： 1tree /usr/share/wallpapers/ ls ：显示指定工作目录下的内容注意是 L 的小写，不是大写 I 命令描述： ls命令用于显示指定工作目录下的内容。 命令格式：ls [参数] [目录名] 参数说明： 参数 说明 -a 显示所有文件及目录（包括隐藏文件） -l 将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l） -r 将文件反序列出（默认按英文字母正序） -t 将文件按创建时间正序列出 -R 递归遍历目录下文件 pwd ：获取当前工作目录的绝对路径命令描述：获取当前工作目录的绝对路径。 命令使用：pwd cd ：切换工作目录命令描述：cd命令用于切换工作目录。 在路径表示中： 一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。 两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。 cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。 touch ：修改文件或者目录的时间属性命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 命令格式：touch [参数] [文件] 参数说明： 参数 说明 -c 如果指定文件不存在，不会建立新文件 -r 使用参考文件的时间记录 -t 设置文件的时间记录 mkdir ：新建子目录命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。 命令使用示例： 1mkdir -p a/b/c rm ：删除一个文件或者目录命令描述：rm命令用于删除一个文件或者目录。 命令格式：rm [参数] [文件] 参数说明： 参数 说明 -i 删除前逐一询问确认 -f 无需确认，直接删除 -r 删除目录下所有文件 cp ：复制文件或目录命令描述： cp命令主要用于复制文件或目录。 命令格式：cp [参数] [源文件] [目标文件] 参数说明： 参数 说明 -d 复制时保留链接 -f 覆盖已经存在的目标文件而不给出提示 -i 覆盖前询问 -p 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中 -r 复制目录及目录内的所有项目 mv ：为文件或目录改名 / 将文件或目录移入其它位置命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 命令格式：mv [参数] [源文件] [目标文件] 参数说明： 参数 说明-i 若指定目录已有同名文件，则先询问是否覆盖旧文件-f 如果目标文件已经存在，不会询问而直接覆盖 rename ：批量改变文件名命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。 命令格式：rename [原值] [替换值] 2、文件权限管理ls命令可以查看Linux系统上的文件、目录和设备的权限。 1ls -l /boot/ 上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。 第1位表示存档类型，d表示目录，-表示一般文件。 第2~4位表示当前用户的权限（属主权限）。 第5~7位表示同用户组的用户权限（属组权限）。 第8~10位表示不同用户组的用户权限（其他用户权限）。 第11位是一个半角句号.，表示SELinux安全标签。 用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。 例如efi目录的root用户权限为drwxr-xr-x.。 该目录对root用户具有读写和执行所有权限。 该目录对root组其他用户有读和执行权限。 该目录对其他用户有读和执行权限。 所以该权限表示对应八进制权限表示为： 属主权限：4+2+1=7。 属组权限：4+1=5。 其他用户权限：4+1=5。 即755。 chmod ：修改文件权限chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。 将hello.sh文件增加属主的执行权限。 1chmod u+x hello.sh 将hello.sh文件撤销属主的执行权限。 1chmod u-x hello.sh 将hello.sh文件权限修改为八进制表示的744权限。 1chmod 744 hello.sh u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。 chown ：修改文件的属主和属组chown命令修改文件的属主和属组 -R参数以递归方式对子目录和文件进行修改 ls -l命令显示的第三列和第四列就是文件的属主和属组信息。 修改test.txt文件的属主用户为test。 1chown test test.txt 修改test.txt文件的属主和属组为admin。 1chown admin:admin test.txt chgrp ：修改文件的属组chgrp命令用于修改文件的属组。 命令使用示例： 将test.txt文件的属组改为root。 1chgrp root test.txt","link":"/Linux/Linux-Files-And-Permissions/"},{"title":"哈希","text":"哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。 1、散列基本概念散列： 碰撞： 散列函数： 除余法： 例子： m=16*2=32 p=31 散列函数 h(key)=key%p 线性勘察法（开地址法处理碰撞） 例子： 已知n个关键码具有相同的散列值d，若采用线性探查法解决碰撞，则在散列这n个关键码的过程中，共将要发生n(n-1)/2 次碰撞 拉链法解决碰撞 例子： 平均查找长度ASL： 2、常见的三种哈希结构 参考： 哈希表理论基础 当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set（集合） map（映射） 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(logn) O(logn) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表 std::set 和std::multiset 的底层实现是红黑树 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(logn) O(logn) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表 std::map 和std::multimap 的底层实现是红黑树 使用时： 解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的 如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 java里的HashMap ，TreeMap 都是一样的原理。 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。 一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？ 实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。","link":"/Data-structure/Hash-Insider/"},{"title":"Golang","text":"Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 参考：Tony Bai · Go 语言第一课GitHub - unknwon/the-way-to-go_ZH_CN: 《The Way to Go》中文译本，中文正式名《Go 入门指南》《Go Web 编程》| Go 技术论坛 1、基础关键字Go 是一门类似 C 的编译型语言，但是它的编译速度非常快。 这门语言的关键字总共也就二十五个： 12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var 变量一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为变量。 声明变量的一般形式是使用 var 关键字：var identifier type 变量的类型放在变量的名称之后，是为了避免像 C 语言中那样含糊不清的声明形式。 C++：int* a, b; // a 是指针，b 不是 Go：var a,b *int // a，b 都是指针 12345678910111213141516171819202122var a intvar b boolvar str string// 因式分解关键字的写法，一般用于声明全局变量var ( a int b bool str string)// 声明与赋值（初始化）语句也可以组合起来var identifier [type] = valuevar a int = 15var i = 5 // 自动推断var b bool = falsevar str string = &quot;Go says hello to the world!&quot;// 短变量声明，用于函数体内声明局部变量a := 1a, b, c := 5, 7, &quot;abc&quot;a, b = b, a // 相当于C++中的 swap(a,b) 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写 如果全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写 值类型 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 像数组和结构体这些复合类型也是值类型 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝 可以通过 &amp;i 来获取变量 i 的内存地址（每次的地址都可能不一样），值类型的变量的值存储在栈中 引用类型 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置（这个内存地址被称之为指针） 在 Go 语言中，指针、slices（切片）、maps 和 channel 都属于引用类型 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制 当 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容 被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间 常量Go 语言的常量是一种在源码编译期间被创建的语法元素。 12345678const Pi float64 = 3.14159265358979323846 // 单行常量声明，显示const Pi = 3.14159 // 隐式// 以const代码块形式声明常量const ( size int64 = 4096 i, j, s = 13, 14, &quot;bar&quot; // 单行声明多个常量) 常量的类型只局限于基本数据类型，包括数值类型、字符串类型、布尔类型 Go 语言在常量方面的创新包括下面这几点： 支持无类型常量： 可以不显示指定类型，比如 const n = 13 支持隐式自动转型： 对于无类型常量参与的表达式求值，Go 编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的 可用于实现枚举： 隐式重复前一个非空表达式 12345const ( Apple, Banana = 11, 22 Strawberry, Grape = 11, 22 // 使用上一行的初始化表达式 Pear, Watermelon = 11, 22 // 使用上一行的初始化表达式) iota 是一个预定义标识符，可以从 0 开始自增（位于同一行的 iota 即便出现多次，多个 iota 的值也是一样的） 12345678const ( Apple, Banana = iota, iota + 10 // 0, 10 (iota = 0) Strawberry, Grape // 1, 11 (iota = 1) Pear, Watermelon // 2, 12 (iota = 2))// 如果想从 1 开始// _ = iota // 0 // 每遇到一次 const 关键字，iota 就重置为 0 数组数组是一个长度固定的、由同构类型元素组成的连续序列，包含两个重要属性：元素的类型和数组长度（元素的个数） 数组变量声明： 1234var arr [5]int // 一维var mArr [2][3][4]int // 多维var arr2 = [6]int { 11, 12, 13, 14, 15, 16,} // [11 12 13 14 15 16]var arr3 = [...]int { 21, 22, 23,} // [21 22 23] ... 自动计算元素个数 数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。 这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针。 切片在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。 切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。可以说，切片之于数组就像是文件描述符之于文件。 去掉“长度”这一束缚后，切片展现出更为灵活的特性 1var nums = []int{1, 2, 3, 4, 5, 6} 底层实现切片的底层数据结构：在运行时其实是一个三元组结构 12345type slice struct { array unsafe.Pointer // 是指向底层数组的指针 len int // 切片的长度，即切片中当前元素的个数 cap int // 底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值} Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同 创建切片的创建根据情况不同，主要通过以下3种方法创建： 1234567// 1、make 函数sl := make([]byte, 6, 10) // 其中10为cap值，即底层数组长度，6为切片的初始长度sl := make([]byte, 6) // cap = len = 6// 2、数组切片化 array[low : high : max]arr := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}sl := arr[3:7:9] // len = high - low ; cap = max - low ; 即数组下标 [3,7)// 3、切片创建切片 与 方法2 书写方法相同 动态扩容当通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。 1234567891011var s []ints = append(s, 11) fmt.Println(len(s), cap(s)) //1 1 创建底层数组 u1（长度1）s = append(s, 12) fmt.Println(len(s), cap(s)) //2 2 创建底层数组 u2（长度2 = u1的两倍），拷贝 u1 元素， array 指向 u2 s = append(s, 13) fmt.Println(len(s), cap(s)) //3 4 创建底层数组 u3（长度4 = u2的两倍），拷贝 u2 元素， array 指向 u3s = append(s, 14) fmt.Println(len(s), cap(s)) //4 4 cap 足够s = append(s, 15) fmt.Println(len(s), cap(s)) //5 8 创建底层数组 u4（长度8 = u3的两倍），拷贝 u3 元素， array 指向 u4 mapmap 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。 形式：map[key_type]value_type Go 语言中要求，key 的类型必须支持“==”和“!=”两种比较操作符。 函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。 底层实现Go 运行时使用一张哈希表来实现抽象的 map 类型。 运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。 在编译阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。 123456789101112// 创建map类型变量实例m := make(map[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)// 插入新键值对或给键重新赋值m[&quot;key&quot;] = &quot;value&quot; → v := runtime.mapassign(maptype, m, &quot;key&quot;) v是用于后续存储value的空间的地址// 获取某键的值 v := m[&quot;key&quot;] → v := runtime.mapaccess1(maptype, m, &quot;key&quot;)v, ok := m[&quot;key&quot;] → v, ok := runtime.mapaccess2(maptype, m, &quot;key&quot;)// 删除某键delete(m, &quot;key&quot;) → runtime.mapdelete(maptype, m, “key”) hmap 类型是 map 类型的头部结构（header），之前提到的 map 类型的描述符，它存储了后续 map 类型操作所需的所有信息 不要依赖 map 的元素遍历顺序； map 不是线程安全的，不支持并发读写； 不要尝试获取 map 中元素（value）的地址 map扩容： 当 count &gt; LoadFactor * 2^B 或 overflow bucket 过多时，运行时会自动对 map 进行扩容（ Go 最新 1.17 版本 LoadFactor 设置为 6.5） 初始化切片类型，初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用” map 类型，因为它内部实现的复杂性，无法“零值可用” 1234567891011121314151617181920var m map[string]int // m = nilm[&quot;key&quot;] = 1 // 发生运行时异常：panic: assignment to entry in nil map// 1、使用复合字面值初始化 map 类型变量，m := map[int]string{}type Position struct { x float64 y float64}// Go 允许省略字面值中的元素类型m2 := map[Position]string{ Position{29.935523, 52.568915}: &quot;school&quot;, // Postion 可省略，如下 {25.352594, 113.304361}: &quot;shopping-mall&quot;, {73.224455, 111.804306}: &quot;hospital&quot;,}// 2、make 函数m1 := make(map[int]string) // 未指定初始容量m2 := make(map[int]string, 8) // 指定初始容量为8 基本操作和切片类型一样，map 也是引用类型。 这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。 123456789101112131415// 插入，更新相同m := make(map[int]string)m[1] = &quot;value1&quot;// 查找v := m[&quot;key1&quot;]v, ok := m[&quot;key1&quot;]if !ok { // &quot;key1&quot;不在map中}// 删除delete(m, &quot;key2&quot;) // 删除&quot;key2&quot;// 遍历，对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同for k, v := range m { fmt.Printf(&quot;[%d, %d] &quot;, k, v) } 2、控制结构if-else123456789101112if condition1 { // do something } else if condition2 { // do something else } else { // catch-all or default}// 多返回值简化if value, ok := readData(); ok { // do something} switch123456789101112131415161718192021222324252627282930switch var1 { case val1: ... case val2: ... default: ...}func checkWorkday(a int) { switch a { case 1, 2, 3, 4, 5: println(&quot;it is a work day&quot;) case 6, 7: println(&quot;it is a weekend day&quot;) default: println(&quot;are you live on earth&quot;) }}//如果需要执行下一个 case 的代码逻辑，可以显式使用 Go 提供的关键字 fallthrough 来实现switch switchexpr() { case case1(): println(&quot;exec case1&quot;) fallthrough case case2(): println(&quot;exec case2&quot;) fallthrough default: println(&quot;exec default&quot;) } forGo 语言不提供 while，所以 for 循环更加强大 12345678for i := 0; i &lt; 5; i++ { fmt.Printf(&quot;This is the %d iteration\\n&quot;, i)}for i &gt;= 0 { i = i - 1 fmt.Printf(&quot;The variable i is now: %d\\n&quot;, i)} for-range遍历数组、切片、字符串、map等的好帮手 123for i, v := range sl { fmt.Printf(&quot;sl[%d] = %d\\n&quot;, i, v)} break、continue 与其他语言功能相同 label +goto 会造成可读性极差，不推荐使用（基本没看到人用） 3、函数Go 函数支持多返回值，函数定义一般如下形式： 12345func funcName(参数列表) 返回值列表func foo() // 无返回值func foo() error // 仅有一个返回值func foo() (int, string, error) // 有2或2个以上返回值 函数在 Go 语言中属于“一等公民（First-Class Citizen）”： Go 函数可以存储在变量中，且拥有自己的类型 1234var dfs func(index int) // 函数类型dfs = func(index int) { // 匿名函数，闭包 // ...} 支持在函数内创建并通过返回值返回 12345func dfs(task string) func() { return func() { // ... }} 作为参数传入函数 1time.AfterFunc(time.Second*2, func() { println(&quot;timer fired&quot;) }) 参数传递按值传递 call by value Go 默认使用按值传递来传递参数，也就是传递参数的副本（逐位拷贝）。 函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量 引用传递 call by reference 如果希望函数可以直接修改参数的值，而不是对参数的副本进行操作， 需要将参数的地址（变量名前面添加&amp;符号，比如 &amp;variable）传递给函数，这就是引用传递。 传递指针（一个32位或者64位的值）的消耗都比传递副本来得少 变长参数如果函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。 12func Greeting(prefix string, who ...string)Greeting(&quot;hello:&quot;, &quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;) 命名返回值尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。 12345678910func getX2AndX3(input int) (int, int) { // 非命名 return 2 * input, 3 * input}func getX2AndX3_2(input int) (x2 int, x3 int) { // 命名 x2 = 2 * input x3 = 3 * input // return x2, x3 return} deferdefer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。 在 Go 中，只有在函数（和方法）内部才能使用 defer defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。 defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行。 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。 所以，deferred 函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。 123456789101112// 关闭文件流// open a file defer file.Close()// 解锁加锁的资源mu.Lock() defer mu.Unlock()// 打印最终报告printHeader() defer printFooter()// 关闭数据库连接// open a database connection defer disconnectFromDB() 跟踪使用 defer 可以跟踪函数的执行过程 1234567891011121314151617181920func Trace(name string) func() { println(&quot;enter:&quot;, name) return func() { println(&quot;exit:&quot;, name) }}func foo() { defer Trace(&quot;foo&quot;)() bar()}func bar() { defer Trace(&quot;bar&quot;)()}func main() { defer Trace(&quot;main&quot;)() foo()} 输出： 123456enter: mainenter: fooenter: barexit: barexit: fooexit: main 内置函数 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）new() 是一个函数，不要忘记它的括号 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数（详见第 4.5.2.2 节） 4、结构与方法struct结构体定义的一般方式如下： 12345678910111213141516type identifier struct { field1 type1 field2 type2 ...}type Person struct { Name string Phone string Addr string}// 可以无需提供字段的名字，只需要使用其类型就可以了type Book struct { Title string Person // 嵌入字段（匿名字段）} type T struct {a, b int} 也是合法的语法，它更适用于简单的结构体。 初始化1234567891011121314151617181920212223242526// 1-struct as a value type:var pers1 Personpers1.firstName = &quot;Chris&quot;pers1.lastName = &quot;Woodward&quot;upPerson(&amp;pers1)// 2—struct as a pointer:pers2 := new(Person)pers2.firstName = &quot;Chris&quot;pers2.lastName = &quot;Woodward&quot;(*pers2).lastName = &quot;Woodward&quot; // 这是合法的upPerson(pers2)// 3—struct as a literal:pers3 := &amp;Person{&quot;Chris&quot;,&quot;Woodward&quot;}upPerson(pers3)// 更常用：field:value 形式的复合字面值t := &amp;Timer{ C: c, r: runtimeTimer{ when: when(d), f: sendTime, arg: c, }, } method在 Go 语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？ Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。 定义方法的一般格式如下： 1func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... } 方法声明要与 receiver 参数的基类型声明放在同一个包内。（即 struct 与 method 在同一个 package） receiver 参数的基类型本身不能为指针类型或接口类型 123456789101112type TwoInts struct { a int b int}func (tn *TwoInts) AddThem() int { return tn.a + tn.b}func (tn *TwoInts) AddToParam(param int) int { return tn.a + tn.b + param} receiver 参数的选择 如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型 如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些 T 类型是否需要实现某个接口，也就是是否存在将 T 类型的变量赋值给某接口类型变量的情况。 如果需要，那使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法 如果 T 不需要，但 *T 需要，*T 的方法集合是包含 T 的方法集合的，参考上面2个原则选择 总结： 类型 T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 类型 *T 的可调用方法集包含接受者为 *T 的所有方法 类型 *T 的可调用方法集不包含接受者为 T 的方法 5、接口与反射interfaceGo 语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。 但是 Go 语言里有非常灵活的 接口 概念，通过它可以实现很多面向对象的特性。 接口提供了一种方式来 说明 对象的行为：如果谁能搞定这件事，它就可以用在这儿。 接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。 通过如下格式定义接口： 12345type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ...} 上面的 Namer 是一个 接口类型。 命名： 接口的名字由方法名加 er 后缀组成 当后缀 er 不合适时，以 able 结尾或者以 I 开头，比如 Recoverable 通常它们会包含 0 个、最多 3 个方法（小接口，抽象程度高） 空接口 如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集，类型 T 实现了接口类型 I， 那么类型 T 的变量就可以作为合法的右值赋值给接口类型 I 的变量。 空接口类型的这一可接受任意类型变量值作为右值的特性，是 Go 加入泛型语法之前唯一一种具有“泛型”能力的语法元素 123456var i interface{} = 15 // oki = &quot;hello, golang&quot; // oktype T struct{}var t Ti = t // oki = &amp;t // ok 类型断言一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的 动态 类型，即运行时在变量中存储的值的实际类型。 在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。 类型 T 的值： 123456v := varI.(T) // unchecked type assertion，varI 必须是一个接口变量if v, ok := varI.(T); ok { // checked type assertion，一般用这种方法 Process(v) return}// varI is not of type 如果断言成功，变量 v 的类型为 i 的值的类型，而并非接口类型 T 如果断言失败，v 的类型信息为接口类型 T，它的值为 nil 类型判断接口变量的类型也可以使用一种特殊形式的 switch 来检测：type-switch 12345678910switch t := areaIntf.(type) {case *Square: fmt.Printf(&quot;Type Square %T with value %v\\n&quot;, t, t)case *Circle: fmt.Printf(&quot;Type Circle %T with value %v\\n&quot;, t, t)case nil: fmt.Printf(&quot;nil value: nothing to check?\\n&quot;)default: fmt.Printf(&quot;Unexpected type %T\\n&quot;, t)} reflection反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。 反射可以在运行时检查类型和变量，例如它的大小、方法和 动态 的调用这些方法。 这对于没有源代码的包尤其有用，除非真得有必要，否则应当避免使用或小心使用。 变量的最基本信息就是类型和值：反射包的 Type 用来表示一个 Go 类型，反射包的 Value 为 Go 值提供了反射接口。 实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。 12func TypeOf(i interface{}) Typefunc ValueOf(i interface{}) Value 更多查看反射包 unknwon/the-way-to-go_ZH_CN · GitHub Go中的面向对象OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？ 封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层: 1）包范围内的：通过标识符首字母小写，对象 只在它所在的包内可见 2）可导出的：通过标识符首字母大写，对象 对所在包以外也可见 类型只拥有自己所在包中定义的方法。 继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现 多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。 6、并发并发是一种能力，它让你的程序可以由若干个代码片段组合而成，并且每个片段都是独立运行的。 Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了goroutine这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。 Goroutine相比传统操作系统线程来说，goroutine 的优势主要是： 资源占用小，每个 goroutine 的初始栈大小仅为 2k 由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小 在语言层面而不是通过标准库提供。goroutine 由go关键字创建，一退出就会被回收或销毁，开发体验更佳 语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。 创建Go 语言通过go关键字+函数/方法的方式创建一个 goroutine。 创建后，新 goroutine 将拥有独立的代码执行流，并与创建它的 goroutine 一起被 Go 运行时调度。 123456789go fmt.Println(&quot;I am a goroutine&quot;)var c = make(chan int)go func(a, b int) { // 匿名函数/闭包 c &lt;- a + b}(3,4) // $GOROOT/src/net/http/server.goc := srv.newConn(rw)go c.serve(connCtx) // 命名函数/方法 不需要考虑对 goroutine 的退出进行控制：goroutine 的执行函数的返回，就意味着 goroutine 退出。 如果需要手动控制，通过 channel实现 channel传统语言的并发模型是基于对内存的共享的 传统的编程语言（比如：C++、Java、Python 等）并非面向并发而生的，所以他们面对并发的逻辑多是基于操作系统的线程。 并发的执行单元（线程）之间的通信，利用的也是操作系统提供的线程或进程间通信的原语， 比如：共享内存、信号（signal）、管道（pipe）、消息队列、套接字（socket）等。 channel 既可以用来实现 Goroutine 间的通信，还可以实现 Goroutine 间的同步。 创建和切片、结构体、map 等一样，channel 也是一种复合数据类型。 channel 类型变量赋初值的唯一方法是使用 make 。 1234567var ch chan int // 声明 int 类型的 channel 类型变量，默认值为 nilch1 := make(chan int) //无缓冲ch2 := make(chan int, 5) //带缓冲，5是缓冲长度ch1 := make(chan&lt;- int, 1) // 只发送channel类型ch2 := make(&lt;-chan int, 1) // 只接收channel类型 发送和接收Go 提供了&lt;-操作符用于对 channel 类型变量进行发送与接收操作： 1234ch1 &lt;- 13 // 将整型字面值13发送到无缓冲channel类型变量ch1中n := &lt;- ch1 // 从无缓冲channel类型变量ch1中接收一个整型值存储到整型变量n中ch2 &lt;- 17 // 将整型字面值17发送到带缓冲channel类型变量ch2中m := &lt;- ch2 // 从带缓冲channel类型变量ch2中接收一个整型值存储到整型变量m中 无缓冲 channel：发送与接收操作同步，一定要放在两个不同的 Goroutine 中进行，否则会导致 deadlock 带缓冲 channel：发送或接收不需要阻塞等待，异步 123456ch2 := make(chan int, 1)n := &lt;-ch2 // 由于此时ch2的缓冲区中无数据，因此对其进行接收操作将导致goroutine挂起ch3 := make(chan int, 1)ch3 &lt;- 17 // 向ch3发送一个整型数17ch3 &lt;- 27 // 由于此时ch3中缓冲区已满，再向ch3发送数据也将导致goroutine挂起 关闭调用 go 内置的 close()函数，发送端负责关闭 channel 123456789close(ch)// 判断是否关闭可以用 c,okn := &lt;- ch // 当ch被关闭后，n将被赋值为ch元素类型的零值m, ok := &lt;-ch // 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为falsefor v := range ch { // 当ch被关闭后，for range循环结束 ... ...} select通过 select，我们可以同时在多个 channel 上进行发送 / 接收操作： 123456789101112select {case x := &lt;-ch1: // 从channel ch1接收数据 ... ...case y, ok := &lt;-ch2: // 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭 ... ...case ch3 &lt;- z: // 将z值发送到channel ch3中: ... ...default: // 当上面case中的channel通信均无法实施时，执行该默认分支} channel 和 select 的结合使用能形成强大的表达能力： 利用 default 分支避免阻塞 实现超时机制 实现心跳机制 lenlen 是 Go 语言的一个内置函数，它支持接收数组、切片、map、字符串和 channel 类型的参数，并返回对应类型的“长度”，也就是一个整型值。 针对 channel ch 的类型不同，len(ch) 有如下两种语义： 当 ch 为无缓冲 channel 时，len(ch) 总是返回 0 当 ch 为带缓冲 channel 时，len(ch) 返回当前 channel ch 中尚未被读取的元素个数 应用无缓冲无缓冲 channel 兼具通信和同步特性，在并发程序中应用颇为广泛。 信号传递 替代锁机制 带缓冲带缓冲的 channel 与无缓冲的 channel 的最大不同之处，就在于它的异步性。 对一个带缓冲 channel： 在缓冲区未满的情况下，对它进行发送操作的 Goroutine 不会阻塞挂起 在缓冲区有数据的情况下，对它进行接收操作的 Goroutine 也不会阻塞挂起 所以可以用于： 消息队列 计数信号量 7、常用包strings作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 strings 包来完成对字符串的主要操作。 strings package - strings - pkg.go.dev 常用函数： 12345678910111213141516171819202122232425262728// 判断前缀strings.HasPrefix(s, prefix string) bool // 判断后缀strings.HasSuffix(s, suffix string) bool// 字符串包含strings.Contains(s, substr string) bool// 字符串替换strings.Replace(str, old, new string, n int) string // 替换old的前 n 个字符， n=-1 替换整个 old// 判断索引（出现位置）strings.Index(s, str string) int // -1 表示不包含strings.LastIndex(s, str string) int // 最后出现的位置strings.IndexRune(s string, r rune) int // 非 ASCII 编码的字符，strings.IndexRune(&quot;chicken&quot;, 99)// 出现次数strings.Count(s, str string) int// 重复字符串strings.Repeat(s, count int) string //重复 count 次字符串 s 并返回一个新的字符串// 大小写转换strings.ToLower(s) stringstrings.ToUpper(s) string// 修剪strings.TrimSpace(s) // 剔除开头和结尾的空白符号strings.Trim(s, &quot;cut&quot;) // 剔除开头和结尾指定字符，TrimLeft，TrimRight 只剔除一边// 分割，返回 slicestrings.Fields(s) // 用一个或多个空白分割，全是空白则返回长度 0 的切片strings.Split(s, sep) // 用指定字符串 seq 分割// 拼接strings.Join(sl []string, sep string) string // seq 为分隔符， sl 为字符串切片// 例如：strings.Join([]string{&quot;删除：文件夹&quot;, path}, &quot; &quot;) strconv与字符串相关的类型转换都是通过 strconv 包实现的。 strconv package - strconv - pkg.go.dev 常用函数： 1234567891011strconv.IntSize // 当前操作系统 int 所占位置// 整数转字符串strconv.Itoa(i int) string// 浮点数转字符串strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string // 其中 fmt 表示格式（其值可以是 'b'、'e'、'f' 或 'g'） // prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64// 字符串转整数strconv.Atoi(s string) (i int, err error)// 浮点数转字符串strconv.ParseFloat(s string, bitSize int) (f float64, err error) timetime 包为我们提供了一个数据类型 time.Time（作为值使用）以及显示和测量时间和日期的功能函数。 time package - time - pkg.go.dev 常用函数： 12345t := time.Now() // 当前时间t.Day()t.Minute()// 标准格式化t.Format(&quot;02 Jan 2006 15:04&quot;) // 输出 21 Jul 2011 10:31","link":"/Language/Language-Golang/"},{"title":"Kotlin","text":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 用了Kotlin就不想回到Java，本文主要记录一些高级用法 参考： Android 上的 Kotlin 协程 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 更多细节可查看：基本语法 - Kotlin 语言中文站 (kotlincn.net) 1、基本知识区间 左闭右闭：0..10 左闭右开：0 unitil 10 (step 2) 降序（左闭右闭）：10 downto 1 类主构造函数12345class Examle(...){ init{ ... }} 次构造函数不常用，一般直接指定默认值 1234class Examle(...){ constructor(...) : this(...){} sonstructor() : this (...){}} 修饰符 public：（默认）对所有类可见 private：对当前类内部可见 protected：对当前类和子类可见 internal：对同一模块的类可见 数据类和单例类 数据类：data class，等同于 Java 中一长串的 bean 单例类：object，等同于 Java 中的单例模式（全局至多只有一个实例） Lambda简而言之，就是可以作为参数传递的代码。 太常用也太多了，写写就会了 2、标准函数只介绍最常用的3个 with一个非扩展函数：上下文对象作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（this）使用。 返回值是 lambda 表达式结果。 接收2个参数： 任意类型的对象 Lambda表达式 12345678910val result = with(obj){ // obj 上下文 &quot;value&quot; // with 返回值}val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)with(numbers) { println(&quot;'with' is called with argument $this&quot;) println(&quot;It contains $size elements&quot;)} run上下文对象 作为接收者（this）来访问。 返回值 是 lambda 表达式结果。 run 和 with 做同样的事情，但是调用方式和 let 一样——作为上下文对象的扩展函数. 当 lambda 表达式同时包含对象初始化和返回值的计算时，run 很有用。 12345678910val result = service.run { port = 8080 query(prepareRequest() + &quot; to port $port&quot;)}// 同样的代码如果用 let() 函数来写:val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)} apply上下文对象 作为接收者（this）来访问。 返回值 是上下文对象本身。 对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用 apply。apply 的常见情况是对象配置。这样的调用可以理解为“将以下赋值操作应用于对象”。 12345val adam = Person(&quot;Adam&quot;).apply { age = 32 city = &quot;London&quot; }println(adam) 函数选择为了选择合适的作用域函数，它们之间的主要区别表。 函数 对象引用 返回值 是否是扩展函数 let it Lambda 表达式结果 是 run this Lambda 表达式结果 是 run - Lambda 表达式结果 不是：调用无需上下文对象 with this Lambda 表达式结果 不是：把上下文对象当做参数 apply this 上下文对象 是 also it 上下文对象 是 3、拓展函数和运算符重载拓展函数基本格式： 123fun ClassName.methodName(pararm: Int):Int{ return 0} 例子： 123fun String.showToast(duration: Int = Toast.LENGTH_SHORT) { Toast.makeToast(MyApp.context, this, duration).show()} 运算符重载例子： 12345class Money(val value:Int){ operator fun plus(money:Money):Money{ return Money(value+money.value) }} 4、高阶函数和内联函数高阶函数如果一个函数接收另一个函数作为参数，或者韩非子的类型是另一个函数，则称之为高阶函数。 基本规则：() -&gt; Unit 例子如下，相当于能嵌套函数 123fun CardItem( onClick: () -&gt; Unit = {}) 内联函数高阶函数实现的 Lambda 表达式在底层被转换为匿名类，每次调用都会创建一个新的匿名类实例，造成额外开销 函数前添加inline可消除开销：inline fun example(){} 5、泛型和委托泛型一般编程模式下，需要给任何一个变量指定具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样的代码会有更好的拓展性。 泛型类： 12345678class MyClass&lt;T&gt;{ fun method(param: T): T{ return param }}val myClass = MyClass&lt;Int&gt;() // 指定 Int 泛型val result = myClass.method(123) // 得到 Int 返回值 泛型方法： 1234567891011class MyClass{ fun &lt;T&gt; method(param: T): T{ return param }}val myClass = MyClass()val result = myClass.method&lt;Int&gt;(123)// kotlin 可以自动识别val result = myClass.method(123) 范围： 可通过 &lt;T : Number&gt;的形式指定范围，此时只允许数字类型，字符串会报错 默认类型可空，即Any?，不想为空可改为Any 委托委托是一种设计模式，操作对象自己不会去处理某段逻辑，而是把工作委托给另外一个辅助对象处理。 类委托： 借助委托可以轻松自己实现类，以下通过Hashset自定义一个类：by是实现委托的关键字 1234class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet{ fun helloworld() = println(&quot;hello world&quot;) override fun isEmpty = false} 属性委托： 将一个属性（字段）的具体实现委托给另一个类去完成 1234567891011121314151617181920class MyClass{ val p by Delegate()}// 调用 p 时，自动调用 Delegate类的 getValue 方法，赋值时调用 setValue 方法// 以下是标准的实现class Delegate{ var propValue: Any? = null // 参数1: 指定该类的委托在什么类可以使用 // 参数2: Kotlin属性操作类，可用于获取各种属性相关的值 operator fun getValue(myClass: MyClass, prop: Kproperty&lt;*&gt;): Any?{ return propValue } operator fun setValue(myClass: MyClass, prop: Kproperty&lt;*&gt;, value: Any?): Any?{ propValue = value } } 泛型实化指定泛型的实际类型 inline fun &lt;reified T&gt; start(block: Intent.() -&gt; Unit = {}){} 此时就可以得到T::class.java类型： 1val intent = Intent(context, T::class.java) 泛型协变和逆变 Todo 6、协程可以理解为轻量级的线程，可以在单线程中模拟多线程效果，与线程不同点在于： 线程依靠操作系统调度实现不同线程切换 协程在编程语言层面实现不同协程切换，大大提高并发编程的运行效率 特点：协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的特点包括： 轻量：可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。 内存泄漏更少：使用结构化并发机制在一个作用域内执行多项操作。 内置取消支持：取消操作会自动在运行中的整个协程层次结构内传播。 Jetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。 作用域构建器Tips： delay()：让当前协程延迟指定时间再运行，会阻塞挂起函数，只会挂起当前协程，不会影响其他协程执行 suspend：将任意函数声明为挂起函数，挂起函数间可以互相调用 作用域 GlobalScope.launch{}：顶层协程（不建议用） runBlocking{}：作用域内所有代码和子协程没有全部执行完之前一直阻塞当前线程（测试用，生产可能有性能问题） launch：在作用域内创建多个协程 coroutineScope{}：继承外部协程作用域并创建一个子协程，配合suspend使用，和runBlocking类似，用于生产环境 123suspend fun printDot() = coroutineScope{ launch{}} 常用写法 123456val job = Job()val scope = CoroutineScope(job)scope.launch{ //...}job.cancel() // 取消作用域内所有协程 获取执行结果调用async后，代码立即执行，如果调用await()时还没执行完，则会阻塞当前协程，直到获得async执行结果 12345runBlocking{ val result = async{ 5+5 }.await()} withContext是一个挂起函数，可以理解为async的一种简化版写法： 12345runBlocking{ val result = withContext(Dispatchers.Default){ 5+5 }} 线程参数除了coroutineScope，其他函数都可以指定线程参数，withContext必须，其他可选 Dispatchers.Default：默认低并发线程策略 Dispatchers.IO：较高并发的线程策略 Dispatchers.Main：不会开启子线程，在 Android 主线程执行（只在安卓中使用） Android 中要求网络请求必须在线程执行，定义协程也不行","link":"/Language/Language-Kotlin/"},{"title":"Linux指令——系统管理","text":"Linux中常用的系统工作命令以及系统状态检测命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、常用系统工作命令echo ：在终端输出字符串或变量提取后的值命令描述：echo命令用于在终端输出字符串或变量提取后的值。 命令格式：echo [字符串 | $变量] 命令用法示例： 显示普通字符串 1echo &quot;Hello World&quot; 显示变量首先在shell环境中定义一个临时变量name，使用echo命令将变量name的值显示到终端。 12export name=&quot;Tom&quot;echo $name 显示结果定向至文件以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。 1echo &quot;This is a test text.&quot; &gt; test.txt 如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。 显示命令执行结果以下命令将会在终端显示当前的工作路径。 1echo `pwd` 注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。使用$(command)形式可以达到相同效果。 1echo $(pwd) date ：显示和设置系统的时间和日期命令描述：date命令用于显示和设置系统的时间和日期。 命令格式：date [选项] [+格式] 其中，时间格式的部分控制字符解释如下： 字符说明%a当地时间的星期名缩写（例如： 日，代表星期日）%A当地时间的星期名全称 （例如：星期日）%b当地时间的月名缩写 （例如：一，代表一月）%B当地时间的月名全称 （例如：一月）%c当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）%C世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）%d按月计的日期（例如：01）%D按月计的日期；等于%m/%d/%y%F完整日期格式，等价于 %Y-%m-%d%j按年计的日期（001-366）%p按年计的日期（001-366）%r当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）%R24 小时时间的时和分，等价于 %H:%M%s自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数%T时间，等于%H:%M:%S%U一年中的第几周，以周日为每星期第一天（00-53）%x当地时间下的日期描述 （例如：12/31/99）%X当地时间下的时间描述 （例如：23:13:48）%w一星期中的第几日（0-6），0 代表周一%W一年中的第几周，以周一为每星期第一天（00-53） 命令用法示例： 按照默认格式查看当前系统时间 1date 按照指定格式查看当前系统时间 1date &quot;+%Y-%m-%d %H:%M:%S&quot; 查看今天是当年中的第几天 1date &quot;+%j&quot; 将系统的当前时间设置为2020年02月20日20点20分20秒 1date -s &quot;20200220 20:20:20&quot; 校正系统时间，与网络时间同步a. 安装ntp校时工具 1yum -y install ntp b. 用ntpdate从时间服务器更新时间 1ntpdate time.nist.gov wget ：在终端中下载文件命令描述：在终端中下载文件。 命令格式：wget [参数] 下载地址 参数说明： 参数作用-b后台下载-P下载到指定目录-t最大重试次数-c断点续传-p下载页面内所有资源，包括图片、视频等-r递归下载 命令使用示例： 下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。 1wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png ps ：查看系统中的进程状态命令描述：ps命令用于查看系统中的进程状态。 命令格式：ps [参数] 命令参数说明： 参数作用-a显示现行终端机下的所有程序，包括其他用户的程序-u以用户为主的格式来显示程序状况-x显示没有控制终端的进程，同时显示各个命令的具体路径-e列出程序时，显示每个程序所使用的环境变量-f显示当前所有的进程-t指定终端机编号，并列出属于该终端机的程序的状况 命令使用示例： 1ps -ef | grep sshd top ：动态地监视进程活动与系统负载等信息命令描述：top命令动态地监视进程活动与系统负载等信息。 命令使用示例： 1top 命令输出参数解释： 以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。 统计信息区 第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。 第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。 进程信息区 列名含义PID进程IDUSER进程所有者的用户名PR进程优先级NInice值。负值表示高优先级，正值表示低优先级VIRT进程使用的虚拟内存总量，单位kbRES进程使用的、未被换出的物理内存大小，单位kbSHR共享内存大小，单位kbS进程状态D：不可中断的睡眠状态R：正在运行S：睡眠T：停止Z：僵尸进程%CPU上次更新到现在的CPU时间占用百分比%MEM进程使用的物理内存百分比TIME+进程使用的CPU时间总计，单位1/100秒COMMAND命令名 按 q 键退出监控页面。 pidof ：查询指定服务进程的PID值命令描述：pidof命令用于查询指定服务进程的PID值。 命令格式：pidof [服务名称] 命令参数说明： 参数说明-s仅返回一个进程号-c只显示运行在root目录下的进程，这个选项只对root用户有效-o忽略指定进程号的进程-x显示由脚本开启的进程 命令使用示例： 查询出crond服务下的所有进程ID。 1pidof crond kill ：终止指定PID的服务进程命令描述：kill命令用于终止指定PID的服务进程。 kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。 命令格式：kill [参数] [进程PID] 命令使用示例： 删除pid为1247的进程。 1kill -9 1247 killall ：终止指定名称的服务对应的全部进程命令描述：killall命令用于终止指定名称的服务对应的全部进程。 命令格式：killall [进程名称] 命令使用示例： 删除crond服务下的所有进程。 1killall crond reboot ：重启系统命令描述：reboot命令用来重启系统。 命令格式：reboot [-n] [-w] [-d] [-f] [-i] 命令参数说明： -n：保存数据后再重新启动系统。 -w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。 -d：重新启动时不把数据写入记录文件/var/tmp/wtmp。 -f：强制重新开机，不调用shutdown指令的功能。 -i：关闭网络设置之后再重新启动系统。 命令使用示例： 1reboot poweroff ：关闭系统命令描述：poweroff命令用来关闭系统。 命令使用示例： 1poweroff 2、系统状态检测命令ifconfig ：获取网卡配置与网络状态等信息命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。 命令示例： 命令输出说明： 第一部分的第一行显示网卡状态信息。 eth0表示第一块网卡。 UP代表网卡开启状态。 RUNNING代表网卡的网线被接上。 MULTICAST表示支持组播。 第二行显示网卡的网络信息。 inet（IP地址）：172.16.132.195。 broadcast（广播地址）：172.16.143.255。 netmask（掩码地址）：255.255.240.0。 RX表示接收数据包的情况，TX表示发送数据包的情况。 lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。 uname ：查看系统内核与系统版本等信息命令描述：uname命令用于查看系统内核与系统版本等信息。 命令语法：uname [-amnrsv][--help][--version] 命令使用示例： 显示系统信息。 1uname -a 显示当前系统的硬件架构。 1uname -i 显示操作系统发行编号。 1uname -r 显示操作系统名称。 1uname -s 显示主机名称。 1uname -n uptime ：查看系统的负载信息命令描述：uptime 用于查看系统的负载信息。 命令使用示例：命令输出说明： 负载信息命令输出值当前服务器时间14:20:27当前服务器运行时长2 min当前用户数2 users当前负载情况load average: 0.03, 0.04, 0.02（分别取1min，5min，15min的均值） free ：显示当前系统中内存的使用量信息命令描述：free用于显示当前系统中内存的使用量信息。 命令语法：free [-bkmotV][-s &lt;间隔秒数&gt;] 命令参数说明： 参数说明-b以Byte为单位显示内存使用情况-k以KB为单位显示内存使用情况-m以MB为单位显示内存使用情况-h以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。 命令使用示例：命令输出说明： 参数说明total物理内存总数used已经使用的内存数free空间的内存数share多个进程共享的内存总额buff/cache应用使用内存数available可用的内存数Swap虚拟内存（阿里云ECS服务器默认不开启虚拟内存） who ：显示关于当前在本地系统上的所有用户的信息命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。 命令使用示例： 显示当前登录系统的用户 1who 显示用户登录来源 1who -l -H 只显示当前用户 1who -m -H 精简模式显示 1who -q last ：显示用户最近登录信息命令描述： last 命令用于显示用户最近登录信息。 1last history ：显示历史执行过的命令命令描述：history命令用于显示历史执行过的命令。 bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。 命令使用示例： 显示最新10条执行过的命令。 1history 10 清除历史记录。 1history -c","link":"/Linux/Linux-System-Management/"},{"title":"单调队列","text":"“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 参考： 代码随想录 (programmercarl.com) 1、介绍单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下： 2、实现 保证队列里单调递减或递增的原则，所以叫做单调队列。 以下不是固定写法： 12345678910111213141516171819202122232425262728293031323334type MonotoneQueue struct { queue []int}func Constructor() MonotoneQueue { return MonotoneQueue{ queue: make([]int, 0), }}func (this *MonotoneQueue) Front() int { return this.queue[0]}func (this *MonotoneQueue) Back() int { return this.queue[len(this.queue)-1]}func (this *MonotoneQueue) Empty() bool { return len(this.queue) == 0}func (this *MonotoneQueue) Push(x int) { for !this.Empty() &amp;&amp; x &gt; this.Back() { this.queue = this.queue[:len(this.queue)-1] } this.queue = append(this.queue, x)}func (this *MonotoneQueue) Pop(x int) { if !this.Empty() &amp;&amp; this.Front() == x { this.queue = this.queue[1:] }}","link":"/Data-structure/Monotone-Queue/"},{"title":"内存管理","text":"内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。 虚拟内存是内存管理技术的一个极其实用的创新。 参考：八股文（星球精华汇总）内存管理 - leetcode 1、页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 最佳置换 OPT OPT, Optimal replacement algorithm 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 三个物理块： 7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 开始运行时，先将 7, 0, 1 三个页面装入内存。 当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 先进先出 FIFO FIFO, First In First Out 选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面换出，导致缺页率升高。 最近最久未使用 LRU LRU, Least Recently Used LRU 将最近最久未使用的页面换出。 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 4，7，0，7，1，0，1，2，1，2，6 最近未使用 NRU NRU, Not Recently Used 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。 可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 第二次机会FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改： 当页面被访问 (读或写) 时设置该页面的 R 位为 1。 需要替换的时候，检查最老页面的 R 位： 如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉 如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 时钟 Clock第二次机会算法需要在链表中移动页面，降低了效率。 时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 2、分段虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 如果使用分页系统的⼀维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，⼀个段构成⼀个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 纯分段分段和分页本质上是不同的，页面是定长的而段不是。 优点： 共享：有助于几个进程之间共享过程和数据。 比如共享库 保护：每个段都可以独立地增大或减小而不会影响其他的段 段页式程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。 这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分段与分页的比较 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因： 分页主要用于实现虚拟内存，从而获得更大的地址空间； 分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 3、虚拟内存虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 属于计算机系统内存管理的⼀种技术，虚拟地址空间构成虚拟内存，它使得应用程序认为自己拥有连续的可用内存空间，但实际上是被分隔的多个物理内存页、以及部分暂时存储在磁盘上的交换分区所构成的。 虚拟内存的实现通过硬件异常、硬件地址翻译、主存、磁盘以及内核软件共同完成。 地址空间：是物理内存的抽象，是⼀个进程可用于寻址内存的⼀套地址集合 分页：地址空间被分割成多个块，每⼀块称作⼀页或页面(Page)。每⼀页有连续的地址范围，这些页被映射到连续的物理内存(页框)。 页表：把虚拟页面(虚拟地址)映射为页框(物理地址)。页表给出了虚拟地址与物理地址的映射关系。从数学的角度说页表是⼀个函数，他的参数是虚拟页号，结果是物理页页框号 虚拟内存的思想，整体来看就是： 通过结合磁盘和内存各自的优势，利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统⼀的抽象。 优化加速将虚拟地址直接映射到物理地址，而不必再访问页表，这种设备被称为转换检测缓冲区（TLB）、相联存储器或快表 ⼯作过程：将⼀个虚拟地址放⼊MMU（内存管理单元）中进行转换时，硬件首先通过将该虚拟页号与 TLB 中所有表项同时进行匹配， 判断虚拟页面是否在其中： 虚拟页号在TLB中。如果MMU检测⼀个有效的匹配并且访问操作并不违反保护位，则将页框号直接从 TLB 中取出而不必访问页表。 虚拟页号不在TLB中。如果MMU检测到没有有效的匹配项就会进行正常的页表查询。接着从 TLB 中淘汰⼀个表项，然后用新的页表项替换它。 加大 多级页表 倒排页表 重要能力 高速缓存 内存管理 内存保护：如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。","link":"/Operating-System/Memory-Management/"},{"title":"Linux指令——文本处理","text":"如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文本编辑工具Vimvim的三种操作模式： 命令模式（Command mode） 输入模式（Insert mode） 底线命令模式（Last line mode） 三种模式切换快捷键： 模式 快捷键 命令模式 ESC 输入模式 i或a 底线命令模式 : 命令模式在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。 使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。 以下是在命令模式中常用的快捷操作： 操作快捷键光标左移h光标右移l（小写L）光标上移k光标下移j光标移动到下一个单词w光标移动到上一个单词b移动游标到第n行nG移动游标到第一行gg移动游标到最后一行G快速回到上一次光标所在位置Ctrl+o删除当前字符x删除前一个字符X删除整行dd删除一个单词dw或daw删除至行尾d$或D删除至行首d^删除到文档末尾dG删除至文档首部d1G删除n行ndd删除n个连续字符nx将光标所在位置字母变成大写或小写~复制游标所在的整行yy（3yy表示复制3行）粘贴至光标后（下）p粘贴至光标前（上）P剪切dd交换上下行ddp替换整行，即删除游标所在行并进入插入模式cc撤销一次或n次操作u{n}撤销当前行的所有修改U恢复撤销操作Ctrl+r整行将向右缩进&gt;&gt;整行将向左退回&lt;&lt;若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开ZZ 输入模式在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。 底线命令模式在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。 以下是底线命令模式中常用的快捷操作： 操作命令保存:w退出:q保存并退出:wq（:wq!表示强制保存退出）将文件另存为其他文件名:w new_filename显示行号:set nu取消行号:set nonu使本行内容居中:ce使本行文本靠右:ri使本行内容靠左:le向光标之下寻找一个名称为word的字符串:/word向光标之上寻找一个字符串名称为word的字符串:?word重复前一个搜寻的动作:n从第一行到最后一行寻找word1字符串，并将该字符串取代为word2:1,$s/word1/word2/g 或 &nbsp;:%s/word1/word2/g 2、文本文件查看命令cat ：查看内容较少的纯文本文件命令描述：cat命令用于查看内容较少的纯文本文件。 命令格式：cat [选项] [文件] 命令参数说明： 参数说明-n或--number显示行号-b或--number-nonblank显示行号，但是不对空白行进行编号-s或--squeeze-blank当遇到有连续两行以上的空白行，只显示一行的空白行 more ：从前向后分页显示文件内容命令描述：more命令从前向后分页显示文件内容。 常用操作命令： 操作作用Enter向下n行，n需要定义，默认为1行Ctrl+F或空格键（Space）向下滚动一页Ctrl+B向上滚动一页=输出当前行的行号!命令调用Shell执行命令q退出more less ：对文件或其它输出进行分页显示命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。 命令格式：less [参数] 文件 命令参数说明： 参数说明-e当文件显示结束后，自动离开-m显示类似more命令的百分比-N显示每行的行号-s显示连续空行为一行 命令常用操作： 快捷键说明/字符串向下搜索字符串?字符串向上搜索字符串n重复前一个搜索N反向重复前一个搜索b或pageup键向上翻一页空格键或pagedown键向下翻一页u向前翻半页d向后翻半页y向前滚动一行回车键向后滚动一行q退出less命令 命令使用示例： 查看命令历史使用记录并通过less分页显示。 1history | less head ：查看文件开头指定行数的内容命令描述：head命令用于查看文件开头指定行数的内容。 命令格式：head [参数] [文件] 命令参数说明： 参数说明-n [行数]显示开头指定行的文件内容，默认为10-c [字符数]显示开头指定个数的字符数-q不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名 命令使用示例： 查看/etc/passwd文件的前5行内容。 1head -5 /etc/passwd tail ：查看文档的后N行或持续刷新内容命令描述：tail命令用于查看文档的后N行或持续刷新内容。 命令格式：tail [参数] [文件] 命令参数说明： 参数说明-f显示文件最新追加的内容-q当有多个文件参数时，不输出各个文件名-v当有多个文件参数时，总是输出各个文件名-c [字节数]显示文件的尾部n个字节内容-n [行数]显示文件的尾部n行内容 命令使用示例： 查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。 1tail -f -n 10 /var/log/messages stat ：显示文件的详细信息命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。 命令使用示例： 查看/etc/passwd文件的详细信息。 1stat /etc/passwd wc ：统计指定文本的行数、字数、字节数命令描述：wc命令用于统计指定文本的行数、字数、字节数。 命令格式：wc [参数] [文件] 命令参数说明： 参数说明-l只显示行数-w只显示单词数-c只显示字节数 命令使用示例： 统计/etc/passwd文件的行数。 1wc -l /etc/passwd file ：辨识文件类型命令描述： file命令用于辨识文件类型。 命令格式：file [参数] [文件] 命令参数说明： 参数说明-b列出辨识结果时，不显示文件名称-c详细显示指令执行过程，便于排错或分析程序执行的情形-f [文件]指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称-L直接显示符号连接所指向的文件类别 命令使用示例： 查看/var/log/messages文件的文件类型。 1file /var/log/messages diff ：比较文件的差异命令描述：diff命令用于比较文件的差异。 命令格式：diff [文件] [文件] 3、文本处理命令grep ：查找文件里符合条件的字符串命令描述：grep命令用于查找文件里符合条件的字符串。 grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。 在Shell脚本中，grep通过返回一个状态值来表示搜索的状态： 0：匹配成功。 1：匹配失败。 2：搜索的文件不存在。 命令格式：grep [参数] [正则表达式] [文件] 命令常用参数说明： 参数说明-c或--count计算符合样式的列数-d recurse或-r指定要查找的是目录而非文件-e [范本样式]指定字符串做为查找文件内容的样式-E 或 --extended-regexp将样式为延伸的正则表达式来使用-F 或 --fixed-regexp将样式视为固定字符串的列表-G 或 --basic-regexp将样式视为普通的表示法来使用-i 或 --ignore-case忽略字符大小写的差别-n 或 --line-number在显示符合样式的那一行之前，标示出该行的列数编号-v 或 --revert-match显示不包含匹配文本的所有行 命令使用示例： 查看sshd服务配置文件中监听端口配置所在行编号。 1grep -n Port /etc/ssh/ssh_config 查询字符串在文本中出现的行数。 1grep -c localhost /etc/hosts 反向查找，不显示符合条件的行。 12ps -ef | grep sshdps -ef | grep -v grep | grep sshd 以递归的方式查找目录下含有关键字的文件。 1grep -r *.sh /etc 使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。 1grep 'ntp[0-9].aliyun.com' /etc/ntp.conf sed ：文本处理命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。 处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。 接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。 接着处理下一行，这样不断重复，直到文件末尾。 注意： sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。如果要改变源文件，需要使用-i选项。命令格式：sed [参数] [动作] [文件] 参数说明： 参数说明-e [script]执行多个script-f [script文件]执行指定script文件-n仅显示script处理后的结果-i输出到原文件，静默执行（修改原文件） 动作说明： 动作说明a在行后面增加内容c替换行d删除行i在行前面插入p打印相关的行s替换内容 命令使用示例： 删除第3行到最后一行内容。 1sed '3,$d' /etc/passwd 在最后一行新增行。 1sed '$a admin:x:1000:1000:admin:/home/admin:/bin/bash' /etc/passwd 替换内容。 1sed 's/SELINUX=disabled/SELINUX=enforcing/' /etc/selinux/config 替换行。 1sed '1c abcdefg' /etc/passwd awk ：文本处理命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。 命令格式：awk [参数] [脚本] [文件] 参数说明： 参数说明-F fs指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符-f file读取awk脚本-v val=val在执行处理过程之前，设置一个变量var，并给其设置初始值为val 内置变量： 变量用途FS字段分隔符$n指定分隔的第n个字段，如$1、$3分别表示第1、第三列$0当前读入的整行文本内容NF记录当前处理行的字段个数（列数）NR记录当前已读入的行数FNR当前行在源文件中的行号 awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。 和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。 命令使用示例： 查看本机IP地址。 1ifconfig eth0 |awk '/inet/{print $2}' 查看本机剩余磁盘容量。 1df -h |awk '/\\/$/{print $4}' 统计系统用户个数。 1awk -F: '$3&lt;1000{x++} END{print x}' /etc/passwd 输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。 1awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd 输出/etc/passwd文件中前三行记录的用户名和用户uid。 1head -3 /etc/passwd | awk 'BEGIN{FS=&quot;:&quot;;print &quot;name\\tuid&quot;}{print $1,&quot;\\t&quot;$3}END{print &quot;sum lines &quot;NR}' 查看tcp连接数。 1netstat -na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 关闭指定服务的所有的进程。 1ps -ef | grep httpd | awk {'print $2'} | xargs kill -9 cut ：切割字符串命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。 命令格式：cut [参数] [文件] 参数说明： 参数说明-b以字节为单位进行分割-c以字符为单位进行分割-d自定义分隔符，默认为制表符 tr ：对来自标准输入的字符进行替换、压缩和删除命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。 命令格式：tr [参数] [文本] 参数说明： 参数说明-c反选指定字符-d删除指定字符-s将重复的字符缩减成一个字符-t [第一字符集] [第二字符集]删除第一字符集较第二字符集多出的字符，使两个字符集长度相等 命令使用示例： 将输入字符由大写转换为小写。 1echo &quot;HELLO WORLD&quot; | tr 'A-Z' 'a-z' 删除字符。 1echo &quot;hello 123 world 456&quot; | tr -d '0-9' 压缩字符。 1echo &quot;thissss is a text linnnnnnne.&quot; | tr -s ' sn' 产生随机密码。 1cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13","link":"/Linux/Linux-Text-Processing/"},{"title":"开源安卓应用推荐","text":"推荐一些开源的安卓应用，可以在 F-Droid或 GitHub 下载，主要是一些软件的第三方。 F-Droid 第三方Aurora DroidAurora Droid Aurora 家族成员，界面仿 PlayStroe 风格，不过上次更新已经是3月了，个人体验下来有点卡顿的感觉，没有中文。 推荐指数：⭐⭐⭐ Droid-ifyDroid-ify FoxyDroid 的 Fork，Matrial you风格，更新勤快，界面简洁且好看，内置了不少仓库，支持中文。 推荐指数：⭐⭐⭐⭐⭐ Play Stroe 第三方Aurora StoreAurora Store Auroara 家族成员，美观且支持匿名登录和选区。 推荐指数：⭐⭐⭐⭐⭐","link":"/Share/Open-Source-Apk-Share/"},{"title":"计算机网络模型与协议","text":"计算机网络主要有3种模型： ISO/OSI参考模型 7层 TCP/IP参考模型 5层 TCP/IP参考模型 4层 OSI是一种理论下的模型，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。 参考：力扣王道考研 1、参考模型OSI 七层模型OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。 应用层：用户与网络的界面，通过应用程序间的交互来完成特定的网络应用 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元为报文。 表示层：使通信的应用程序能够解释交换数据的含义 数据格式变换 翻译官 数据描述 数据加密解密 数据加密 数据压缩和恢复 数据压缩 这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。 会话层：负责建立、管理和终止表示层实体之间的通信会话。 该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法（类似断点续传）。 传输层：负责主机中两个进程的通信，即端到端通信。传输单位是报文段或用户数据报 可 靠传输、不可靠传输 差 错控制 流 量控制 复 用分用（记忆：可差的也能流用？） 复用：多个应用层进程可同时使用下面传输层的服务 分用：传输层把收到的信息分别交付给上面应用层相应的进程 网络层：选择合适的网间路由和交换节点，确保数据按时成功传送。传输单位是数据报 路由选择与分组转发 最佳路径 在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。 流量控制 发送速度 差错控制 拥塞控制 总体速度 数据链路层：把网络层传下来的数据报组装成帧。传输单位是帧 成帧（定义帧的开始和结束） 差错控制 帧错+位错 流量控制 访问（接入）控制 控制对信道的访问 物理层：在物理媒体上实现比特流的透明传输。传输单位是比特 尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么 定义接口特性（机械特性、电气特性、功能特性，过程特性） 定义传输模式 （单工、半双工、双工） 定义传输速率 比特同步 比特编码 TCP/IP 四层模型 由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。三层都在应用程序内实现，程序间无法共享，合三为一就形成了 TCP/IP 模型。 应用层 TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。 例如：FTP、Telnet、DNS、SMTP 等。 传输层 该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。 传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。 其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。 网际互联层 网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。 在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。 根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。 除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 网络接口层 网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。 事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。 TCP/IP 五层模型五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。 五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。 2、模型异同相同点 OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。 都能够提供面向连接和无连接两种通信服务机制。 不同点 OSI 采用的七层模型； TCP/IP 是四层结构。 TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。 OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。 TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。 OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。 3、各层协议 OSI 七层网络模型 TCP/IP 四层概念模型 对应的网络协议 应用层（Application） 应用层 HTTP, FTP, DNS, SMTP,TFTP,NFS, WAIS, Telnet, SNMP 表示层（Presentation） TIFF, GIF, JPEG, PICT 会话层（Session） RPC, SQL, NFS, NetBIOS, names, AppleTalk 传输层（Transport） 传输层 TCP, UDP 网络层（Network） 网际层 IP, ICMP, ARP, RARP, RIP, IPX 数据链路层（Data Link） 网络接口层 FDDI, Frame Relay, HDLC, SLIP, PPP 物理层（Physical） EIA/TIA-232, EIA/TIA-499, V.35, 802.3","link":"/Computer-network/Models-And-Protocols/"},{"title":"网络层","text":"网络层（Network Layer）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。 网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。 功能： 路由选择与分组转发 最佳路径 异构网络互联 拥塞控制 网络层重要协议： IP（Internet Protocol）网际互连协议 与 IP 协议配套使用的还有三个协议： ARP（Address Resolution Protocol）地址解析协议 ICMP（Internet Control Message Protocol）网际控制报文协议 IGMP（Internet Group Management Protocol）网际组管理协议 参考：力扣王道考研 1、IP该协议工作在网络层，主要目的就是为了提高网络的可扩展性。 和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP 协议族的核心。 IP 协议主要有以下几个作用： 寻址和路由：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。 分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。 数据报总长度单位1B，片位移单位8B，首部单位4B 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 分片 IPV4IP地址分类IP地址由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 以上分类还空出一些地址，这些特殊的地址包括： 另外还有私有地址（局域网）： 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 子网掩码：主机位全0，其他全1（网络位、子网位） NAT 网络地址转换NAT（Network Address Translation)，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。 该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。 在专用网连接到因特网（公用地址）的路由器上安装NAT软件（NAT路由器），它至少有一个有效的外部全球IP地址 NAT路由器根据转换表替换源IP地址或者目的IP地址和端口号，所以转发数据报时需查看和转换传输层的端口号 普通路由器仅工作在网络层，不改变源IP和目的IP NAT 的实现有三种方式： 静态转换，一对一，一个私有对应一个公有 动态转换，一对多，一个私有每次转换的公有不唯一 端口多路复用，多对一，多个私有共享一个合法的外部IP，映射到了不同的端口上 CIDR 无分类域间路由选择CIDR（Classless Inter-Domain Routing） 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} IPV6从根本上解决 IPV4 地址不够的问题。 其他方法：NAT：网络地址转换DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址（DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP） IPV6 将地址从32位（4B）扩大到了128位（64B） 2、ARPARP（Address Resolution Protocol）地址解析协议，完成IP地址到MAC地址的映射（解决下一跳走哪的问题） 使用过程 检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网内所有主机都能受到该请求 目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次） 典型情况 主机A发给本网络上的主机B：用ARP找到B的硬件地址 主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址 路由器发给本网络的主机B：用ARP找到B的硬件地址 路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址 3、ICMPICMP（Internet Control Message Protocol）是网际控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。 功能 验证网络是否畅通（确认接收方是否成功接收到 IP 数据包） 辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理） 应用 Ping：测试两个主机间的连通性，使用 ICMP 会送请求和回答报文 TraceRoute：跟踪一个分组从源点到终点的路径，使用 ICMP 时间超过差错报告报文 ping 不通可能存在的问题： 首先看网络是否连接正常，检查网卡驱动是否正确安装 局域网设置问题，检查 IP 地址是否设置正确 看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 看是否被第三方软件拦截 两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到 4、IGMPIGMP（Internet Group Management Protocol）网际组管理协议，让路由器知道局域网上是否有主机（的进程）参加或退出某个组播组。 5、路由器路由器是网络层设备，通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。 路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。 交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。 分组转发流程 从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络 判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 3 检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4 逐条检查路由表，使用每一行的子网掩码与目的IP匹配。若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5 若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6 无法找到合适路由，向源主机报错 路由协议 RIP（Routing Information Protocol）路由信息协议 OSPF（Open Shortest Path First）开放式最短路径优先 BGP（Border Gateway Protocol）边界网关协议","link":"/Computer-network/Network-Layer/"},{"title":"主流开源协议","text":"常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类： 宽松自由软件许可协议 Permissive free software licence 著佐权许可证 copyleft license 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 参考： 主流开源协议之间有何异同？ - 知乎 (zhihu.com) 如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com) 1、区别 Permissive free software licence ： 一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。 Copyleft License ： 在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。 两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 2、常见开源许可证 MITMIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。 BSDBerkeley Software Distribution license BSD 许可证与 MIT 差不多。 事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。 可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。 ApacheApache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。 Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。 Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。 GPLGPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。 由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。 LGPL更宽松的GPL协议。 与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。 调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。","link":"/Mixed/Open-Source-License/"},{"title":"物理层","text":"物理层（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 物理层主要任务：确定与传输媒体接口有关的一些特性 四大特性： 机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制 功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途 规程特性：定义各条物理线路的工作规程和时序关系 物理层设备：中继器 1、通信方式主要考虑： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 2、数据交换方式 电路交换 报文交换 分组交换 3、传输介质导向性传输介质 双绞线 同轴电缆 光纤 非导向性传输介质 无线电波 微波 红外线、激光","link":"/Computer-network/Physical-Layer/"},{"title":"Go 优先队列","text":"论如何在 Go 语言中使用优先队列。 参考： Go标准库中文文档 (cngolib.com) 1、介绍Go 提供了 container/heap 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 index = 0 的值是最小的，即最小堆。 堆也是实现优先队列 Priority Queue 的常用方式。 堆中元素的类型需要实现 heap.Interface 这个接口： 12345type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1.} 其中 sort.Interface 包括 Len(), Less, Swap 方法。 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041type IntHeap [][2]int // 0 key 1 valuefunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i][1] &lt; h[j][1] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.([2]int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 347. 前 K 个高频元素// https://leetcode-cn.com/problems/top-k-frequent-elements/func topKFrequent(nums []int, k int) []int { m := make(map[int]int) ans := make([]int, k) h := &amp;IntHeap{} heap.Init(h) for _, v := range nums { m[v]++ } for key, value := range m { heap.Push(h, [2]int{key, value}) if h.Len() &gt; k { heap.Pop(h) } } for k &gt; 0 { k-- ans[k] = heap.Pop(h).([2]int)[0] } return ans}","link":"/Data-structure/Priority-Queue/"},{"title":"进程管理","text":"线程是最小的执行单元，而进程由至少一个线程组成。 如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。 多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。 参考：八股文（星球精华汇总）进程与线程 - 力扣（LeetCode） 1、进程概念进程我们编译的代码可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU执行内存中指令，这个运行的程序被称为进程。 进程是对运行时程序的封装，操作系统进行资源调度和分配的基本单位。 如果包含线程的话，进程是资源分配的基本单位，线程是独立调度的基本单位。 线程 线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程⼀样，都是clone 从内核⾥看进程和线程是⼀样的，都有各自不同的PCB 进程可以蜕变成线程 在linux下，线程最是小的执⾏单位；进程是最小的分配资源单位 进程与线程的区别： Ⅰ拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 进程控制块为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。 每个进程占有⼀个进程表项(进程控制块)。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 该表项是进程存在的唯⼀标识，其包括以下信息： 进程描述信息： 进程标识符、用户标识符等 进程控制和管理信息： 进程状态，进程优先级等 进程资源分配清单： 虚拟内存地址空间信息，打开文件列表，IO设备信息等 CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续执行 PCB通过链表形式组织起来，比如有就绪队列、阻塞队列等，方便增删，方便进程管理。 并发与并行 单个核心在很短时间内分别执行多个进程，称为并发（同一时间段） 多个核⼼同时执行多个进程称为并行（同一时刻） 对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息 进程状态除了创建和结束⼀般有三个状态： 运行态： 该时刻进程占用CPU 就绪态： 可运行，由于其他进程处于运行状态而暂时停止运行 等待被调度 阻塞态： 该进程正在等待某⼀事件发生（如等待输⼊/输出操作的完成）而暂时停止运行 等待资源 阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换⼊到物理内存。 挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态 阻塞挂起状态： 进程在外存（硬盘）并等待某个事件的出现 就绪挂起状态： 进程在外存（硬盘），但只要进⼊内存，马上运行 注意： 只有就绪态和运行态可以相互转换，其它的都是单向转换。 就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态 运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 守护进程守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。 它是⼀个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件 ⼀般采用以d结尾的名字 所有的服务存在于 etc/init.d 守护进程是个特殊的孤儿进程 之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示 Linux 的⼤多数服务器就是用守护进程实现的 僵尸进程多进程程序，父进程⼀般需要跟踪子进程的退出状态，当子进程退出，父进程在运行，子进程必须等到父进程捕获到了子进程的退出状态才真正结束。在子进程结束后，父进程读取状态前，此时子进程为僵尸进程。 设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。 但是子进程停止在僵尸态会占据内核资源，所以需要避免僵尸进程的产生或立即结束子进程的僵尸态。 多进程进程结构由以下几个部分组成：代码段、堆栈段、数据段。 代码段是静态的⼆进制代码，多个程序可以共享。 父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎⼀样。 父、子进程共享全部数据，子进程在写数据时会使用写时复制技术将公共的数据重新拷贝⼀份，之后在拷贝出的数 据上进行操作；不是对同⼀块数据进行操作；如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。 2、进程调度不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 先来先服务 first-come first-serverd（FCFS）非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 短作业优先 shortest job first（SJF）非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 最短剩余时间优先 shortest remaining time next（SRTN）最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 交互式系统交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系，因为进程切换都要保存进程的信息并且载入新进程的信息 如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 优先级调度为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同， 例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 实时系统实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 3、进程通信进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。 同一主机 无名管道 ：半双工（单方向交替传输）、只能在父子进程或者兄弟进程中使用 有名管道：（FIFO）去除了管道只能在父子进程中使用的限制。 信号：信号是软件中断，它是在软件层次上对中断机制的⼀种模拟，是⼀种异步通信的方式 消息队列：A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。 相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 共享存储：存储映射I/O (Memory-mapped I/O) 使⼀个磁盘⽂件与存储空间中的⼀个缓冲区相映射。 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，可以直接读写内存，所以这是最快的一种 IPC 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 信号量：它是一个计数器，用于为多个进程提供对共享数据对象的访问。 不同主机 Socket 套接字 4、进程同步临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 同步与互斥 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 互斥锁 Mutex也叫互斥量，互斥锁是⼀种简单的加锁的⽅法来控制对共享资源的访问，互斥锁只有两种状态，即加锁( lock )和解锁 ( unlock ) 在访问共享资源后临界区域前，对互斥锁进行加锁 在访问完成后释放互斥锁导上的锁 对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放 互斥锁的数据类型是： pthread_mutex_t 12345678910#include &lt;pthread.h&gt;// 创建互斥锁int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);// 销毁互斥锁int pthread_mutex_destroy(pthread_mutex_t *mutex);// 上锁int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);// 解锁int pthread_mutex_unlock(pthread_mutex_t *mutex); 死锁 DeadLock如果⼀个进程集合中的每⼀个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁 必要条件死锁产生必须同时满足四个条件，只要其中任意一条不成立，死锁就不会发生。 互斥条件 进程要求对所分配的资源（比如打印机）进行排他性控制，即在一段时间内某资源只能由一个进程占有。 此时若有其他进程请求该资源，则请求进程只能等待。 不可剥夺条件 进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。 请求并保持条件 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 循环等待条件 存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁检测与死锁恢复每种类型⼀个资源的死锁检测： 通过检测有向图中是否存在环来实现，从⼀个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁发生。 每种类型多个资源的死锁检测： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 从死锁中恢复： 利用抢占恢复：将进程挂起，强行取走资源给另⼀个进程使用，用完再放回 利用回滚恢复：复位到更早的状态，那时它还没有取得所需的资源 通过杀死进程恢复：杀掉环中的⼀个进程或多个，牺牲掉⼀个环外进程 死锁预防在程序运行之前预防发生死锁，其实就是破坏死锁产生的必要条件，破坏任何一个，死锁都不会发生。 破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 破坏请求和保持条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 破坏不可剥夺条件：保证每⼀个进程在任何时刻只能占用⼀个资源，如果请求另⼀个资源必须先释放第⼀个资源。 破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免 安全状态：如果没有死锁发⽣，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每⼀个进程运行完毕 单个资源的银行家算法：一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 多个资源的银行家算法：如果一个状态不是安全的，需要拒绝进入这个状态。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 读写锁在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应⽤。 为了满⾜当前能够允许多个读出，但只允许⼀个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作 如果有其它线程写数据，则其它线程都不允许读、写操作 POSIX 定义的读写锁的数据类型是： pthread_rwlock_t 12345678910111213#include &lt;pthread.h&gt;// 创建读写锁int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);// 销毁读写锁int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);// 读锁定int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);// 写锁定int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);// 解锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 条件变量与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。 条件变量用来自动阻塞⼀个线程，直到某特殊情况发生为止。 通常条件变量和互斥锁同时使用。相较于mutex而言，条件变量可以减少竞争。 条件变量的两个动作： 条件不满, 阻塞线程 当条件满足 通知阻塞的线程开始工作 123456789101112#include &lt;pthread.h&gt;// 创建条件变量int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);// 删除条件变量int pthread_cond_destroy(pthread_cond_t *cond);// 唤醒线程int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond);// 阻塞线程int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex,const struct *restrict abstime); 信号量信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() { down(&amp;mutex); // 临界区 up(&amp;mutex);}void P2() { down(&amp;mutex); // 临界区 up(&amp;mutex);} 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 管程引入了条件变量以及相关的操作： wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。 signal() 操作用于唤醒被阻塞的进程。","link":"/Operating-System/Process-And-Thread/"},{"title":"Redis","text":"Redis (Remote Dictionary Server ) 远程字典服务，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。 Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。 和Memcached类似，它支持存储的value类型相对更多，包括： string（字符串） list（链表） set（集合） zset（sorted set 有序集合） hash（哈希类型） 与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。 参考：Redis 教程_w3cschoolRedis使用教程 - 掘金 1、简介Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 优势 性能极高 Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis 与其他 key-value 存储的区别 Redis 运行在内存中但是可以 持久化到磁盘，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。 Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。 Redis 和 MongoDB 的区别更多可见：NoSQL，浅谈redis与mongoDB的区别 - 知乎 性能方面，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB； 可操作性上，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 丰富的查询语言，操作比 Redis 更为便利； 内存及存储方面，MongoDB 适合 大数据量存储，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 虚拟内存特性，突破物理内存限制，数据可以设置时效性； 对于数据持久化和数据恢复，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能； 在数据一致性上，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行； 数据分析上，MongoDB 内置 数据分析功能（mapreduce），而 Redis 不支持数据分析； 应用场景不同，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。 数据类型Redis支持五种数据类型： string（字符串） hash（哈希） list（列表） set（集合） zset(sorted set：有序集合) string最基本的类型，一个key对应一个value。string类型是二进制安全的，即redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 一个键最大能存储512MB。 1234redis 127.0.0.1:6379&gt; set name &quot;sukiu.top&quot;OKredis 127.0.0.1:6379&gt; get name&quot;sukiu.top&quot; Redis 字符串(String)_w3cschool hashRedis hash 是一个键值 (key=&gt;value) 对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个 hash 可以存储 232 - 1键值对（40多亿）。 12345678910111213redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200OKredis 127.0.0.1:6379&gt; hgetall user:11) &quot;username&quot;2) &quot;sukiu.top&quot;3) &quot;password&quot;4) &quot;sukiu.top&quot;5) &quot;points&quot;6) &quot;200&quot;redis 127.0.0.1:6379&gt; hkeys user:11) &quot;username&quot;2) &quot;password&quot;3) &quot;points&quot; Redis 哈希(Hash)_w3cschool listRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 12345678910127.0.0.1:6379&gt; lpush test redis(integer) 1127.0.0.1:6379&gt; lpush test mongodb(integer) 2127.0.0.1:6379&gt; lpush test rabitmq(integer) 3127.0.0.1:6379&gt; lrange test 0 101) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis 列表(List)_w3cschool setRedis 的 Set是 string 类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112127.0.0.1:6379&gt; sadd t1 redis(integer) 1127.0.0.1:6379&gt; sadd t1 mongodb(integer) 1127.0.0.1:6379&gt; sadd t1 rabitmq(integer) 1127.0.0.1:6379&gt; sadd t1 rabitmq(integer) 0127.0.0.1:6379&gt; smembers t11) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis 集合(Set)_w3cschool zset和 set 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 zset 的成员是唯一的,但分数(score)却可以重复。 123456789101112127.0.0.1:6379&gt; zadd t2 0 redis(integer) 1127.0.0.1:6379&gt; zadd t2 0 mongodb(integer) 1127.0.0.1:6379&gt; zadd t2 0 rabitmq(integer) 1127.0.0.1:6379&gt; zadd t2 0 rabitmq(integer) 0127.0.0.1:6379&gt; zrangebyscore t2 0 10001) &quot;mongodb&quot;2) &quot;rabitmq&quot;3) &quot;redis&quot; Redis 有序集合(sorted set)_w3cschool 2、高级持久化 更多：Redis专题：万字长文详解持久化原理 - SegmentFault 思否 Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。Redis支持两种方式的持久化：RDB快照和AOF。 RDBRDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。到目前为止，仍是官方的默认支持方案。 原理： Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。 优点: 适合大规模的数据恢复 对数据的完整性要不高 缺点： 需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了 fork进程的时候，会占用一定的内容空间 AOFAOF（Append Only File），它是Redis的完全持久化策略。 原理： 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。 123456# no-关闭，yes-开启，默认noappendonly yesappendfilename &quot;appendonTy.aof&quot; #持久化的文件的名字# appendfsync always #每次修改都会sync,消耗性能 appendfsync everysec #每秒执行一次sync,可能会丢失这1s的数据# appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快! 优点： 每一次修改都同步，文件的完整会更加好 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点： 相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢 Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 主从复制主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。 前者称为主节点(master/leader) 后者称为从节点(slavel/follower) 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。 默认情况下，每台Redis服务器都是主节点一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点 主从复制的作用主要包括: 数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 集群模式 更多：redis系列之——高可用（主从、哨兵、集群） 主从原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。 哨兵主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 自动选取老大的模式 集群Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。","link":"/Database/Redis/"},{"title":"队列 Queue","text":"与栈类似，队列是一种先进先出的容器适配器。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 1、定义 在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。 2、实现为了实现队列，我们可以使用动态数组和指向队列头部的索引。 简单的参考实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;class MyQueue { private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() {p_start = 0;} /** Insert an element into the queue. Return true if the operation is successful. */ bool enQueue(int x) { data.push_back(x); return true; } /** Delete an element from the queue. Return true if the operation is successful. */ bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; /** Get the front item from the queue. */ int Front() { return data[p_start]; }; /** Checks whether the queue is empty or not. */ bool isEmpty() { return p_start &gt;= data.size(); }};int main() { MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; }} 缺点上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。 所以应该规定数组的长度，一组一组队列的进行使用。","link":"/Data-structure/Queue/"},{"title":"Shell","text":"Shell 脚本的一些注意点 文件测试1234567if [ -e file/dir ] # 如果文件/目录存在 if [ -f file ] # 如果文件存在 if [ -d dir ] # 如果目录存在 if [ -s file ] # 如果文件存在且非空 if [ -r file ] # 如果文件存在且可读 if [ -w file ] # 如果文件存在且可写 if [ -x file ] # 如果文件存在且可执行 整数比较123456if [ int1 -eq int2 ] # 如果 == if [ int1 -ne int2 ] # 如果 != if [ int1 -ge int2 ] # 如果 &gt;= if [ int1 -gt int2 ] # 如果 &gt; if [ int1 -le int2 ] # 如果 &lt;= if [ int1 -lt int2 ] # 如果 &lt; 字符串比较1234if [ $string1 == $string2 ] # 如果 == (字符串允许使用赋值号做等号) if [ $string1 != $string2 ] # 如果 != if [ -n $string ] # 如果string 长度非0 if [ -z $string ] # 如果string 长度为0","link":"/Language/Shell/"},{"title":"栈 Stack","text":"栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。 STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 代码随想录 (programmercarl.com) 1、介绍在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。 与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。 2、实现从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 动态数组实现参考： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack { private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) { data.push_back(x); } /** Checks whether the queue is empty or not. */ bool isEmpty() { return data.empty(); } /** Get the top item from the queue. */ int top() { return data.back(); } /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; }};int main() { MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) { if (!s.isEmpty()) { cout &lt;&lt; s.top() &lt;&lt; endl; } cout &lt;&lt; (s.pop() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl; }}","link":"/Data-structure/Stack/"},{"title":"SQL","text":"SQL 语句可分为以下几类： 数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 CREATE，DROP，ALTER 数据查询语言 DQL（Data Query Language）：即查询操作，以 SELECT 关键字为主 数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 INSERT，UPDATE，DELETE 数据控制功能 DCL（Data Control Language）：即权限控制操作，如 GRANT，REVOKE，COMMIT，ROLLBACK 参考：常用 SQL 语句 - LeetCodeSQL约束 - 掘金 1、键 超键：在关系中，能唯一标识元组的属性集称为关系模式的超键。 一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。 外键：在一个表中存在的另一个表的主键称此表的外键。 外键可以有重复的, 可以是空值。 2、约束约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束： 非空约束（NOT NULL）：保证该字段值一定不为空； 默认约束（DEFAULT）：保证字段有默认值； 主键约束（PRIMARY KEY）：标志一列或者多列，并保证其值在表内的唯一性； 外键约束（FOREIGN KEY）：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值； 唯一约束（UNIQUE）： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）； 检查约束（CHECK）：限制一列的可用值范围。 创建约束 创建表时，在字段描述处，声明指定字段为主键： 1234CREATE TABLE persons ( pid int primary key, -- 添加了主键约束...); 创建表时，在constraint约束区域，声明指定字段为主键： 12345678CREATE TABLE persons ( pid INT, lastname VARCHAR(255), firstname VARCHAR(255), address VARCHAR(255), CONSTRAINT pk_persons PRIMARY KEY (lastname, firstname) -- 添加主键约束, 多个字段, 我们称为联合主键。);-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。 创建表之后，通过修改表结构，声明指定字段为主键： 123-- 添加联合主键约束-- 其他约束类似alter table persons add constraint pk_persons primary key (lastname, firstname); 删除约束123456789101112131415-- 删除主键约束-- ALTER TABLE 表名 DROP PRIMARY KEYalter table persons drop primary key; -- 删除非空约束-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]alter table persons modify lastname varchar(255);-- 删除唯一约束-- ALTER TABLE 表名 DROP INDEX 名称-- 有唯一约束名称, 使用约束名称删除alter table persons drop index uni_persons_address; -- 没有唯一约束名称, 使用字段名删除alter table persons drop index address; 3、SQL语句参考w3cschool即可： 详尽的SQL语句大全分类整理_w3cschool 下面列出一些重点： 关联查询在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。 交叉连接（CROSS JOIN） 除了在 FROM 子句中使用 逗号间隔连接的表 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数 乘以 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 CROSS JOIN 关键字而不是逗号，即以下两个表达式等价： SELECT * FROM A, B SELECT * FROM A CROSS JOIN B 内连接（INNER JOIN） 内连接分为三类，分别是 等值连接：ON A.id = B.id、不等值连接：ON A.id &gt; B.id 和 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid 外连接（LEFT JOIN/RIGHT JOIN） 左外连接：以左表为主，先查询出左表，按照 ON 后的关联条件匹配右表，没有匹配到的用 NULL 填充，可以简写成 LEFT JOIN 右外连接：以右表为主，先查询出右表，按照 ON 后的关联条件匹配左表，没有匹配到的用 NULL 填充，可以简写成 RIGHT JOIN 联合查询（UNION 与 UNION ALL） SELECT * FROM A UNION SELECT * FROM B UNION ... 联合查询就是把多个结果集集中在一起，UNION 前的结果为基准，需要注意的是联合查询的 列数要相等，相同的记录行会合并； 如果使用 UNION ALL，不会合并重复的记录行，所以效率更高。 全连接（FULL JOIN） MySQL 本身不支持全连接，但可以通过联合使用 LEFT JOIN、UNION 和 RIGHT JOIN 来实现。 SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id 子查询多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。 子查询是一个 SELECT 语句，它嵌套在另一个 SELECT、SELECT…INTO 语句、INSERT…INTO 语句、DELETE 语句、 UPDATE 语句或嵌套在另一子查询中。 MySQL 的子查询是多表查询的一个重要组成部分，常常和 连接查询 一起使用，是多表查询的基础。 子查询分为以下四类： 标量子查询 查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。 列子查询 子查询返回的结果集是 N 行一列，该结果通常来自对表的 某个字段 查询返回。 行子查询 子查询返回的结果集是一行 N 列，该结果通常是对表的 某行数据 进行查询而返回的结果集 表子查询 子查询返回的结果集是 N 行 N 列的一个表数据。 char 与 varchar 的区别 char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532； 使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充； 因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间； DROP、DELETE 与 TRUNCATE 的区别 DROP DELETE TRUNCATE SQL 语句类型 DDL DML DDL 回滚 不可回滚 可回滚 不可回滚 删除内容 从数据库中 删除表，所有的数据行，索引和权限也会被删除 表结构还在，删除表的 全部或者一部分数据行 表结构还在，删除表中的 所有数据 删除速度 删除速度最快 删除速度慢，需要逐行删除 删除速度快 在不再需要一张表的时候，采用 DROP在想删除部分数据行时候，用 DELETE在保留表而删除所有数据的时候用 TRUNCATE UNION 与 UNION ALL 的区别 UNION 用于把来自多个 SELECT 语句的结果组合到一个结果集合中，MySQL 会把结果集中 重复的记录删掉 UNION ALL，MySQL 会把所有的记录返回，且效率高于 UNION","link":"/Language/SQL/"},{"title":"KMP 算法","text":"KMP主要应用在字符串匹配上。 KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 说明借用了这篇博客的一些插图和理解 next数组就是一个前缀表（prefix table）：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 假设 匹配串 S， 模式串 T 最长公共前后缀 ： ABCAB 公共前后缀 是 AB ABABA 公共前后缀 是 ABA ABCABC 公共前后缀 是 ABC 如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图 又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2 将 j 移到 2 （i=5，j=2） 所以，重点要求 next 数组： next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值（最长公共前后缀的长度） 考虑四种情况： ① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1 ② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0 ③ X [ k ] = X [ j ] 匹配到这个位置说明失配位置前 公共前后缀相等，即 X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度） 那么，X [ 0…k ] = X [ j-k…j ] 所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1) ④ X [ k ] != X [ j ] next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀) 此时，将前缀移到后缀位置，即指针前移到最长公共前后缀的长度位置，可以得出： k = next [ k ] 不过，这样求得的 next 数组还有缺陷： 按照前述，j 移到 最长公共前后缀长度 1 的位置： 这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 X[ j ] = X[ next[ j ] ] 的情况没有意义 代码随想录动图示例： 代码GO12345678910111213141516171819202122232425262728293031323334353637383940func getNext(next []int, s string) { i, j := 0, -1 next[0] = j for i &lt; len(s) { for j !=-1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ if i &gt;= len(s) || j &gt;= len(s) { return } if s[i] == s[j] { // 优化去重 next[i] = next[j] } else { next[i] = j } }}func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) i, j := 0, 0 for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) { for j !=-1 &amp;&amp; haystack[i] != needle[j] { j = next[j] } i++ j++ } if j == len(needle) { return i - j } else { return -1 }} C++123456789101112131415161718192021222324252627int nx[maxn];void getnx(string x){ int m=x.size(); int i,j; j=nx[0]=-1; i=0; while (i&lt;m){ while (-1!=j &amp;&amp; x[i]!=x[j]) j=nx[j]; if (x[++i]==x[++j]) nx[i]=nx[j]; else nx[i]=j; }}//输出第一次出现的位置int kmp(string s, string t) { //s为匹配串，t为模式串 int n=s.size(); int m=t.size(); int i=0,j=0; getnx(t); while (i&lt;n &amp;&amp; j&lt;m) { while (-1!=j &amp;&amp; s[i]!=t[j]) j=nx[j]; i++; j++; } if (j==m) return i-j; else return -1;} 性质数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 即最小的循环节 12345678910111213141516171819202122232425func getNext(next []int, s string) { // 计算后缀，不需要去重 i, j := 0, -1 next[0] = j for i &lt; len(s) { for j != -1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ next[i] = j }}func repeatedSubstringPattern(s string) bool { // if len(s) == 0 { return false } next := make([]int, len(s)+1) // 多+1 计算末位最长前后缀 getNext(next, s) l := len(s) if next[l] != 0 &amp;&amp; l%(l-next[l]) == 0 { return true } return false}","link":"/Algorithm/String-KMP/"},{"title":"传输层","text":"传输层（Transport Layer）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。 功能：使用网络层服务，为应用层提供服务 提供进程和进程之间的逻辑通信 复用和分用 传输层对收到的报文进行差错检测 传输层的重要协议： TCP（Transmission Control Protocol）传输控制协议 UDP（User Datagram Protocol）用户数据报协议 参考：力扣王道考研 1、TCP报文 三次握手三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段： 标志位：SYN（Synchronize）、ACK（ACKnowledge Character）序号：seq确认号：ack 第 2 次握手为什么还要传回 SYN： ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（seq）同步给客户端。 为什么三次握手三次握手保证两点： 保证双方都是双工通信： 第一次握手，服务端确定客户端的发送正常 第二次握手，客户端确认服务端的收发正常 第三次握手，服务端确定客服端接收正常 如果只有第二次握手，服务端发给客服端的包丢了之后： 服务端直接建立了连接，端口就会一直开着 等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接 端口越来越多，造成服务器开销的浪费 握手异常 异常 如何处理 备注 第一次握手 SYN 包丢失 服务端不会进行任何相应的动作客户端在一段时间内没有收到服务器发来的确认报文， 会等待一段时间后重新发送 SYN 同步报文，若仍没有回应，则重复上述直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1 客户端超时重传最大次数：tcp_syn_retries，默认5次（Linux 3.7 后为6次） 第二次握手 SYN、ACK 包丢失 客户端会采取第一次握手失败时的动作（超时重传）服务端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文（同样超时重传） 服务端超时重传最大次数：tcp_synack_retries，默认5次 第三次握手 ACK 包丢失 两次握手成功，客户端进入ESTABLISHED状态，服务端进入SYN_REC状态服务端收不到 ACK，就一直重传 SYN、ACK 包，直到超过最大次数，断开TCP连接客户端认为自己连接成功，开始向服务器端发送数据，服务端收到来自客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态 四次挥手四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手： 标志位：Fin（Finish）阶段：FIN-WAIT（半关闭） CLOSE-WAIT：是服务端发出第一次挥手（整体第二次）进入的状态 表示“我准备关闭了，但是还有自己的事情处理一下，你等我处理完”等服务器处理好自己的数据业务，则表示“我准备好了”，再发送 FIN 包 TIME-WAIT：是第四次挥手后，客户端进入的状态，是客户端必要的等待时间。 目的是：等待服务端的对应端口关闭与客户端发送到服务端的数据到达（可能出现延迟） 如果不存在这个步骤就会导致两个问题: 客户端立即关闭后，立即又用同样的端口握手并建立通信，此时上次的连接残留的数据包会被误认为是本次的，造成数据异常 客户端直接关闭后，若服务端重新发送 FIN 包，客户端就会回应 RST，会报异常，但是实际没有问题的 MSL（Maximum Segment Lifetime）：指一段 TCP 报文在传输过程中的最大生命周期 2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长，为的是确认服务器能否接收到客户端发出的 ACK 确认报文 为什么四次挥手简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的： 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文 当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。 可靠传输TCP 如何保证可靠传输： 数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。 序列号和确认应答：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。 校验和：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。 流量控制：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。 拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。 ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。 停止-等待协议在已发送但未确认的报文被确认之前，发送方的滑动窗口将不会滑动（类比滑动窗口算法） 最大连接数限制 Client 最大 TCP 连接数：TCP 端口的数据类型是 unsigned short（$2^{16}$），可用端口最多有 65535 个（除端口0） Server最大 TCP 连接数：客户端 IP 数 × 客户端 port 数（理论） 对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 $2^{32}$（IP 数）× $2^{16}$（port 数），即约为$2^{48}$ 流量控制所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。 拥塞控制拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。 常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。 拥塞控制和流量控制的区别：拥塞控制往往是一种全局的控制，防止过多的数据注入到网络之中流量控制往往指点对点通信量的控制，是端到端的问题（TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处） 2、UDP报文 区别 类型 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 应用场景 首部字节 TCP 是 可靠 字节流 慢 多 文件传输、邮件传输 20~60 UDP 否 不可靠 数据报文段 快 少 即时通讯、域名转换 8个字节 不可靠传输 UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，当对方接收缓冲区满了后就会丢弃，因此 UDP 不能保证数据能够到达目的地 UDP 没有流量控制和重传机制 UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号 调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。 3、MoreSYN FLOODSYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。","link":"/Computer-network/Transport-Layer/"},{"title":"Thanox 情景模式","text":"情景模式简单理解： 什么时候，干什么。 什么时候就是触发条件（condition） 干什么就是动作（actions） 本文分享自用的情景模式，不定期更新~ 官方文档： https://tornaco.github.io/Thanox/6-Profile/ 1、GPS 相关GPS自动开关GPS自动开启 >folded1234567name: &quot;GPS自动开启&quot;description: &quot;打开应用打开GPS，全局变量 gps&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$gps.contains(to) &amp;&amp; !hw.isLocationEnabled()&quot;actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' GPS自动关闭 >folded1234567name: &quot;GPS自动关闭&quot;description: &quot;停止应用关闭GPS，全局变量 gps&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$gps.contains(pkgName) &amp;&amp; hw.isLocationEnabled()&quot;actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 微信小程序开关GPS小程序自动打开GPS >folded1234567name: &quot;小程序自动打开GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI&quot;)'actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' 小程序自动关闭GPS >folded1234567name: &quot;小程序自动关闭GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: 'frontPkgChanged &amp;&amp; hw.isLocationEnabled() &amp;&amp; from == &quot;com.tencent.mm&quot;'actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 微信网页开关GPS微信网页打开GPS >folded1234567name: &quot;微信网页打开GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)'actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' 微信网页关闭GPS >folded1234567name: &quot;微信网页关闭GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; hw.isLocationEnabled() &amp;&amp; !componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)'actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 2、NFC 相关NFC自动开关NFC自动开启 >folded1234567name: &quot;NFC自动开启&quot;description: &quot;打开应用打开NFC，全局变量 nfc&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$nfc.contains(to) &amp;&amp; !hw.isNfcEnabled()&quot;actions: - &quot;hw.enableNfc()&quot; - 'ui.showShortToast(&quot;🎉打开NFC&quot;)' NFC自动关闭 >folded1234567name: &quot;NFC自动关闭&quot;description: &quot;停止应用关闭NFC，全局变量 nfc&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$nfc.contains(pkgName) &amp;&amp; hw.isNfcEnabled()&quot;actions: - &quot;hw.disableNfc()&quot; - 'ui.showShortToast(&quot;🎉关闭NFC&quot;)' 3、冻结相关蓝牙开关冻结BT冻结 >folded1234567name: &quot;BT冻结&quot;description: &quot;蓝牙关闭冻结指定应用，全局变量 btkill&quot;priority: 2condition: &quot;btStateChanged &amp;&amp; btStateOff&quot;actions: - &quot;for (String s : globalVarOf$btkill) { if (pkg.isApplicationEnabled(s)) pkg.disableApplication(s) }&quot; - 'ui.showShortToast(&quot;🎉BT冻结&quot;)' BT解冻 >folded1234567name: &quot;BT解冻&quot;description: &quot;蓝牙打开解冻指定应用，全局变量 btkill&quot;priority: 2condition: &quot;btStateChanged &amp;&amp; btStateOn&quot;actions: - &quot;for (String s : globalVarOf$btkill) { if (!pkg.isApplicationEnabled(s)) pkg.enableApplication(s) }&quot; - 'ui.showShortToast(&quot;🎉BT解冻&quot;)' 游戏开关冻结 自行修改以下 com.oneplus.gamespace 包名 Game冻结 >folded12345678name: &quot;Game冻结&quot;description: &quot;关闭游戏冻结游戏空间，全局变量 game&quot;# 一加专属priority: 2condition: 'taskRemoved &amp;&amp; globalVarOf$game.contains(pkgName) &amp;&amp; pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)'actions: - 'pkg.disableApplication(&quot;com.oneplus.gamespace&quot;)' - 'ui.showShortToast(&quot;🎉冻结游戏空间&quot;)' Game解冻 >folded12345678name: &quot;Game解冻&quot;description: &quot;打开游戏解冻游戏空间，全局变量 game&quot;# 一加专属priority: 2condition: 'frontPkgChanged &amp;&amp; globalVarOf$game.contains(to) &amp;&amp; !pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)'actions: - 'pkg.enableApplication(&quot;com.oneplus.gamespace&quot;)' - 'ui.showShortToast(&quot;🎉解冻游戏空间&quot;)' 4、应用相关APP保活 推荐用乖巧模式的规则来 KEEP 想保持的服务 以下貌似没用，可以开启电池不优化试试 APP保活 >folded12345678name: &quot;APP保活&quot;description: &quot;应用停止运行时重启应用进程，全局变量 apps&quot;# APP 后台不优化priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$apps.contains(pkgName)&quot;actions: - &quot;activity.launchProcessForPackage(pkgName)&quot; - 'ui.showShortToast(&quot;🎉保活app&quot;)' APP休眠APP休眠 >folded123456name: &quot;APP休眠&quot;description: &quot;后台应用休眠，全局变量 idle&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$idle.contains(from)&quot;actions: - &quot;activity.setInactive(from)&quot; 5、Data 相关Data自动开启Data自动开启 >folded1234567name: &quot;Data自动开启&quot;description: &quot;打开应用打开移动数据，全局变量 data&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$data.contains(to) &amp;&amp; !hw.isWifiEnabled() &amp;&amp; !data.isDataEnabled()&quot;actions: - &quot;data.setDataEnabled(true)&quot; - 'ui.showShortToast(&quot;🎉打开移动数据&quot;)' 6、亮度相关自动亮度关闭自动亮度关闭 >folded1234567name: &quot;自动亮度关闭&quot;description: &quot;打开应用关闭自动亮度，全局变量 bright&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$bright.contains(to) &amp;&amp; power.isAutoBrightnessEnabled()&quot;actions: - &quot;power.setAutoBrightnessEnabled(false)&quot; - 'ui.showShortToast(&quot;🎉关闭自动亮度&quot;)' 自动亮度开启自动亮度开启 >folded123456789name: &quot;自动亮度开启&quot;description: &quot;停止应用打开自动亮度，全局变量 bright&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$bright.contains(pkgName) &amp;&amp; !power.isAutoBrightnessEnabled()&quot;actions: - &quot;power.setAutoBrightnessEnabled(true)&quot; - &quot;power.setBrightness(power.getBrightness())&quot; - 'ui.showShortToast(&quot;🎉开启自动亮度&quot;)' 7、状态栏图标相关 隐藏状态栏图标的 shell 命令： settings put secure icon_blacklist 「args」 自行修改 「args」 参数 状态栏图标隐藏 仅供参考 状态栏图标隐藏 >folded1234567name: &quot;状态栏图标隐藏&quot;description: &quot;打开应用隐藏状态栏图标,全局变量 bar&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$bar.contains(to)&quot;actions: - 'sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,clock,battery,vpn&quot;)' - 'ui.showShortToast(&quot;🎉隐藏状态栏图标&quot;)' 状态栏图标显示状态栏图标显示 >folded1234567name: &quot;状态栏图标显示&quot;description: &quot;停止应用显示状态栏图标,全局变量 bar&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$bar.contains(pkgName)&quot;actions: - 'sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,battery,vpn&quot;)' - 'ui.showShortToast(&quot;🎉显示状态栏图标&quot;)'","link":"/Mixed/Thanox-Profile/"}],"tags":[{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Backtracking","slug":"Backtracking","link":"/tags/Backtracking/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Bit Operation","slug":"Bit-Operation","link":"/tags/Bit-Operation/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Device","slug":"Device","link":"/tags/Device/"},{"name":"File","slug":"File","link":"/tags/File/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Memory","slug":"Memory","link":"/tags/Memory/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"License","slug":"License","link":"/tags/License/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Thanox","slug":"Thanox","link":"/tags/Thanox/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Computer network","slug":"Computer-network","link":"/categories/Computer-network/"},{"name":"Data structure","slug":"Data-structure","link":"/categories/Data-structure/"},{"name":"Knowledge","slug":"Knowledge","link":"/categories/Knowledge/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Operating System","slug":"Operating-System","link":"/categories/Operating-System/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Share","slug":"Share","link":"/categories/Share/"},{"name":"Mixed","slug":"Mixed","link":"/categories/Mixed/"}]}