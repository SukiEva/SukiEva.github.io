{"pages":[{"title":"关于","text":"Stats Pinned Contributions","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"comment-policy","text":"评论政策 被认为是垃圾邮件或纯属促销性质的评论将被删除。 包括相关内容的链接是允许的，但评论应与帖子主题相关。 包括亵渎在内的评论将被删除。 包含可能被视为冒犯的语言或概念的评论将被删除。 请注意，这可能包括辱骂性，威胁性，色情，冒犯性，误导性或诽谤性的语言。 直接攻击个人的评论将被删除。 骚扰其他人员的评论将被删除。 请尊重其他贡献者。 匿名评论将被删除。 此博客的所有者保留在未通知的情况下编辑或删除提交到博客的任何评论的权利。 此评论政策随时可能更改。 如果您对评论政策有任何疑问，请通过dev.suki@outlook.com告知我们。","link":"/comment-policy/index.html"}],"posts":[{"title":"Android——ViewBinding","text":"通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。 在大多数情况下，视图绑定会替代 findViewById。 参考自： 视图绑定 | Android 开发者 | Android Developers Android | ViewBinding 与 Kotlin 委托双剑合璧 - 掘金 (juejin.cn) 1、实现原理在 Android 开发更新迭代中，Kotlin 逐渐取代 Java 成为主流开发语言，原来一些旧的使用方法也随之被取代。Android-Kotlin-Extensions 因为安全问题被官方废弃，随之就有了view binding（视图绑定）来继承对findViewById的替换。 用于更加轻量地实现视图绑定（视图与变量的绑定），可以理解为轻量版本的 DataBinding。 Android Gradle 插件会为每个 XML 布局文件创建一个绑定类，绑定类中包含布局文件中每个定义了android:id属性的 View 引用。假设布局文件为fragment_test.xml，则生成绑定类FragmentTestBinding.java； 2、使用方法1、开启视图绑定在模块的build.gradle/.kts中加入以下内容开启： 123456android { ... buildFeatures { viewBinding = true }} 如果希望生成绑定类时忽略某个布局文件，在相应的XML里加入： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 2、Activity中使用在 Activity 的 onCreate() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 将根视图传递到 setContentView()，使其成为屏幕上的活动视图。 123456789101112 private lateinit var binding: ResultProfileBinding override fun onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view) }// 后续通过以下方法引用viewbinding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 3、Fragment中使用在 Fragment 的 onCreateView() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。 注意：inflate() 方法会要求您传入布局膨胀器。如果布局已膨胀，可以调用绑定类的静态 bind() 方法。如需了解详情，请查看视图绑定 GitHub 示例中的例子。 1234567891011121314151617181920212223 private var _binding: ResultProfileBinding? = null // This property is only valid between onCreateView and // onDestroyView. private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view }// Fragment 的存在时间比其视图长。请务必在 Fragment 的 onDestroyView() 方法中清除对绑定类实例的所有引用。 override fun onDestroyView() { super.onDestroyView() _binding = null }// 后续使用binding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 为什么 Fragment#onDestroyView() 里需要置空绑定类对象，而 Activity 里不需要？ 答：Activity 实例和 Activity 视图的生命周期是同步的，而 Fragment 实例和 Fragment 视图的生命周期并不是完全同步的，因此需要在 Fragment 视图销毁时，手动回收绑定类对象，否则造成内存泄露。 例如：detach Fragment，或者 remove Fragment 并且事务进入返回栈，此时 Fragment 视图销毁但 Fragment 实例存在。 总之，在视图销毁但是控制类对象实例还存活的时机，你就需要手动回收绑定类对象，否则造成内存泄露。 3、与其他方案对比 角度 findViewById ButterKnife Kotlin Synthetics DataBinding ViewBinding 简洁性 ✖ ✖ ✔ ✔ ✔ 编译期检查 ✖ ✖ ✖ ✔ ✔ 编译速度 ✔ ✖ ✔ ✖ ✔ 支持 Kotlin &amp; Java ✔ ✔ ✖ ✔ ✔ 收敛模板代码 ✖ ✖ ✔ ✖ ✖ 简洁性： findViewById 和 ButterKnife 需要在代码中声明很多变量，其他几种方案代码简洁读较好； 编译检查： 编译期间主要有两个方面的检查：类型检查 + 只能访问当前布局中的 id。findViewById、ButterKnife 和 Kotlin Synthetics 在这方面表现较差； 编译速度： findViewById 的编译速度是最快的，而 ButterKnife 和 DataBinding 中存在注解处理，编译速度略逊色于 Kotlin Synthetics 和 ViewBinding； 支持 Kotlin &amp; Java： Kotlin Synthetics 只支持 Kotlin 语言； 收敛模板代码： 基本上每种方案都带有一定量的模板代码，只有 Kotlin Synthetics 的模板代码是较少的。","link":"/Android/Android%E2%80%94ViewBinding/"},{"title":"Android四大组件——Activity","text":"Activity 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 main() 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。 参考： Activity 简介 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期状态每个 Activity 至多有4种状态： 运行状态：Activity 位于返回栈栈顶（系统不回收） 暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收） 停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收） 销毁状态：Activity 从返回栈移除（系统回收） 生存期为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()，另有一个onRestart()。当 Activity 进入新状态时，系统会调用其中每个回调。 onCreate()：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 onStart() 和 onResume() 方法 onStart()：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入onResume() onResume()：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态 onPause()：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据 onStop() ：当完全不可见时调用。与onPause() 的区别在于：如果新活动是对话框，onPause()执行，它不执行 onDestroy()：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态 onRestart()：由停止到运行时调用，即活动被重启 以上除了onRestart()两两对应，即： 完整生存期：onCreate()→onDestroy() 可见生存期：onStart()→onStop() 前台生存期：onResume()→onPause() 2、启动模式通过AndroidManifest.xml中为&lt;activity&gt;指定android:launchMode standard默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 singleTop在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。 singleTask在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。 Activity 一次只能有一个实例存在。 注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。 singleInstance与 &quot;singleTask&quot; 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。 该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。 即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。 用于其他应用中调用此 Activity。 3、意图显示 intent12val intent = Intent(this, SecondActivity::class.java)startActivity(intent) 隐式 intent在&lt;activity&gt;下配置&lt;intent-filter&gt;，在&lt;action&gt;中指名可以相应的action，&lt;category&gt;中添加附加信息，只有&lt;action&gt;和&lt;category&gt;同时匹配，当前活动才会响应 intent 123456&lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 12val intent = Intent(com.example.activitytest.ACTION_START) // default 默认添加categorystartActivity(intent) 向下一个 Activity 传递数据在显示 intent 中添加：intent.putExtra() 向上一个Activity 传递数据SecondActivity.kt 1234567override fun onBackPressed() { super.onBackPressed() val intent = Intent() intent.putExtra(&quot;data_return&quot;,&quot;msg...&quot;) setResult(RESULT_OK, intent) finish()} FirstActivity.ky 1234567891011val intent = ...startActivityForResult(intent, 1) // 参数2是请求码，唯一值即可override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { 1 -&gt; if (requestCode = RESULT_OK) { val retrunedData = data?.getStringExtra(&quot;data_return&quot;) } }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Activity/"},{"title":"Android四大组件——BroadcastReceiver","text":"Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似。这些广播会在所关注的事件发生时发送。 一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。 参考： 广播概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、广播类型 标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。 优点：效率高 缺点：无法被截断 系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。 优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播 缺点：效率没有标准广播高 2、系统广播Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。 可以在&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt中查看 1、动态注册程序启动之后才能接收广播 1234567891011121314151617181920212223242526lateinit var timeChangeReceiver: TimeChangeReceiveroverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) // 系统广播动作 timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) // 动态注册}override fun onDestroy() { super.onDestroy() unregisterReceiver(timeChangeReceiver) // 取消注册}// 内部类注册inner class TimeChangeReceiver : BroadcastReceiver() { // 继承 BroadcastReceiver override fun onReceive(p0: Context?, p1: Intent?) { // 不允许多线程，所以不能执行耗时操作 p0?.let { &quot;Time has changed&quot;.showToast(it) } }} 2、静态注册由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。 Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。 例外情况见 隐式广播例外情况 | Android 开发者 | Android Developers 注意：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器 1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3、自定义广播1、发送标准广播创建 BroadcastReceiver12345class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 }} 注册广播12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播123val intent = Intent(&quot;com.example.MY_BROADCAST&quot;)intent.setPackage(packageName) // 指定包名，使其成为显示广播sendBroadcast(intent) 2、发送有序广播前面与标准广播相同，发送广播时选择 sendOrderedBroadcast(intent,null) （参数2是与权限相关的字符串） 设置优先级因为有序广播可以被截断，在静态注册时指定优先级： &lt;intent-filter android:priority=&quot;100&quot;&gt; 截断使用 abortBroadcast() 123456class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 abortBroadcast() }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94BroadcastReceiver/"},{"title":"Android四大组件——ContentProvider","text":"内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。 参考： 内容提供程序 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 todo","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94ContentProvider/"},{"title":"Android四大组件——Service","text":"Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。 参考： 服务概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、多线程一般耗时的服务都需要放在子线程中运行，否则会造成主线程阻塞，从而影响用户使用。 基本用法 继承Thread 1234567class MyThread : Thread(){ override fun fun(){ // ... }}// 开始运行MyThread().start() 上面的方法耦合性过高，一般使用Runnable接口 12345678class MyThread : Runnable{ override fun fun(){ // ... }}// 开始运行val myThread = MyThread()Thread(myThread).start() 更为常见的方法是使用Lambda表达式，不需要专门定义一个类 123456789Thread { // ...}.start()// 在Kotlin中可以写为： 不需要调用 start()thread{ // ...} 子线程更新UIAndroid 的 UI 是线程不安全的，直接在子线程中进行 UI 操作会出现异常。不过，Android 提供了异步消息处理机制Handler。 主要包含以下部分： Message：线程间传递的消息，可以在内部携带少量消息 Handler：处理者，用于发送和处理消息 MessageQueue：消息队列，用于存放通过Handler发送的消息，每个线程只有一个 Looper：每个线程中MessageQueue的管家，调用Looper的loop()后开始循环取出MessageQueue中的消息，并传递到Handler的handleMessage()中，每个线程只有一个 12345678910111213141516val updateText = 1val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) when (msg.what) { updateText -&gt; //... // ... } } }thread{ val msg = Message() msg.what = updateText handler.sendMessage(msg) // 发送消息} AsyncTask 在 API30 被Google废弃，转而推荐使用 将 Kotlin 协程与生命周期感知型组件一起使用 | Android 开发者 | Android Developers 2、Service生命周期最常使用的回调方法是：onBind()、onCreate、onStartCommand、onDestroy onCreate：在 Service 创建（仅第一次）的时候调用 onStartCommand：在 Service 启动（每次）的时候调用 onDestroy：在 Service 销毁时调用 每个 Service 只会存在一个实例 3、Service基本用法启动和停止123val intent = Intent(this, MyService::class.java)startService(intent) // 启动stopService(intent) // 停止 与Activity通信在活动中控制服务的具体执行，而不是启动后就无法控制。 通过Bind实现： 123456789101112131415class MyService : Service() { private val mBinder = DownloadBinder() override fun onBind(intent: Intent): IBinder { return mBinder } class DownloadBinder : Binder() { fun startDownload() { //... } }} 在活动中创建： 1234567891011121314151617var downloadBinder = MyService.DownloadBinder()private val connection = object:ServiceConnection{ // 匿名类 override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) { // 绑定时调用 downloadBinder = p1 as MyService.DownloadBinder downloadBinder.startDownload() // 可自由选择 Service 中的方法 } override fun onServiceDisconnected(p0: ComponentName?) { // 进程崩溃或被杀掉时调用，不常用 TODO(&quot;Not yet implemented&quot;) }}val intent = Intent(this, MyService::class.java)bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service// BIND_AUTO_CREATE: 自动创建Service，调用 onCreate，忽略 onStartCommamdunbindService(connection) // 解绑Service 任何 Service 可以和任意 Activity 绑定，且绑定后获得相同实例 4、前台服务前台服务是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，将其放在运行中的标题下方。这意味着除非将服务停止或从前台移除，否则不能清除该通知。 从 Android 9.0 开始需要申请权限 android.permission.FOREGROUND_SERVICE 在onCreate中： 1234567891011121314val pendingIntent: PendingIntent = Intent(this, ExampleActivity::class.java).let { notificationIntent -&gt; PendingIntent.getActivity(this, 0, notificationIntent, 0) }val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build()startForeground(ONGOING_NOTIFICATION_ID, notification) 5、IntentService用来执行耗时操作的 Service 的子类。 实现 onHandleIntent()，该方法会接收每个启动请求的 Intent，以便您执行后台工作。 1234567891011121314151617181920212223/** * A constructor is required, and must call the super [android.app.IntentService.IntentService] * constructor with a name for the worker thread. */class HelloIntentService : IntentService(&quot;HelloIntentService&quot;) { /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ override fun onHandleIntent(intent: Intent?) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } }} 重写其他回调方法，（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现 例如，onStartCommand() 必须返回默认实现，即如何将 Intent 传递给 onHandleIntent()： 1234override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() return super.onStartCommand(intent, flags, startId)} 启动 123Intent(this, HelloService::class.java).also { intent -&gt; startService(intent)} 扩展服务类借助 IntentService，您可以非常轻松地实现启动服务。但是，若要求服务执行多线程（而非通过工作队列处理启动请求），则可通过扩展 Service 类来处理每个 Intent。 为进行比较，以下示例代码展示了 Service 类的实现，该类执行的工作与上述使用 IntentService 的示例完全相同。换言之，对于每个启动请求，其均使用工作线程来执行作业，且每次仅处理一个请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class HelloService : Service() { private var serviceLooper: Looper? = null private var serviceHandler: ServiceHandler? = null // Handler that receives messages from the thread private inner class ServiceHandler(looper: Looper) : Handler(looper) { override fun handleMessage(msg: Message) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1) } } override fun onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND).apply { start() // Get the HandlerThread's Looper and use it for our Handler serviceLooper = looper serviceHandler = ServiceHandler(looper) } } override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job serviceHandler?.obtainMessage()?.also { msg -&gt; msg.arg1 = startId serviceHandler?.sendMessage(msg) } // If we get killed, after returning from here, restart return START_STICKY } override fun onBind(intent: Intent): IBinder? { // We don't provide binding, so return null return null } override fun onDestroy() { Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show() }}","link":"/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Service/"},{"title":"Binary Search Tree 二叉搜索树","text":"简称 BST，也称二叉排序树或二叉查找树。 特点： 任一结点 &gt; 其左子树的所有结点，并且&lt; 其右子树的所有结点； 结点的左、右子树，也是二叉排序树； 每个结点键值唯一（不能重复） 重要性质： 中序遍历二叉排序树得到递增序列 所以判断 1 棵二叉树是否是二叉排序树？只要中序遍历，得到递增序列才是。 插入 若当前树为空，则新结点为根 若当前树不空，将待插入 x 与根比较； 若 x 等于根，不用插入 若 x 大于根，则去右子树(找位置)； 若 x 小于根，则去左子树(找位置)； 可以总结为： 插入之前，先查找： 若找到，不用插入 若找不到，则在到达的空位置处，放入 x； 所以最新插入的结点，一定是叶子； 1234567891011121314func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return &amp;TreeNode{ Val: val, } } if root.Val &gt; val { root.Left = insertIntoBST(root.Left, val) } if root.Val &lt; val { root.Right = insertIntoBST(root.Right, val) } return root} 查找 从根结点开始，如果树为空，则返回 NULL 如果非空，从根结点开始，比较待检索的键值 若相等，则成功； 若小于根，则去根的左子树； 若大于根，则去根的右子树， 迭代123456789101112func searchBST(root *TreeNode, val int) *TreeNode { for root != nil { if root.Val &gt; val { root = root.Left } else if root.Val &lt; val { root = root.Right } else { return root } } return nil} 删除考虑三种情况： ① 要删除叶子结点直接删除，并将父结点指针置为 NULL ② 删除只有 1 个孩子的结点将父结点指针指向要删除结点的孩子结点 ③ 删除有左右子树的结点用另一个结点替代删除的结点： 右子树的最小元素 或者 左子树的最大元素 12345678910111213141516171819202122232425262728func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return root } if root.Val &gt; key { root.Left = deleteNode(root.Left, key) return root } if root.Val &lt; key { root.Right = deleteNode(root.Right, key) return root } // 情况 1 : 以下两个 if 已经处理 if root.Left == nil { // 情况 2 左 return root.Right } if root.Right == nil { // 情况 2 右 return root.Left } // 情况 3 ： 使用右子树最小元素 minNode := root.Right for minNode.Left != nil { minNode = minNode.Left } root.Val = minNode.Val root.Right = deleteNode(root.Right, minNode.Val) return root} 平均检索长度 ASL比较次数：不大于树的深度 最坏平均查找长度 ASL：(n+1)/2 最好 ASL：$log2(n)$ (参考二分查找) 所有操作的复杂度都是 $O(logn)$","link":"/Data-structure/Binary%20Search%20Tree/"},{"title":"Gradle——Android Build 构建配置","text":"Android 构建系统会编译应用资源和源代码，然后将它们打包到 APK 或 Android App Bundle 中，供测试、部署、签名和分发。Android Studio 会使用高级构建工具包 Gradle 自动执行和管理构建流程，同时也允许定义灵活的自定义 build 配置。 参考: 配置 build | Android 开发者 | Android Developers 史上最全Android build.gradle配置详解，你懂的！ - 掘金 (juejin.cn) 1、构建流程典型 Android 应用模块的构建流程按照以下常规步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。 打包器将 DEX 文件和编译后的资源组合成 APK 或 AAB（具体取决于所选的 build 目标）。 必须先为 APK 或 AAB 签名，然后才能将应用安装到 Android 设备或分发到 Google Play 等商店。 打包器使用调试或发布密钥库为 APK 或 AAB 签名： 如果您构建的是调试版应用（即专门用来测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库（您需要进行配置）为应用签名。如需创建发布密钥库，请参阅在 Android Studio 中为应用签名。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，您将获得应用的调试版或发布版 APK/AAB，以用于部署、测试或向外部用户发布。 2、配置文件1、Gradle 设置文件settings.gradle 文件位于项目的根目录下，用于指示 Gradle 在构建应用时应将哪些模块包含在内。 123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;hhuer&quot;include(&quot;:app&quot;) 2、项目 build 文件顶层 build.gradle 文件位于项目的根目录下，用于定义适用于项目中所有模块的构建配置。 默认情况下，顶层 build 文件使用 buildscript 代码块定义项目中所有模块共用的 Gradle 代码库和依赖项。 1234567891011121314151617buildscript { // gradle脚本执行所需依赖 repositories { // 配置远程仓库 google() // 引用google上的开源项目 mavenCentral() // 引用 jcenter上的开源项目，现已经替换为 mavenCenter } dependencies { // 配置构建工具 classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0-M1&quot;) }}// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 配置项目全局属性 项目包含多个模块时，可以在文件中添加公用配置。 123456789101112buildscript {...}allprojects {...}// 使用mapextra[&quot;compileSdkVersion&quot;] = 28// You can also create properties to specify versions for dependencies.// Having consistent versions between modules can avoid conflicts with behavior.extra[&quot;supportLibVersion&quot;] = &quot;28.0.0&quot;// 或者使用 Kotlin 委托 https://www.runoob.com/kotlin/kotlin-delegated.htmlval compileSdkVersion by extra(31)val supportLibVersion by extra(&quot;28.0.0&quot;) 在模块中使用以下代码引用即可： 123val sdkVersion: Int by rootProject.extra...compileSdkVersion(sdkVersion) 注意：虽然 Gradle 可让您在模块级别定义项目全局属性，但您应避免这样做，因为这样会导致共享这些属性的模块相互结合。模块结合使得以后将模块作为独立项目导出更加困难，并实际妨碍 Gradle 利用并行项目执行加快多模块构建。 3、模块 build 文件模块级 build.gradle 文件位于每个 project/module/ 目录下，用于为其所在的特定模块配置构建设置。您可以通过配置这些 build 设置提供自定义打包选项（如额外的 build 类型和产品变种），以及替换 main/ 应用清单或顶层 build.gradle 文件中的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}// 上面全局配置的引用val androidTargetSdkVersion: Int by rootProject.extra// 配置项目构建的各种属性android { compileSdk = androidCompileSdkVersion //设置编译时用的Android版本 ... defaultConfig { // app 相关 applicationId = defaultManagerPackageName // 包名 minSdk = androidMinSdkVersion // 最低兼容版本 targetSdk = androidTargetSdkVersion // 目标安卓版本 versionCode = verCode // 版本号 versionName = verName // 版本名称 //若使用AndroidJUnitRunner进行单元测试 //testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } //指定生成安装文件的主要配置，一般包含两个子闭包: //一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写； //另一个是release闭包，用于指定生成正式版安装文件的配置。 buildTypes { release { // 一般使用如下两项 isMinifyEnabled = false //是否对代码进行混淆 proguardFiles(&quot;proguard-rules.pro&quot;) //指定混淆的规则文件 } } compileOptions { sourceCompatibility(androidSourceCompatibility) targetCompatibility(androidTargetCompatibility) } kotlinOptions { jvmTarget = &quot;1.8&quot; } packagingOptions{//打包时的相关配置 //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' }}dependencies { // 项目的依赖 // Dependency on a local library module implementation project(&quot;:mylibrary&quot;) // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3' ...}configurations.all { exclude(group = &quot;androidx.appcompat&quot;, module = &quot;appcompat&quot;)} 4、更多模块配置项设置应用 ID添加构建依赖项Android Gradle 插件可以使用的原生依赖项优化构建速度排查构建性能问题分析构建性能配置 build 变体构建多个 APK合并多个清单文件将构建变量注入清单缩减、混淆处理和优化应用为方法数超过 64K 的应用启用 MultiDex 使用 APK 分析器分析您的 build使用 Maven Publish 插件Gradle 提示与诀窍将构建配置从 Groovy 迁移到 KTS 此部分可以参考 Gradle——从Groovy迁移到KTS - Sakurasou (sukiu.top)","link":"/Android/Gradle%E2%80%94Build%E6%9E%84%E5%BB%BA/"},{"title":"Gradle——从Groovy迁移到KTS","text":"在Android Studio中将Gradle配置从 Groovy 迁移到 KTS，即用 Kotlin 代替 Groovy 编写Gradle脚本。 参考： 官方文档 将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers 知乎 快速迁移 Gradle 脚本至 KTS - 知乎 (zhihu.com) 1、转换规则 Groovy 允许使用单引号来定义字符串，而 Kotlin 则要求使用双引号： 即include ':app' -&gt; include &quot;:app&quot; // '(.*?[^\\\\])' 正则替换 &quot;$1&quot; 在 Groovy 中使用 $ 前缀来表示基于句点表达式的字符串插值，但在 Kotlin 中需要使用大括号括住整个变量： 即myRootDirectory = &quot;$project.rootDir/tools&quot; 改为：myRootDirectory = &quot;${project.rootDir}/tools&quot; 显式和隐式 buildTypes：在 KTS 中，仅 debug 和 release buildTypes 是隐式提供的，而 staging 则必须手动创建 12345678910buildTypes getByName(&quot;debug&quot;) { ... } getByName(&quot;release&quot;) { ... } create(&quot;staging&quot;) { ... } 使用 plugins 代码块：给方法调用加上括号 1234567// (\\w+) (([^=\\{\\s]+)(.*)) 正则替换 $1($2)plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;) id(&quot;kotlin-kapt&quot;) id(&quot;androidx.navigation.safeargs.kotlin&quot;)} 更多请参考 Gradle | Kotlin (kotlinlang.org) 2、逐个迁移按上述转换规则逐个迁移以下文件，每迁移一个文件，都 sync 一遍查看是否出现问题。 下列每个迁移前，先把文件扩展名添加为 *.gradle.kts 1、迁移 setting.gradle123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;your app name&quot;include(&quot;:app&quot;) 2、迁移项目的 build.gradle1234567891011121314buildscript { repositories { google() mavenCentral() } dependencies { classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20&quot;) }}tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 3、迁移模块的 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}android { compileSdk = 30 defaultConfig { applicationId = &quot;github.sukieva.hhuer&quot; minSdk = 24 targetSdk = 30 versionCode = 1 versionName = &quot;1.0&quot; } buildTypes { release { isMinifyEnabled = false proguardFiles(&quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility(JavaVersion.VERSION_1_8) targetCompatibility(JavaVersion.VERSION_1_8) } kotlinOptions { jvmTarget = &quot;1.8&quot; }}dependencies { implementation(&quot;androidx.core:core-ktx:1.6.0&quot;) implementation(&quot;androidx.appcompat:appcompat:1.3.1&quot;) implementation(&quot;com.google.android.material:material:1.4.0&quot;) implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.0&quot;) testImplementation(&quot;junit:junit:4.+&quot;) androidTestImplementation(&quot;androidx.test.ext:junit:1.1.3&quot;) androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.4.0&quot;)} 3、代码优化可以在项目的build.gradle.kts里添加定义属性，在其他配置文件可直接访问。 12345678910val defaultManagerPackageName by extra(&quot;github.sukieva.hhuer&quot;)val verCode by extra(20210924)val verName by extra(&quot;1.0&quot;)val androidTargetSdkVersion by extra(31)val androidMinSdkVersion by extra(27)val androidBuildToolsVersion by extra(&quot;31.0.0&quot;)val androidCompileSdkVersion by extra(31)val androidCompileNdkVersion by extra(&quot;23.0.7599858&quot;)val androidSourceCompatibility by extra(JavaVersion.VERSION_11)val androidTargetCompatibility by extra(JavaVersion.VERSION_11) 3、可能出现的问题1、code insight unavailable因为期间重启过几次Android Studio不太确定怎么排除的，可能切换kotlin到dev版能解决此问题。","link":"/Android/Gradle%E2%80%94Gradle%E8%BF%81%E7%A7%BBkts/"},{"title":"Jetpack——Compose","text":"使用 JetpackCompose 的一些笔记。 关键术语 - 组合：Jetpack Compose 在执行可组合项时构建的界面描述。 初始组合：通过首次运行可组合项创建组合。 重组：在数据发生变化时重新运行可组合项以更新组合。 'Surface' A surface container using the 'background' color from the theme 'Divider' is a provided composable function that creates a horizontal divider. 可组合项中的状态可组合函数可以使用 remember 可组合项记住单个对象。 系统会在初始组合期间将由 remember 计算的值存储在组合中，并在重组期间返回存储的值。 remember 既可用于存储可变对象，又可用于存储不可变对象。 mutableStateOf会创建可观察的 MutableState 会创建可观察的 MutableState，后者是与 Compose 运行时集成的可观察类型。 在可组合项中声明 MutableState 对象的方法有三种（等价）： val mutableState = remember { mutableStateOf(default) } var value by remember { mutableStateOf(default) } val (value, setValue) = remember { mutableStateOf(default) } 1234567@Composablefun Counter() { val count = remember { mutableStateOf(0) } Button(onClick = { count.value++ }) { Text(&quot;I've been clicked ${count.value} times&quot;) }} Color primary：main brand color secondary：provide accents Typography","link":"/Android/Jetpack%E2%80%94Compose/"},{"title":"Jetpack——Lifecycle","text":"Lifecycle组件可以让任何一个类都能轻松感知到Activity的生命周期，同时不需要再Activity中编写太多额外的逻辑。 参考： Lifecycle | Android 开发者 | Android Developers Android官方架构组件:Lifecycle详解&amp;原理分析_却把清梅嗅的博客-CSDN博客_lifecycle原理 1、生命周期生命周期和状态事件如图所示： ## 2、Lifecycles 的最佳实践 一般在 ViewModel中观察和控制界面。 保持 UI 控制器（Activity 和 Fragment）尽可能的精简。它们不应该试图去获取它们所需的数据；相反，要用 ViewModel来获取，并且观察 LiveData将数据变化反映到视图中。 尝试编写数据驱动（data-driven）的 UI，即 UI 控制器的责任是在数据改变时更新视图或者将用户的操作通知给 ViewModel。 将数据逻辑放到 ViewModel 类中。ViewModel 应该作为 UI 控制器和应用程序其它部分的连接服务。注意：不是由 ViewModel 负责获取数据（例如：从网络获取）。相反，ViewModel 调用相应的组件获取数据，然后将数据获取结果提供给 UI 控制器。 使用Data Binding来保持视图和 UI 控制器之间的接口干净。这样可以让视图更具声明性，并且尽可能减少在 Activity 和 Fragment 中编写更新代码。如果你喜欢在 Java 中执行该操作，请使用像Butter Knife 这样的库来避免使用样板代码并进行更好的抽象化。 如果 UI 很复杂，可以考虑创建一个 Presenter 类来处理 UI 的修改。虽然通常这样做不是必要的，但可能会让 UI 更容易测试。 不要在 ViewModel 中引用View或者 Activity的 context。因为如果ViewModel存活的比 Activity 时间长（在配置更改的情况下），Activity 将会被泄漏并且无法被正确的回收。","link":"/Android/Jetpack%E2%80%94Lifecycle/"},{"title":"Jetpack——ViewModel","text":"ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。 参考： ViewModel 概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期ViewModel的一个重要作用是帮助Activity分担部分工作，专门用来存放与界面相关的数据，减轻Activity负担。 另外，如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。而ViewModel的生命周期和Activity不同，只有Activity退出时才会跟着一起销毁。 ViewModel对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失： 对于 activity，是在 activity 完成时； 对于 fragment，是在 fragment 分离时。 通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel","link":"/Android/Jetpack%E2%80%94ViewModel/"},{"title":"KMP","text":"KMP主要应用在字符串匹配上。 KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 说明借用了这篇博客的一些插图和理解 next数组就是一个前缀表（prefix table）：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 假设 匹配串 S， 模式串 T 最长公共前后缀 ：ABCAB 公共前后缀 是 ABABABA 公共前后缀 是 ABAABCABC 公共前后缀 是 ABC 如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图 又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2 将 j 移到 2 （i=5，j=2） 所以，重点要求 next 数组： next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值（最长公共前后缀的长度） 考虑四种情况： ① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1 ② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0 ③ X [ k ] = X [ j ]匹配到这个位置说明失配位置前 公共前后缀相等，即X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度）那么，X [ 0…k ] = X [ j-k…j ]所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1) ④ X [ k ] != X [ j ]next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀)此时，将前缀移到后缀位置，即指针前移到最长公共前后缀的长度位置，可以得出：k = next [ k ] 不过，这样求得的 next 数组还有缺陷： 按照前述，j 移到 最长公共前后缀长度 1 的位置： 这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 X[ j ] = X[ next[ j ] ] 的情况没有意义 代码随想录动图示例： 代码GO12345678910111213141516171819202122232425262728293031323334353637383940func getNext(next []int, s string) { i, j := 0, -1 next[0] = j for i &lt; len(s) { for j !=-1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ if i &gt;= len(s) || j &gt;= len(s) { return } if s[i] == s[j] { // 优化去重 next[i] = next[j] } else { next[i] = j } }}func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) i, j := 0, 0 for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) { for j !=-1 &amp;&amp; haystack[i] != needle[j] { j = next[j] } i++ j++ } if j == len(needle) { return i - j } else { return -1 }} C++123456789101112131415161718192021222324252627int nx[maxn];void getnx(string x){ int m=x.size(); int i,j; j=nx[0]=-1; i=0; while (i&lt;m){ while (-1!=j &amp;&amp; x[i]!=x[j]) j=nx[j]; if (x[++i]==x[++j]) nx[i]=nx[j]; else nx[i]=j; }}//输出第一次出现的位置int kmp(string s, string t) { //s为匹配串，t为模式串 int n=s.size(); int m=t.size(); int i=0,j=0; getnx(t); while (i&lt;n &amp;&amp; j&lt;m) { while (-1!=j &amp;&amp; s[i]!=t[j]) j=nx[j]; i++; j++; } if (j==m) return i-j; else return -1;} 性质数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 即最小的循环节 12345678910111213141516171819202122232425func getNext(next []int, s string) { // 计算后缀，不需要去重 i, j := 0, -1 next[0] = j for i &lt; len(s) { for j != -1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ next[i] = j }}func repeatedSubstringPattern(s string) bool { // if len(s) == 0 { return false } next := make([]int, len(s)+1) // 多+1 计算末位最长前后缀 getNext(next, s) l := len(s) if next[l] != 0 &amp;&amp; l%(l-next[l]) == 0 { return true } return false}","link":"/Algorithm/KMP/"},{"title":"Language——Kotlin","text":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 用了Kotlin就不想回到Java，本文主要记录一些高级用法 参考： Android 上的 Kotlin 协程 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 更多细节可查看：基本语法 - Kotlin 语言中文站 (kotlincn.net) 1、基本知识区间 左闭右闭：0..10 左闭右开：0 unitil 10 (step 2) 降序（左闭右闭）：10 downto 1 类主构造函数12345class Examle(...){ init{ ... }} 次构造函数不常用，一般直接指定默认值 1234class Examle(...){ constructor(...) : this(...){} sonstructor() : this (...){}} 修饰符 public：（默认）对所有类可见 private：对当前类内部可见 protected：对当前类和子类可见 internal：对同一模块的类可见 数据类和单例类 数据类：data class，等同于 Java 中一长串的 bean 单例类：object，等同于 Java 中的单例模式（全局至多只有一个实例） Lambda简而言之，就是可以作为参数传递的代码。 太常用也太多了，写写就会了 2、标准函数只介绍最常用的3个 with一个非扩展函数：上下文对象作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（this）使用。 返回值是 lambda 表达式结果。 接收2个参数： 任意类型的对象 Lambda表达式 12345678910val result = with(obj){ // obj 上下文 &quot;value&quot; // with 返回值}val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)with(numbers) { println(&quot;'with' is called with argument $this&quot;) println(&quot;It contains $size elements&quot;)} run上下文对象 作为接收者（this）来访问。 返回值 是 lambda 表达式结果。 run 和 with 做同样的事情，但是调用方式和 let 一样——作为上下文对象的扩展函数. 当 lambda 表达式同时包含对象初始化和返回值的计算时，run 很有用。 12345678910val result = service.run { port = 8080 query(prepareRequest() + &quot; to port $port&quot;)}// 同样的代码如果用 let() 函数来写:val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)} apply上下文对象 作为接收者（this）来访问。 返回值 是上下文对象本身。 对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用 apply。apply 的常见情况是对象配置。这样的调用可以理解为“将以下赋值操作应用于对象”。 12345val adam = Person(&quot;Adam&quot;).apply { age = 32 city = &quot;London&quot; }println(adam) 函数选择为了选择合适的作用域函数，它们之间的主要区别表。 函数 对象引用 返回值 是否是扩展函数 let it Lambda 表达式结果 是 run this Lambda 表达式结果 是 run - Lambda 表达式结果 不是：调用无需上下文对象 with this Lambda 表达式结果 不是：把上下文对象当做参数 apply this 上下文对象 是 also it 上下文对象 是 3、拓展函数和运算符重载拓展函数基本格式： 123fun ClassName.methodName(pararm: Int):Int{ return 0} 例子： 123fun String.showToast(duration: Int = Toast.LENGTH_SHORT) { Toast.makeToast(MyApp.context, this, duration).show()} 运算符重载例子： 12345class Money(val value:Int){ operator fun plus(money:Money):Money{ return Money(value+money.value) }} 4、高阶函数和内联函数高阶函数如果一个函数接收另一个函数作为参数，或者韩非子的类型是另一个函数，则称之为高阶函数。 基本规则：() -&gt; Unit 例子如下，相当于能嵌套函数 123fun CardItem( onClick: () -&gt; Unit = {}) 内联函数高阶函数实现的 Lambda 表达式在底层被转换为匿名类，每次调用都会创建一个新的匿名类实例，造成额外开销 函数前添加inline可消除开销：inline fun example(){} 5、泛型和委托泛型一般编程模式下，需要给任何一个变量指定具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样的代码会有更好的拓展性。 泛型类： 12345678class MyClass&lt;T&gt;{ fun method(param: T): T{ return param }}val myClass = MyClass&lt;Int&gt;() // 指定 Int 泛型val result = myClass.method(123) // 得到 Int 返回值 泛型方法： 1234567891011class MyClass{ fun &lt;T&gt; method(param: T): T{ return param }}val myClass = MyClass()val result = myClass.method&lt;Int&gt;(123)// kotlin 可以自动识别val result = myClass.method(123) 范围： 可通过 &lt;T : Number&gt;的形式指定范围，此时只允许数字类型，字符串会报错 默认类型可空，即Any?，不想为空可改为Any 委托委托是一种设计模式，操作对象自己不会去处理某段逻辑，而是把工作委托给另外一个辅助对象处理。 类委托： 借助委托可以轻松自己实现类，以下通过Hashset自定义一个类：by是实现委托的关键字 1234class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet{ fun helloworld() = println(&quot;hello world&quot;) override fun isEmpty = false} 属性委托： 将一个属性（字段）的具体实现委托给另一个类去完成 1234567891011121314151617181920class MyClass{ val p by Delegate()}// 调用 p 时，自动调用 Delegate类的 getValue 方法，赋值时调用 setValue 方法// 以下是标准的实现class Delegate{ var propValue: Any? = null // 参数1: 指定该类的委托在什么类可以使用 // 参数2: Kotlin属性操作类，可用于获取各种属性相关的值 operator fun getValue(myClass: MyClass, prop: Kproperty&lt;*&gt;): Any?{ return propValue } operator fun setValue(myClass: MyClass, prop: Kproperty&lt;*&gt;, value: Any?): Any?{ propValue = value } } 泛型实化指定泛型的实际类型 inline fun &lt;reified T&gt; start(block: Intent.() -&gt; Unit = {}){} 此时就可以得到T::class.java类型： 1val intent = Intent(context, T::class.java) 泛型协变和逆变 Todo 6、协程可以理解为轻量级的线程，可以在单线程中模拟多线程效果，与线程不同点在于： 线程依靠操作系统调度实现不同线程切换 协程在编程语言层面实现不同协程切换，大大提高并发编程的运行效率 特点：协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的特点包括： 轻量：可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。 内存泄漏更少：使用结构化并发机制在一个作用域内执行多项操作。 内置取消支持：取消操作会自动在运行中的整个协程层次结构内传播。 Jetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。 作用域构建器Tips： delay()：让当前协程延迟指定时间再运行，会阻塞挂起函数，只会挂起当前协程，不会影响其他协程执行 suspend：将任意函数声明为挂起函数，挂起函数间可以互相调用 作用域 GlobalScope.launch{}：顶层协程（不建议用） runBlocking{}：作用域内所有代码和子协程没有全部执行完之前一直阻塞当前线程（测试用，生产可能有性能问题） launch：在作用域内创建多个协程 coroutineScope{}：继承外部协程作用域并创建一个子协程，配合suspend使用，和runBlocking类似，用于生产环境 123suspend fun printDot() = coroutineScope{ launch{}} 常用写法 123456val job = Job()val scope = CoroutineScope(job)scope.launch{ //...}job.cancel() // 取消作用域内所有协程 获取执行结果调用async后，代码立即执行，如果调用await()时还没执行完，则会阻塞当前协程，直到获得async执行结果 12345runBlocking{ val result = async{ 5+5 }.await()} withContext是一个挂起函数，可以理解为async的一种简化版写法： 12345runBlocking{ val result = withContext(Dispatchers.Default){ 5+5 }} 线程参数除了coroutineScope，其他函数都可以指定线程参数，withContext必须，其他可选 Dispatchers.Default：默认低并发线程策略 Dispatchers.IO：较高并发的线程策略 Dispatchers.Main：不会开启子线程，在 Android 主线程执行（只在安卓中使用） Android 中要求网络请求必须在线程执行，定义协程也不行","link":"/Language/Language%E2%80%94Kotlin/"},{"title":"Linux指令——文件与权限","text":"Linux系统中常用的文件目录管理和文件权限管理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文件目录管理命令tree ：以树状图列出目录的内容命令描述：tree命令用于以树状图列出目录的内容。 tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装： 1yum install -y tree 命令使用示例： 1tree /usr/share/wallpapers/ ls ：显示指定工作目录下的内容注意是 L 的小写，不是大写 I 命令描述： ls命令用于显示指定工作目录下的内容。 命令格式：ls [参数] [目录名] 参数说明： 参数 说明 -a 显示所有文件及目录（包括隐藏文件） -l 将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l） -r 将文件反序列出（默认按英文字母正序） -t 将文件按创建时间正序列出 -R 递归遍历目录下文件 pwd ：获取当前工作目录的绝对路径命令描述：获取当前工作目录的绝对路径。 命令使用：pwd cd ：切换工作目录命令描述：cd命令用于切换工作目录。 在路径表示中： 一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。 两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。 cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。 touch ：修改文件或者目录的时间属性命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 命令格式：touch [参数] [文件] 参数说明： 参数 说明 -c 如果指定文件不存在，不会建立新文件 -r 使用参考文件的时间记录 -t 设置文件的时间记录 mkdir ：新建子目录命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。 命令使用示例： 1mkdir -p a/b/c rm ：删除一个文件或者目录命令描述：rm命令用于删除一个文件或者目录。 命令格式：rm [参数] [文件] 参数说明： 参数 说明 -i 删除前逐一询问确认 -f 无需确认，直接删除 -r 删除目录下所有文件 cp ：复制文件或目录命令描述： cp命令主要用于复制文件或目录。 命令格式：cp [参数] [源文件] [目标文件] 参数说明： 参数 说明 -d 复制时保留链接 -f 覆盖已经存在的目标文件而不给出提示 -i 覆盖前询问 -p 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中 -r 复制目录及目录内的所有项目 mv ：为文件或目录改名 / 将文件或目录移入其它位置命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 命令格式：mv [参数] [源文件] [目标文件] 参数说明： 参数 说明-i 若指定目录已有同名文件，则先询问是否覆盖旧文件-f 如果目标文件已经存在，不会询问而直接覆盖 rename ：批量改变文件名命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。 命令格式：rename [原值] [替换值] 2、文件权限管理ls命令可以查看Linux系统上的文件、目录和设备的权限。 1ls -l /boot/ 上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。 第1位表示存档类型，d表示目录，-表示一般文件。 第2~4位表示当前用户的权限（属主权限）。 第5~7位表示同用户组的用户权限（属组权限）。 第8~10位表示不同用户组的用户权限（其他用户权限）。 第11位是一个半角句号.，表示SELinux安全标签。 用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。 例如efi目录的root用户权限为drwxr-xr-x.。 该目录对root用户具有读写和执行所有权限。 该目录对root组其他用户有读和执行权限。 该目录对其他用户有读和执行权限。 所以该权限表示对应八进制权限表示为： 属主权限：4+2+1=7。 属组权限：4+1=5。 其他用户权限：4+1=5。 即755。 chmod ：修改文件权限chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。 将hello.sh文件增加属主的执行权限。 1chmod u+x hello.sh 将hello.sh文件撤销属主的执行权限。 1chmod u-x hello.sh 将hello.sh文件权限修改为八进制表示的744权限。 1chmod 744 hello.sh u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。 chown ：修改文件的属主和属组chown命令修改文件的属主和属组 -R参数以递归方式对子目录和文件进行修改 ls -l命令显示的第三列和第四列就是文件的属主和属组信息。 修改test.txt文件的属主用户为test。 1chown test test.txt 修改test.txt文件的属主和属组为admin。 1chown admin:admin test.txt chgrp ：修改文件的属组chgrp命令用于修改文件的属组。 命令使用示例： 将test.txt文件的属组改为root。 1chgrp root test.txt","link":"/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/"},{"title":"Linux指令——文本处理","text":"如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文本编辑工具Vimvim的三种操作模式： 命令模式（Command mode） 输入模式（Insert mode） 底线命令模式（Last line mode）。 三种模式切换快捷键： 模式 快捷键 命令模式 ESC 输入模式 i或a 底线命令模式 : 命令模式在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。 使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。 以下是在命令模式中常用的快捷操作： 操作快捷键光标左移h光标右移l（小写L）光标上移k光标下移j光标移动到下一个单词w光标移动到上一个单词b移动游标到第n行nG移动游标到第一行gg移动游标到最后一行G快速回到上一次光标所在位置Ctrl+o删除当前字符x删除前一个字符X删除整行dd删除一个单词dw或daw删除至行尾d$或D删除至行首d^删除到文档末尾dG删除至文档首部d1G删除n行ndd删除n个连续字符nx将光标所在位置字母变成大写或小写~复制游标所在的整行yy（3yy表示复制3行）粘贴至光标后（下）p粘贴至光标前（上）P剪切dd交换上下行ddp替换整行，即删除游标所在行并进入插入模式cc撤销一次或n次操作u{n}撤销当前行的所有修改U恢复撤销操作Ctrl+r整行将向右缩进&gt;&gt;整行将向左退回&lt;&lt;若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开ZZ 输入模式在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。 底线命令模式在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。 以下是底线命令模式中常用的快捷操作： 操作命令保存:w退出:q保存并退出:wq（:wq!表示强制保存退出）将文件另存为其他文件名:w new_filename显示行号:set nu取消行号:set nonu使本行内容居中:ce使本行文本靠右:ri使本行内容靠左:le向光标之下寻找一个名称为word的字符串:/word向光标之上寻找一个字符串名称为word的字符串:?word重复前一个搜寻的动作:n从第一行到最后一行寻找word1字符串，并将该字符串取代为word2:1,$s/word1/word2/g 或 &nbsp;:%s/word1/word2/g 2、文本文件查看命令cat ：查看内容较少的纯文本文件命令描述：cat命令用于查看内容较少的纯文本文件。 命令格式：cat [选项] [文件] 命令参数说明： 参数说明-n或--number显示行号-b或--number-nonblank显示行号，但是不对空白行进行编号-s或--squeeze-blank当遇到有连续两行以上的空白行，只显示一行的空白行 more ：从前向后分页显示文件内容命令描述：more命令从前向后分页显示文件内容。 常用操作命令： 操作作用Enter向下n行，n需要定义，默认为1行Ctrl+F或空格键（Space）向下滚动一页Ctrl+B向上滚动一页=输出当前行的行号!命令调用Shell执行命令q退出more less ：对文件或其它输出进行分页显示命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。 命令格式：less [参数] 文件 命令参数说明： 参数说明-e当文件显示结束后，自动离开-m显示类似more命令的百分比-N显示每行的行号-s显示连续空行为一行 命令常用操作： 快捷键说明/字符串向下搜索字符串?字符串向上搜索字符串n重复前一个搜索N反向重复前一个搜索b或pageup键向上翻一页空格键或pagedown键向下翻一页u向前翻半页d向后翻半页y向前滚动一行回车键向后滚动一行q退出less命令 命令使用示例： 查看命令历史使用记录并通过less分页显示。 1history | less head ：查看文件开头指定行数的内容命令描述：head命令用于查看文件开头指定行数的内容。 命令格式：head [参数] [文件] 命令参数说明： 参数说明-n [行数]显示开头指定行的文件内容，默认为10-c [字符数]显示开头指定个数的字符数-q不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名 命令使用示例： 查看/etc/passwd文件的前5行内容。 1head -5 /etc/passwd tail ：查看文档的后N行或持续刷新内容命令描述：tail命令用于查看文档的后N行或持续刷新内容。 命令格式：tail [参数] [文件] 命令参数说明： 参数说明-f显示文件最新追加的内容-q当有多个文件参数时，不输出各个文件名-v当有多个文件参数时，总是输出各个文件名-c [字节数]显示文件的尾部n个字节内容-n [行数]显示文件的尾部n行内容 命令使用示例： 查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。 1tail -f -n 10 /var/log/messages stat ：显示文件的详细信息命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。 命令使用示例： 查看/etc/passwd文件的详细信息。 1stat /etc/passwd wc ：统计指定文本的行数、字数、字节数命令描述：wc命令用于统计指定文本的行数、字数、字节数。 命令格式：wc [参数] [文件] 命令参数说明： 参数说明-l只显示行数-w只显示单词数-c只显示字节数 命令使用示例： 统计/etc/passwd文件的行数。 1wc -l /etc/passwd file ：辨识文件类型命令描述： file命令用于辨识文件类型。 命令格式：file [参数] [文件] 命令参数说明： 参数说明-b列出辨识结果时，不显示文件名称-c详细显示指令执行过程，便于排错或分析程序执行的情形-f [文件]指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称-L直接显示符号连接所指向的文件类别 命令使用示例： 查看/var/log/messages文件的文件类型。 1file /var/log/messages diff ：比较文件的差异命令描述：diff命令用于比较文件的差异。 命令格式：diff [文件] [文件] 3、文本处理命令grep ：查找文件里符合条件的字符串命令描述：grep命令用于查找文件里符合条件的字符串。 grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。 在Shell脚本中，grep通过返回一个状态值来表示搜索的状态： 0：匹配成功。 1：匹配失败。 2：搜索的文件不存在。 命令格式：grep [参数] [正则表达式] [文件] 命令常用参数说明： 参数说明-c或--count计算符合样式的列数-d recurse或-r指定要查找的是目录而非文件-e [范本样式]指定字符串做为查找文件内容的样式-E 或 --extended-regexp将样式为延伸的正则表达式来使用-F 或 --fixed-regexp将样式视为固定字符串的列表-G 或 --basic-regexp将样式视为普通的表示法来使用-i 或 --ignore-case忽略字符大小写的差别-n 或 --line-number在显示符合样式的那一行之前，标示出该行的列数编号-v 或 --revert-match显示不包含匹配文本的所有行 命令使用示例： 查看sshd服务配置文件中监听端口配置所在行编号。 1grep -n Port /etc/ssh/ssh_config 查询字符串在文本中出现的行数。 1grep -c localhost /etc/hosts 反向查找，不显示符合条件的行。 12ps -ef | grep sshdps -ef | grep -v grep | grep sshd 以递归的方式查找目录下含有关键字的文件。 1grep -r *.sh /etc 使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。 1grep 'ntp[0-9].aliyun.com' /etc/ntp.conf sed ：文本处理命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。 处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。 接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。 接着处理下一行，这样不断重复，直到文件末尾。 注意： sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。如果要改变源文件，需要使用-i选项。命令格式：sed [参数] [动作] [文件] 参数说明： 参数说明-e [script]执行多个script-f [script文件]执行指定script文件-n仅显示script处理后的结果-i输出到原文件，静默执行（修改原文件） 动作说明： 动作说明a在行后面增加内容c替换行d删除行i在行前面插入p打印相关的行s替换内容 命令使用示例： 删除第3行到最后一行内容。 1sed '3,$d' /etc/passwd 在最后一行新增行。 1sed '$a admin:x:1000:1000:admin:/home/admin:/bin/bash' /etc/passwd 替换内容。 1sed 's/SELINUX=disabled/SELINUX=enforcing/' /etc/selinux/config 替换行。 1sed '1c abcdefg' /etc/passwd awk ：文本处理命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。 命令格式：awk [参数] [脚本] [文件] 参数说明： 参数说明-F fs指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符-f file读取awk脚本-v val=val在执行处理过程之前，设置一个变量var，并给其设置初始值为val 内置变量： 变量用途FS字段分隔符$n指定分隔的第n个字段，如$1、$3分别表示第1、第三列$0当前读入的整行文本内容NF记录当前处理行的字段个数（列数）NR记录当前已读入的行数FNR当前行在源文件中的行号 awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。 和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。 命令使用示例： 查看本机IP地址。 1ifconfig eth0 |awk '/inet/{print $2}' 查看本机剩余磁盘容量。 1df -h |awk '/\\/$/{print $4}' 统计系统用户个数。 1awk -F: '$3&lt;1000{x++} END{print x}' /etc/passwd 输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。 1awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd 输出/etc/passwd文件中前三行记录的用户名和用户uid。 1head -3 /etc/passwd | awk 'BEGIN{FS=&quot;:&quot;;print &quot;name\\tuid&quot;}{print $1,&quot;\\t&quot;$3}END{print &quot;sum lines &quot;NR}' 查看tcp连接数。 1netstat -na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 关闭指定服务的所有的进程。 1ps -ef | grep httpd | awk {'print $2'} | xargs kill -9 cut ：切割字符串命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。 命令格式：cut [参数] [文件] 参数说明： 参数说明-b以字节为单位进行分割-c以字符为单位进行分割-d自定义分隔符，默认为制表符 tr ：对来自标准输入的字符进行替换、压缩和删除命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。 命令格式：tr [参数] [文本] 参数说明： 参数说明-c反选指定字符-d删除指定字符-s将重复的字符缩减成一个字符-t [第一字符集] [第二字符集]删除第一字符集较第二字符集多出的字符，使两个字符集长度相等 命令使用示例： 将输入字符由大写转换为小写。 1echo &quot;HELLO WORLD&quot; | tr 'A-Z' 'a-z' 删除字符。 1echo &quot;hello 123 world 456&quot; | tr -d '0-9' 压缩字符。 1echo &quot;thissss is a text linnnnnnne.&quot; | tr -s ' sn' 产生随机密码。 1cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13","link":"/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"},{"title":"Linux指令——系统管理","text":"Linux中常用的系统工作命令以及系统状态检测命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、常用系统工作命令echo ：在终端输出字符串或变量提取后的值命令描述：echo命令用于在终端输出字符串或变量提取后的值。 命令格式：echo [字符串 | $变量] 命令用法示例： 显示普通字符串 1echo &quot;Hello World&quot; 显示变量首先在shell环境中定义一个临时变量name，使用echo命令将变量name的值显示到终端。 12export name=&quot;Tom&quot;echo $name 显示结果定向至文件以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。 1echo &quot;This is a test text.&quot; &gt; test.txt 如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。 显示命令执行结果以下命令将会在终端显示当前的工作路径。 1echo `pwd` 注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。使用$(command)形式可以达到相同效果。 1echo $(pwd) date ：显示和设置系统的时间和日期命令描述：date命令用于显示和设置系统的时间和日期。 命令格式：date [选项] [+格式] 其中，时间格式的部分控制字符解释如下： 字符说明%a当地时间的星期名缩写（例如： 日，代表星期日）%A当地时间的星期名全称 （例如：星期日）%b当地时间的月名缩写 （例如：一，代表一月）%B当地时间的月名全称 （例如：一月）%c当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）%C世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）%d按月计的日期（例如：01）%D按月计的日期；等于%m/%d/%y%F完整日期格式，等价于 %Y-%m-%d%j按年计的日期（001-366）%p按年计的日期（001-366）%r当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）%R24 小时时间的时和分，等价于 %H:%M%s自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数%T时间，等于%H:%M:%S%U一年中的第几周，以周日为每星期第一天（00-53）%x当地时间下的日期描述 （例如：12/31/99）%X当地时间下的时间描述 （例如：23:13:48）%w一星期中的第几日（0-6），0 代表周一%W一年中的第几周，以周一为每星期第一天（00-53） 命令用法示例： 按照默认格式查看当前系统时间 1date 按照指定格式查看当前系统时间 1date &quot;+%Y-%m-%d %H:%M:%S&quot; ​查看今天是当年中的第几天 1date &quot;+%j&quot; ​将系统的当前时间设置为2020年02月20日20点20分20秒 1date -s &quot;20200220 20:20:20&quot; ​校正系统时间，与网络时间同步​ a. 安装ntp校时工具 1yum -y install ntp b. 用ntpdate从时间服务器更新时间 1ntpdate time.nist.gov wget ：在终端中下载文件命令描述：在终端中下载文件。 命令格式：wget [参数] 下载地址 参数说明： 参数作用-b后台下载-P下载到指定目录-t最大重试次数-c断点续传-p下载页面内所有资源，包括图片、视频等-r递归下载 命令使用示例： 下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。 1wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png ps ：查看系统中的进程状态命令描述：ps命令用于查看系统中的进程状态。 命令格式：ps [参数] 命令参数说明： 参数作用-a显示现行终端机下的所有程序，包括其他用户的程序-u以用户为主的格式来显示程序状况-x显示没有控制终端的进程，同时显示各个命令的具体路径-e列出程序时，显示每个程序所使用的环境变量-f显示当前所有的进程-t指定终端机编号，并列出属于该终端机的程序的状况 命令使用示例： 1ps -ef | grep sshd top ：动态地监视进程活动与系统负载等信息命令描述：top命令动态地监视进程活动与系统负载等信息。 命令使用示例： 1top 命令输出参数解释： 以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。 统计信息区 第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。 第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。 进程信息区 列名含义PID进程IDUSER进程所有者的用户名PR进程优先级NInice值。负值表示高优先级，正值表示低优先级VIRT进程使用的虚拟内存总量，单位kbRES进程使用的、未被换出的物理内存大小，单位kbSHR共享内存大小，单位kbS进程状态D：不可中断的睡眠状态R：正在运行S：睡眠T：停止Z：僵尸进程%CPU上次更新到现在的CPU时间占用百分比%MEM进程使用的物理内存百分比TIME+进程使用的CPU时间总计，单位1/100秒COMMAND命令名 按 q 键退出监控页面。 pidof ：查询指定服务进程的PID值命令描述：pidof命令用于查询指定服务进程的PID值。 命令格式：pidof [服务名称] 命令参数说明： 参数说明-s仅返回一个进程号-c只显示运行在root目录下的进程，这个选项只对root用户有效-o忽略指定进程号的进程-x显示由脚本开启的进程 命令使用示例： 查询出crond服务下的所有进程ID。 1pidof crond kill ：终止指定PID的服务进程命令描述：kill命令用于终止指定PID的服务进程。 kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。 命令格式：kill [参数] [进程PID] 命令使用示例： 删除pid为1247的进程。 1kill -9 1247 killall ：终止指定名称的服务对应的全部进程命令描述：killall命令用于终止指定名称的服务对应的全部进程。 命令格式：killall [进程名称] 命令使用示例： 删除crond服务下的所有进程。 1killall crond reboot ：重启系统命令描述：reboot命令用来重启系统。 命令格式：reboot [-n] [-w] [-d] [-f] [-i] 命令参数说明： -n：保存数据后再重新启动系统。 -w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。 -d：重新启动时不把数据写入记录文件/var/tmp/wtmp。 -f：强制重新开机，不调用shutdown指令的功能。 -i：关闭网络设置之后再重新启动系统。 命令使用示例： 1reboot poweroff ：关闭系统命令描述：poweroff命令用来关闭系统。 命令使用示例： 1poweroff 2、系统状态检测命令ifconfig ：获取网卡配置与网络状态等信息命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。 命令示例： 命令输出说明： 第一部分的第一行显示网卡状态信息。 eth0表示第一块网卡。 UP代表网卡开启状态。 RUNNING代表网卡的网线被接上。 MULTICAST表示支持组播。 第二行显示网卡的网络信息。 inet（IP地址）：172.16.132.195。 broadcast（广播地址）：172.16.143.255。 netmask（掩码地址）：255.255.240.0。 RX表示接收数据包的情况，TX表示发送数据包的情况。 lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。 uname ：查看系统内核与系统版本等信息命令描述：uname命令用于查看系统内核与系统版本等信息。 命令语法：uname [-amnrsv][--help][--version] 命令使用示例： 显示系统信息。 1uname -a 显示当前系统的硬件架构。 1uname -i 显示操作系统发行编号。 1uname -r 显示操作系统名称。 1uname -s 显示主机名称。 1uname -n uptime ：查看系统的负载信息命令描述：uptime 用于查看系统的负载信息。 命令使用示例：命令输出说明： 负载信息命令输出值当前服务器时间14:20:27当前服务器运行时长2 min当前用户数2 users当前负载情况load average: 0.03, 0.04, 0.02（分别取1min，5min，15min的均值） free ：显示当前系统中内存的使用量信息命令描述：free用于显示当前系统中内存的使用量信息。 命令语法：free [-bkmotV][-s &lt;间隔秒数&gt;] 命令参数说明： 参数说明-b以Byte为单位显示内存使用情况-k以KB为单位显示内存使用情况-m以MB为单位显示内存使用情况-h以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。 命令使用示例：命令输出说明： 参数说明total物理内存总数used已经使用的内存数free空间的内存数share多个进程共享的内存总额buff/cache应用使用内存数available可用的内存数Swap虚拟内存（阿里云ECS服务器默认不开启虚拟内存） who ：显示关于当前在本地系统上的所有用户的信息命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。 命令使用示例： 显示当前登录系统的用户 1who 显示用户登录来源 1who -l -H 只显示当前用户 1who -m -H 精简模式显示 1who -q last ：显示用户最近登录信息命令描述： last 命令用于显示用户最近登录信息。 1last history ：显示历史执行过的命令命令描述：history命令用于显示历史执行过的命令。 bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。 命令使用示例： 显示最新10条执行过的命令。 1history 10 清除历史记录。 1history -c","link":"/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"title":"Monotone Queue 单调队列","text":"“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 参考： 代码随想录 (programmercarl.com) 1、介绍单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下： 2、实现 保证队列里单调递减或递增的原则，所以叫做单调队列。 以下不是固定写法： 12345678910111213141516171819202122232425262728293031323334type MonotoneQueue struct { queue []int}func Constructor() MonotoneQueue { return MonotoneQueue{ queue: make([]int, 0), }}func (this *MonotoneQueue) Front() int { return this.queue[0]}func (this *MonotoneQueue) Back() int { return this.queue[len(this.queue)-1]}func (this *MonotoneQueue) Empty() bool { return len(this.queue) == 0}func (this *MonotoneQueue) Push(x int) { for !this.Empty() &amp;&amp; x &gt; this.Back() { this.queue = this.queue[:len(this.queue)-1] } this.queue = append(this.queue, x)}func (this *MonotoneQueue) Pop(x int) { if !this.Empty() &amp;&amp; this.Front() == x { this.queue = this.queue[1:] }}","link":"/Data-structure/Monotone%20Queue/"},{"title":"Priority Queue Go 优先队列","text":"论如何在 Go 语言中使用优先队列。 参考： Go标准库中文文档 (cngolib.com) 1、介绍Go 提供了 container/heap 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 index = 0 的值是最小的，即最小堆。 堆也是实现优先队列 Priority Queue 的常用方式。 堆中元素的类型需要实现 heap.Interface 这个接口： 12345type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1.} 其中 sort.Interface 包括 Len(), Less, Swap 方法。 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041type IntHeap [][2]int // 0 key 1 valuefunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i][1] &lt; h[j][1] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.([2]int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 347. 前 K 个高频元素// https://leetcode-cn.com/problems/top-k-frequent-elements/func topKFrequent(nums []int, k int) []int { m := make(map[int]int) ans := make([]int, k) h := &amp;IntHeap{} heap.Init(h) for _, v := range nums { m[v]++ } for key, value := range m { heap.Push(h, [2]int{key, value}) if h.Len() &gt; k { heap.Pop(h) } } for k &gt; 0 { k-- ans[k] = heap.Pop(h).([2]int)[0] } return ans}","link":"/Data-structure/Priority%20Queue/"},{"title":"Queue","text":"与栈类似，队列是一种先进先出的容器适配器。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 1、定义 在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。 2、实现为了实现队列，我们可以使用动态数组和指向队列头部的索引。 简单的参考实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;class MyQueue { private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() {p_start = 0;} /** Insert an element into the queue. Return true if the operation is successful. */ bool enQueue(int x) { data.push_back(x); return true; } /** Delete an element from the queue. Return true if the operation is successful. */ bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; /** Get the front item from the queue. */ int Front() { return data[p_start]; }; /** Checks whether the queue is empty or not. */ bool isEmpty() { return p_start &gt;= data.size(); }};int main() { MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; }} 缺点上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。 所以应该规定数组的长度，一组一组队列的进行使用。","link":"/Data-structure/Queue/"},{"title":"Stack","text":"栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。 STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 代码随想录 (programmercarl.com) 1、介绍在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。 与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。 2、实现从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 动态数组实现参考： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack { private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) { data.push_back(x); } /** Checks whether the queue is empty or not. */ bool isEmpty() { return data.empty(); } /** Get the top item from the queue. */ int top() { return data.back(); } /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; }};int main() { MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) { if (!s.isEmpty()) { cout &lt;&lt; s.top() &lt;&lt; endl; } cout &lt;&lt; (s.pop() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl; }}","link":"/Data-structure/Stack/"},{"title":"主流开源协议","text":"常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类： 宽松自由软件许可协议 Permissive free software licence 著佐权许可证 copyleft license 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 参考： 主流开源协议之间有何异同？ - 知乎 (zhihu.com) 如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com) 1、区别 Permissive free software licence ： 一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。 Copyleft License ： 在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。 两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 2、常见开源许可证 MITMIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。 BSDBerkeley Software Distribution license BSD 许可证与 MIT 差不多。 事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。 可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。 ApacheApache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。 Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。 Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。 GPLGPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。 由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。 LGPL更宽松的GPL协议。 与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。 调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。","link":"/Mixed/%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"title":"二叉树遍历","text":"二叉树遍历主要包括： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 参考： 代码随想录 (programmercarl.com) 1、递归遍历递归三要素： 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历即 根-左-右 1234567891011121314func preorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var preOrder func(root *TreeNode) preOrder = func(root *TreeNode) { if root == nil { return } ans = append(ans, root.Val) preOrder(root.Left) preOrder(root.Right) } preOrder(root) return ans} 中序遍历即 左-根-右 1234567891011121314func inorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var inOrder func(root *TreeNode) inOrder = func(root *TreeNode) { if root == nil { return } inOrder(root.Left) ans = append(ans, root.Val) inOrder(root.Right) } inOrder(root) return ans} 后序遍历即 左-右-根 1234567891011121314func postorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var postorder func(root *TreeNode) postorder = func(root *TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) ans = append(ans, root.Val) } postorder(root) return ans} 2、迭代遍历要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 通过这种标记法实现二叉树的统一迭代遍历。 前序遍历12345678910111213141516171819202122232425262728func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } stack.PushBack(node) // 根 stack.PushBack(nil) } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 中序遍历12345678910111213141516171819202122232425262728func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } stack.PushBack(node) // 根 stack.PushBack(nil) if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 后序遍历12345678910111213141516171819202122232425262728func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 stack.PushBack(node) // 根 stack.PushBack(nil) if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 3、层序遍历12345678910111213141516171819202122232425func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := list.New() queue.PushBack(root) t := make([]int, 0) for queue.Len() &gt; 0 { l := queue.Len() for i := 0; i &lt; l; i++ { node := queue.Remove(queue.Front()).(*TreeNode) t = append(t, node.Val) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } } ans = append(ans, t) t = []int{} } return ans}","link":"/Algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"title":"常见容器底层","text":"各种语言下，常见容器底层整理。 参考： C++ STL容器底层数据结构总结 - 简书 (jianshu.com) C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com) 1、C++vector其底层数据结构是数组，由于能动态扩容，所以也称动态数组 特点： 随机访问：$O(1)$ 随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删 扩容规则： 新建时初始化一片空间 插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据 释放原来空间 在进行迭代器相关的修改操作时（包括扩容），所有迭代器和指针引用都会失效 map &amp; multimap &amp; set &amp; multisetmap提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。 与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。 底层数据结构均为红黑树，可以参考[教你透彻了解红黑树](The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com))。 特点： 访问、查找、删除：$O(logn)$ unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset顾名思义，以上容器是无序的，所以底层实现为哈希表，因此其查找时间复杂度理论上达到了O(n) 特点： 访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题 2、GoGo 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现 map底层数据结构是哈希表 特点： 访问、查找、删除：$O(1)$","link":"/Data-structure/%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82/"}],"tags":[{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"License","slug":"License","link":"/tags/License/"},{"name":"Container","slug":"Container","link":"/tags/Container/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Data structure","slug":"Data-structure","link":"/categories/Data-structure/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Mixed","slug":"Mixed","link":"/categories/Mixed/"}]}