{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于","text":"Stats Pinned Contributions","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"comment-policy","text":"评论政策 被认为是垃圾邮件或纯属促销性质的评论将被删除。 包括相关内容的链接是允许的，但评论应与帖子主题相关。 包括亵渎在内的评论将被删除。 包含可能被视为冒犯的语言或概念的评论将被删除。 请注意，这可能包括辱骂性，威胁性，色情，冒犯性，误导性或诽谤性的语言。 直接攻击个人的评论将被删除。 骚扰其他人员的评论将被删除。 请尊重其他贡献者。 匿名评论将被删除。 此博客的所有者保留在未通知的情况下编辑或删除提交到博客的任何评论的权利。 此评论政策随时可能更改。 如果您对评论政策有任何疑问，请通过dev.suki@outlook.com告知我们。","link":"/comment-policy/index.html"}],"posts":[{"title":"Android四大组件——BroadcastReceiver","text":"Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与发布-订阅设计模式相似。这些广播会在所关注的事件发生时发送。 一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。 参考： 广播概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、广播类型 标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。 优点：效率高 缺点：无法被截断 系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。 优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播 缺点：效率没有标准广播高 2、系统广播Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。 可以在&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt中查看 1、动态注册程序启动之后才能接收广播 1234567891011121314151617181920212223242526lateinit var timeChangeReceiver: TimeChangeReceiveroverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) // 系统广播动作 timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) // 动态注册}override fun onDestroy() { super.onDestroy() unregisterReceiver(timeChangeReceiver) // 取消注册}// 内部类注册inner class TimeChangeReceiver : BroadcastReceiver() { // 继承 BroadcastReceiver override fun onReceive(p0: Context?, p1: Intent?) { // 不允许多线程，所以不能执行耗时操作 p0?.let { &quot;Time has changed&quot;.showToast(it) } }} 2、静态注册由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。 Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。 例外情况见 隐式广播例外情况 | Android 开发者 | Android Developers 注意：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器 1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 3、自定义广播1、发送标准广播创建 BroadcastReceiver12345class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 }} 注册广播12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播123val intent = Intent(&quot;com.example.MY_BROADCAST&quot;)intent.setPackage(packageName) // 指定包名，使其成为显示广播sendBroadcast(intent) 2、发送有序广播前面与标准广播相同，发送广播时选择 sendOrderedBroadcast(intent,null) （参数2是与权限相关的字符串） 设置优先级因为有序广播可以被截断，在静态注册时指定优先级： &lt;intent-filter android:priority=&quot;100&quot;&gt; 截断使用 abortBroadcast() 123456class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(p0: Context?, p1: Intent?) { // TODO: 2021/9/28 abortBroadcast() }}","link":"/Android/Android-BroadcastReceiver/"},{"title":"Android四大组件——ContentProvider","text":"内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。 参考： 内容提供程序 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 todo","link":"/Android/Android-ContentProvider/"},{"title":"Android四大组件——Activity","text":"Activity 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 main() 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。 参考：Activity 简介 | Android 开发者 | Android Developers《第一行代码 Android 第3版》 1、生命周期状态每个 Activity 至多有4种状态： 运行状态：Activity 位于返回栈栈顶（系统不回收） 暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收） 停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收） 销毁状态：Activity 从返回栈移除（系统回收） 生存期为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()，另有一个onRestart()。当 Activity 进入新状态时，系统会调用其中每个回调。 onCreate()：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 onStart() 和 onResume() 方法 onStart()：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入onResume() onResume()：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态 onPause()：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据 onStop() ：当完全不可见时调用。与onPause() 的区别在于：如果新活动是对话框，onPause()执行，它不执行 onDestroy()：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态 onRestart()：由停止到运行时调用，即活动被重启 以上除了onRestart()两两对应，即： 完整生存期：onCreate()→onDestroy() 可见生存期：onStart()→onStop() 前台生存期：onResume()→onPause() 2、启动模式通过AndroidManifest.xml中为&lt;activity&gt;指定android:launchMode standard默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 singleTop在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。 Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。 singleTask在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。 Activity 一次只能有一个实例存在。 注意：虽然 Activity 在新任务中启动，但用户按返回按钮仍会返回到上一个 Activity。 singleInstance与 &quot;singleTask&quot; 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。 该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。 即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。 用于其他应用中调用此 Activity。 3、意图显示 intent12val intent = Intent(this, SecondActivity::class.java)startActivity(intent) 隐式 intent在&lt;activity&gt;下配置&lt;intent-filter&gt;，在&lt;action&gt;中指名可以相应的action，&lt;category&gt;中添加附加信息，只有&lt;action&gt;和&lt;category&gt;同时匹配，当前活动才会响应 intent 123456&lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 12val intent = Intent(com.example.activitytest.ACTION_START) // default 默认添加categorystartActivity(intent) 向下一个 Activity 传递数据在显示 intent 中添加：intent.putExtra() 向上一个Activity 传递数据SecondActivity.kt 1234567override fun onBackPressed() { super.onBackPressed() val intent = Intent() intent.putExtra(&quot;data_return&quot;,&quot;msg...&quot;) setResult(RESULT_OK, intent) finish()} FirstActivity.ky 1234567891011val intent = ...startActivityForResult(intent, 1) // 参数2是请求码，唯一值即可override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { 1 -&gt; if (requestCode = RESULT_OK) { val retrunedData = data?.getStringExtra(&quot;data_return&quot;) } }}","link":"/Android/Android-Activity/"},{"title":"Android——ViewBinding","text":"通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。 在大多数情况下，视图绑定会替代 findViewById。 参考自： 视图绑定 | Android 开发者 | Android Developers Android | ViewBinding 与 Kotlin 委托双剑合璧 - 掘金 (juejin.cn) 1、实现原理在 Android 开发更新迭代中，Kotlin 逐渐取代 Java 成为主流开发语言，原来一些旧的使用方法也随之被取代。Android-Kotlin-Extensions 因为安全问题被官方废弃，随之就有了view binding（视图绑定）来继承对findViewById的替换。 用于更加轻量地实现视图绑定（视图与变量的绑定），可以理解为轻量版本的 DataBinding。 Android Gradle 插件会为每个 XML 布局文件创建一个绑定类，绑定类中包含布局文件中每个定义了android:id属性的 View 引用。假设布局文件为fragment_test.xml，则生成绑定类FragmentTestBinding.java； 2、使用方法1、开启视图绑定在模块的build.gradle/.kts中加入以下内容开启： 123456android { ... buildFeatures { viewBinding = true }} 如果希望生成绑定类时忽略某个布局文件，在相应的XML里加入： 12345&lt;LinearLayout ... tools:viewBindingIgnore=&quot;true&quot; &gt; ...&lt;/LinearLayout&gt; 2、Activity中使用在 Activity 的 onCreate() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Activity 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 将根视图传递到 setContentView()，使其成为屏幕上的活动视图。 123456789101112 private lateinit var binding: ResultProfileBinding override fun onCreate(savedInstanceState: Bundle) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view) }// 后续通过以下方法引用viewbinding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 3、Fragment中使用在 Fragment 的 onCreateView() 方法中执行以下步骤： 调用生成的绑定类中包含的静态 inflate() 方法。此操作会创建该绑定类的实例以供 Fragment 使用。 通过调用 getRoot() 方法或使用 Kotlin 属性语法获取对根视图的引用。 从 onCreateView() 方法返回根视图，使其成为屏幕上的活动视图。 注意：inflate() 方法会要求您传入布局膨胀器。如果布局已膨胀，可以调用绑定类的静态 bind() 方法。如需了解详情，请查看视图绑定 GitHub 示例中的例子。 1234567891011121314151617181920212223 private var _binding: ResultProfileBinding? = null // This property is only valid between onCreateView and // onDestroyView. private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view }// Fragment 的存在时间比其视图长。请务必在 Fragment 的 onDestroyView() 方法中清除对绑定类实例的所有引用。 override fun onDestroyView() { super.onDestroyView() _binding = null }// 后续使用binding.name.text = viewModel.name binding.button.setOnClickListener { viewModel.userClicked() } 为什么 Fragment#onDestroyView() 里需要置空绑定类对象，而 Activity 里不需要？ 答：Activity 实例和 Activity 视图的生命周期是同步的，而 Fragment 实例和 Fragment 视图的生命周期并不是完全同步的，因此需要在 Fragment 视图销毁时，手动回收绑定类对象，否则造成内存泄露。 例如：detach Fragment，或者 remove Fragment 并且事务进入返回栈，此时 Fragment 视图销毁但 Fragment 实例存在。 总之，在视图销毁但是控制类对象实例还存活的时机，你就需要手动回收绑定类对象，否则造成内存泄露。 3、与其他方案对比 角度 findViewById ButterKnife Kotlin Synthetics DataBinding ViewBinding 简洁性 ✖ ✖ ✔ ✔ ✔ 编译期检查 ✖ ✖ ✖ ✔ ✔ 编译速度 ✔ ✖ ✔ ✖ ✔ 支持 Kotlin &amp; Java ✔ ✔ ✖ ✔ ✔ 收敛模板代码 ✖ ✖ ✔ ✖ ✖ 简洁性： findViewById 和 ButterKnife 需要在代码中声明很多变量，其他几种方案代码简洁读较好； 编译检查： 编译期间主要有两个方面的检查：类型检查 + 只能访问当前布局中的 id。findViewById、ButterKnife 和 Kotlin Synthetics 在这方面表现较差； 编译速度： findViewById 的编译速度是最快的，而 ButterKnife 和 DataBinding 中存在注解处理，编译速度略逊色于 Kotlin Synthetics 和 ViewBinding； 支持 Kotlin &amp; Java： Kotlin Synthetics 只支持 Kotlin 语言； 收敛模板代码： 基本上每种方案都带有一定量的模板代码，只有 Kotlin Synthetics 的模板代码是较少的。","link":"/Android/Android-ViewBinding/"},{"title":"B Tree","text":"B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。 特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围； 把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。 转载： 平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 1、B 树(B-tree) 注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树; 1、概念B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构 规则： （1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则 （2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉） （3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2) （4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子 例子： 来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） 2、B 树的查询如上图我要从上图中找到 E 字母，查找流程如下 （1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）； （2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点； （3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）； 3、B 树的插入定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来; （1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）； （2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则; 先插入 3、8、31、11 再插入 23、29 再插入 50、28 3、B 树的删除 （1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）； （2）满足节点本身比左边节点大，比右边节点小的排序规则; （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放； 2、B+树1、概念B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别 （1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加； （2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样； （3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。 （4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）; 2、特点1、B+树的层级更少：相较于 B 树 B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快； 2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定; 3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。 4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B 树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B 树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。 3、总结1、相同思想和策略从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度； 2、不同的方式的磁盘空间利用不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；","link":"/Data-structure/B-Tree/"},{"title":"Android四大组件——Service","text":"Service 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。 参考： 服务概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、多线程一般耗时的服务都需要放在子线程中运行，否则会造成主线程阻塞，从而影响用户使用。 基本用法 继承Thread 1234567class MyThread : Thread(){ override fun fun(){ // ... }}// 开始运行MyThread().start() 上面的方法耦合性过高，一般使用Runnable接口 12345678class MyThread : Runnable{ override fun fun(){ // ... }}// 开始运行val myThread = MyThread()Thread(myThread).start() 更为常见的方法是使用Lambda表达式，不需要专门定义一个类 123456789Thread { // ...}.start()// 在Kotlin中可以写为： 不需要调用 start()thread{ // ...} 子线程更新UIAndroid 的 UI 是线程不安全的，直接在子线程中进行 UI 操作会出现异常。不过，Android 提供了异步消息处理机制Handler。 主要包含以下部分： Message：线程间传递的消息，可以在内部携带少量消息 Handler：处理者，用于发送和处理消息 MessageQueue：消息队列，用于存放通过Handler发送的消息，每个线程只有一个 Looper：每个线程中MessageQueue的管家，调用Looper的loop()后开始循环取出MessageQueue中的消息，并传递到Handler的handleMessage()中，每个线程只有一个 12345678910111213141516val updateText = 1val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) when (msg.what) { updateText -&gt; //... // ... } } }thread{ val msg = Message() msg.what = updateText handler.sendMessage(msg) // 发送消息} AsyncTask 在 API30 被Google废弃，转而推荐使用 将 Kotlin 协程与生命周期感知型组件一起使用 | Android 开发者 | Android Developers 2、Service生命周期最常使用的回调方法是：onBind()、onCreate、onStartCommand、onDestroy onCreate：在 Service 创建（仅第一次）的时候调用 onStartCommand：在 Service 启动（每次）的时候调用 onDestroy：在 Service 销毁时调用 每个 Service 只会存在一个实例 3、Service基本用法启动和停止123val intent = Intent(this, MyService::class.java)startService(intent) // 启动stopService(intent) // 停止 与Activity通信在活动中控制服务的具体执行，而不是启动后就无法控制。 通过Bind实现： 123456789101112131415class MyService : Service() { private val mBinder = DownloadBinder() override fun onBind(intent: Intent): IBinder { return mBinder } class DownloadBinder : Binder() { fun startDownload() { //... } }} 在活动中创建： 1234567891011121314151617var downloadBinder = MyService.DownloadBinder()private val connection = object:ServiceConnection{ // 匿名类 override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) { // 绑定时调用 downloadBinder = p1 as MyService.DownloadBinder downloadBinder.startDownload() // 可自由选择 Service 中的方法 } override fun onServiceDisconnected(p0: ComponentName?) { // 进程崩溃或被杀掉时调用，不常用 TODO(&quot;Not yet implemented&quot;) }}val intent = Intent(this, MyService::class.java)bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service// BIND_AUTO_CREATE: 自动创建Service，调用 onCreate，忽略 onStartCommamdunbindService(connection) // 解绑Service 任何 Service 可以和任意 Activity 绑定，且绑定后获得相同实例 4、前台服务前台服务是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，将其放在运行中的标题下方。这意味着除非将服务停止或从前台移除，否则不能清除该通知。 从 Android 9.0 开始需要申请权限 android.permission.FOREGROUND_SERVICE 在onCreate中： 1234567891011121314val pendingIntent: PendingIntent = Intent(this, ExampleActivity::class.java).let { notificationIntent -&gt; PendingIntent.getActivity(this, 0, notificationIntent, 0) }val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build()startForeground(ONGOING_NOTIFICATION_ID, notification) 5、IntentService用来执行耗时操作的 Service 的子类。 实现 onHandleIntent()，该方法会接收每个启动请求的 Intent，以便您执行后台工作。 1234567891011121314151617181920212223/** * A constructor is required, and must call the super [android.app.IntentService.IntentService] * constructor with a name for the worker thread. */class HelloIntentService : IntentService(&quot;HelloIntentService&quot;) { /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ override fun onHandleIntent(intent: Intent?) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } }} 重写其他回调方法，（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现 例如，onStartCommand() 必须返回默认实现，即如何将 Intent 传递给 onHandleIntent()： 1234override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() return super.onStartCommand(intent, flags, startId)} 启动 123Intent(this, HelloService::class.java).also { intent -&gt; startService(intent)} 扩展服务类借助 IntentService，您可以非常轻松地实现启动服务。但是，若要求服务执行多线程（而非通过工作队列处理启动请求），则可通过扩展 Service 类来处理每个 Intent。 为进行比较，以下示例代码展示了 Service 类的实现，该类执行的工作与上述使用 IntentService 的示例完全相同。换言之，对于每个启动请求，其均使用工作线程来执行作业，且每次仅处理一个请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class HelloService : Service() { private var serviceLooper: Looper? = null private var serviceHandler: ServiceHandler? = null // Handler that receives messages from the thread private inner class ServiceHandler(looper: Looper) : Handler(looper) { override fun handleMessage(msg: Message) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1) } } override fun onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND).apply { start() // Get the HandlerThread's Looper and use it for our Handler serviceLooper = looper serviceHandler = ServiceHandler(looper) } } override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show() // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job serviceHandler?.obtainMessage()?.also { msg -&gt; msg.arg1 = startId serviceHandler?.sendMessage(msg) } // If we get killed, after returning from here, restart return START_STICKY } override fun onBind(intent: Intent): IBinder? { // We don't provide binding, so return null return null } override fun onDestroy() { Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show() }}","link":"/Android/Android-Service/"},{"title":"Binary Search Tree 二叉搜索树","text":"简称 BST，也称二叉排序树或二叉查找树。 特点： 任一结点 &gt; 其左子树的所有结点， 并且&lt; 其右子树的所有结点； 结点的左、右子树，也是二叉排序树； 每个结点键值唯一（不能重复） 重要性质： 中序遍历二叉排序树得到递增序列 所以判断 1 棵二叉树是否是二叉排序树？只要中序遍历，得到递增序列才是。 插入 若当前树为空，则新结点为根 若当前树不空， 将待插入 x 与根比较； 若 x 等于根，不用插入 若 x 大于根，则去右子树(找位置)； 若 x 小于根，则去左子树(找位置)； 可以总结为： 插入之前，先查找： 若找到，不用插入 若找不到，则在到达的空位置处，放入 x； 所以最新插入的结点，一定是叶子； 1234567891011121314func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return &amp;TreeNode{ Val: val, } } if root.Val &gt; val { root.Left = insertIntoBST(root.Left, val) } if root.Val &lt; val { root.Right = insertIntoBST(root.Right, val) } return root} 查找 从根结点开始，如果树为空，则返回 NULL 如果非空，从根结点开始，比较待检索的键值 若相等，则成功； 若小于根， 则去根的左子树； 若大于根， 则去根的右子树， 迭代123456789101112func searchBST(root *TreeNode, val int) *TreeNode { for root != nil { if root.Val &gt; val { root = root.Left } else if root.Val &lt; val { root = root.Right } else { return root } } return nil} 删除考虑三种情况： ① 要删除叶子结点 直接删除，并将父结点指针置为 NULL ② 删除只有 1 个孩子的结点 将父结点指针指向要删除结点的孩子结点 ③ 删除有左右子树的结点 用另一个结点替代删除的结点： 右子树的最小元素 或者 左子树的最大元素 12345678910111213141516171819202122232425262728func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return root } if root.Val &gt; key { root.Left = deleteNode(root.Left, key) return root } if root.Val &lt; key { root.Right = deleteNode(root.Right, key) return root } // 情况 1 : 以下两个 if 已经处理 if root.Left == nil { // 情况 2 左 return root.Right } if root.Right == nil { // 情况 2 右 return root.Left } // 情况 3 ： 使用右子树最小元素 minNode := root.Right for minNode.Left != nil { minNode = minNode.Left } root.Val = minNode.Val root.Right = deleteNode(root.Right, minNode.Val) return root} 平均检索长度 ASL比较次数：不大于树的深度 最坏平均查找长度 ASL：(n+1)/2 最好 ASL：$log2(n)$ (参考二分查找) 所有操作的复杂度都是 $O(logn)$","link":"/Data-structure/Binary-Search-Tree/"},{"title":"二叉树遍历","text":"二叉树遍历主要包括： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 参考： 代码随想录 (programmercarl.com) 1、递归遍历递归三要素： 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 前序遍历即 根-左-右 1234567891011121314func preorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var preOrder func(root *TreeNode) preOrder = func(root *TreeNode) { if root == nil { return } ans = append(ans, root.Val) preOrder(root.Left) preOrder(root.Right) } preOrder(root) return ans} 中序遍历即 左-根-右 1234567891011121314func inorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var inOrder func(root *TreeNode) inOrder = func(root *TreeNode) { if root == nil { return } inOrder(root.Left) ans = append(ans, root.Val) inOrder(root.Right) } inOrder(root) return ans} 后序遍历即 左-右-根 1234567891011121314func postorderTraversal(root *TreeNode) []int { ans := make([]int, 0) var postorder func(root *TreeNode) postorder = func(root *TreeNode) { if root == nil { return } postorder(root.Left) postorder(root.Right) ans = append(ans, root.Val) } postorder(root) return ans} 2、迭代遍历要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 通过这种标记法实现二叉树的统一迭代遍历。 前序遍历12345678910111213141516171819202122232425262728func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } stack.PushBack(node) // 根 stack.PushBack(nil) } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 中序遍历12345678910111213141516171819202122232425262728func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 if node.Right != nil { stack.PushBack(node.Right) // 右 } stack.PushBack(node) // 根 stack.PushBack(nil) if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 后序遍历12345678910111213141516171819202122232425262728func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := make([]int, 0) stack := list.New() stack.PushBack(root) var node *TreeNode for stack.Len() &gt; 0 { back := stack.Back() stack.Remove(back) if back.Value != nil { node = back.Value.(*TreeNode) // interface 为 nil 无法 断言类型转换 stack.PushBack(node) // 根 stack.PushBack(nil) if node.Right != nil { stack.PushBack(node.Right) // 右 } if node.Left != nil { stack.PushBack(node.Left) // 左 } } else { node = stack.Remove(stack.Back()).(*TreeNode) ans = append(ans, node.Val) } } return ans} 3、层序遍历12345678910111213141516171819202122232425func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := list.New() queue.PushBack(root) t := make([]int, 0) for queue.Len() &gt; 0 { l := queue.Len() for i := 0; i &lt; l; i++ { node := queue.Remove(queue.Front()).(*TreeNode) t = append(t, node.Val) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } } ans = append(ans, t) t = []int{} } return ans}","link":"/Algorithm/Binary-Tree-Traversal/"},{"title":"Binary Search 二分查找","text":"二分查找也称折半查找，它是一种效率较高的查找方法。 前提数组为有序数组，数组中无重复元素。 因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。 二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。 到底是 while(left &lt; right) 还是 while(left &lt;= right)？ 到底是right = middle呢，还是要right = middle - 1呢？ 区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 写法1、左闭右闭定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码： 12345678910111213int search(vector&lt;int&gt;&amp; nums, int target) { // 左闭右闭 int left = 0, right = nums.size() - 1; while (left &lt;= right) { int middle = left + ((right - left) &gt;&gt; 1); // 防止溢出 if (nums[middle] &gt; target) right = middle - 1; else if (nums[middle] &lt; target) left = middle + 1; else return middle; } return -1;} Go 1234567891011121314func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left &lt;= right { middle := left + (right-left)&gt;&gt;1 if nums[middle] &gt; target { right = middle - 1 } else if nums[middle] &lt; target { left = middle + 1 } else { return middle } } return -1} 2、左闭右开定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 代码： 12345678910111213141516int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size(); // 左闭右开 while (left &lt; right) { // left == right在[left, right)是无效的空间 int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) { right = middle; // target 在左区间，在[left, middle)中 } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，在[middle + 1, right)中 } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1;}","link":"/Algorithm/Binary-Search/"},{"title":"位运算","text":"计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。 位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。 上述位运算中，只有取反是一元运算，其余的都是二元运算。 参考：位运算符的概念和性质 1、与、或、异或和取反 与运算的符号是 $\\And$ ，运算规则是：全 1 为 1，有 0 为 0 或运算的符号是 $∣$ ，运算规则是：有 1 为 1，全 0 为 0 异或运算的符号是 $\\oplus$（在代码中用 $\\wedge$ 表示异或），运算规则是：相同为 0 ，不同为 1 取反运算的符号是 $\\sim$，运算规则是：0 变 1， 1 变 0 2、移位运算移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。 左移运算的符号是 $&lt;&lt;$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。 右移运算的符号是 $&gt;&gt;$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定： 算术右移时，高位补最高位； 逻辑右移时，高位补 0。 C++ 中：对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。Java 中：不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。算术右移的符号是 $&gt;&gt;$，逻辑右移的符号是 $&gt;&gt;&gt;$Go 中：只有算数移位 3、位运算与乘除法使用移位运算实现乘除法的效率显著高于直接乘除法的效率。 左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$ 例如，$29 &lt;&lt; 2 = 116$，等价于 $ 29 \\times 4 $ 当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和： 例如，$a \\times 6$ 等价于 $(a&lt;&lt;2)+(a&lt;&lt;1)$ 对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。 算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$ 例如，$50 &gt;&gt; 2 = 12$ ，等价于 $50 / 4$，结果向下取整 一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是不等价的（只对0和正数成立） 同时，位运算也能用来替代取模运算判断奇偶： 奇数：$整数&amp;1==1$（二进制最低位是1，就是奇数 偶数：$整数&amp;1==0$（二进制最低位是0，就是偶数 4、位运算性质此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。 幂等律：$a \\And a = a$ ，$a ∣ a=a$ （注意异或不满足幂等律） 交换律：$a \\And b = b \\And a$，$a ∣ b = b ∣ a$，$a \\oplus b = b \\oplus a$ 结合律：$(a \\And b) \\And c = a \\And (b \\And c)$，$(a ∣ b) ∣ c = a ∣ (b ∣ c)$，$(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$ 分配律：$(a \\And b) ∣ c = (a ∣ c) \\And (b ∣ c)$，$(a ∣ b) \\And c = (a \\And c) ∣ (b \\And c)$，$(a ⊕ b) \\And c = (a \\And c) ⊕ (b \\And c)$ 德·摩根律：$\\sim (a \\And b) = ( \\sim a) ∣ (\\sim b)$ ，$\\sim(a ∣ b) = (\\sim a) \\And (\\sim b)$ 取反运算性质：$-1 = \\sim 0，-a = \\sim (a-1)$ 与运算性质：$a \\And 0 = 0$，$a \\And (-1) = a$，$a \\And (\\sim a) = 0$ 或运算性质：$a ∣ 0 = a$，$a ∣ (\\sim a) = -1$ 异或运算性质：$a \\oplus 0 = a$，$a \\oplus a = 0$ 其他性质： $a \\And (a-1)$ 的结果：将 a 的二进制表示的最后一个 1 变成 0 $a \\And (-a)$（与 $a \\And (\\sim (a-1))$ 等价）的结果：只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0","link":"/Knowledge/Bit-Operation/"},{"title":"常见容器底层","text":"各种语言下，常见容器底层整理。 参考： C++ STL容器底层数据结构总结 - 简书 (jianshu.com) C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com) 1、C++vector其底层数据结构是数组，由于能动态扩容，所以也称动态数组 特点： 随机访问：$O(1)$ 随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删 扩容规则： 新建时初始化一片空间 插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据 释放原来空间 在进行迭代器相关的修改操作时（包括扩容），所有迭代器和指针引用都会失效 map &amp; multimap &amp; set &amp; multisetmap提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。 与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。 底层数据结构均为红黑树，可以参考[教你透彻了解红黑树](The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com))。 特点： 访问、查找、删除：$O(logn)$ unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset顾名思义，以上容器是无序的，所以底层实现为哈希表，因此其查找时间复杂度理论上达到了O(n) 特点： 访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题 2、GoGo 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现 map底层数据结构是哈希表 特点： 访问、查找、删除：$O(1)$","link":"/Data-structure/Common-Container/"},{"title":"数据库","text":"数据库（Database） 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 数据库管理系统（DataBase- Management System，DBMS） 创建和操纵的容器。 DBMS 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。 参考： 数据库知识手册 1、概念数据库有两种类型，分别是 关系型数据库 和 非关系型数据库。 数据库类型 定义 优点 缺点 常见 关系型数据库 建立在关系模型基础上，由多张能互相连接的 表 组成的数据库 使用表结构，格式一致，易于维护； 使用 SQL 语句，可用于复杂查询； 数据存储在磁盘中，安全性高 读写性能比较差； 建立在关系模型上，不可避免空间浪费； 固定的表结构，灵活度较低 MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等 非关系型数据库 非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 对象 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛； 可轻松进行海量数据的维护和处理； 具有可扩展、高并发、高稳定性、成本低的优势； 可以实现数据的分布式处理 不提供 SQL 支持； 无事务处理，无法保证数据的完整性和安全性； 功能没有关系型数据库完善 Neo4j，Redis，MongoDB 等 SQL 是 结构化查询语言（Structured Query Language） 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。 MySQL 是一个 关系数据库管理系统（RDBMS），使用 SQL 执行所有数据库操作。 函数依赖 部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB 完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB 传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A 范式数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。 常用的数据库三大范式为： 第一范式（1NF）：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。关系模式的基本要求 第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。消除部分依赖 第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。消除传递依赖 2、索引索引是一种 数据结构。数据库索引是 DBMS 中一个 排序的数据结构，以 协助快速查询、更新 数据库表中数据。 索引的实现通常使用 B 树以及变种 B+ 树。 以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。 优点 缺点 通过创建 唯一性索引 ，可以保证数据库表中每一行数据的唯一性； 可以加快数据的 检索速度 ，这也是创建索引的主要原因； 可以加速表和表之间的连接，特别是在实现 数据的参考完整性 方面特别有意义； 通过使用索引，可以在查询的过程中，使用 优化隐藏器 ，提高系统性能。 时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度； 空间上，索引需要占 物理空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 索引分类数据库索引根据结构分类，主要有 B 树索引（使用最频繁）、Hash 索引 和 位图索引 三种。 关于 B 树可以参考：B Tree 使用 B+ 树的优点： 由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。 B+ 树的叶结点由一条链相连，因此当需要进行一次 全数据遍历 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 大于某个关键字或者小于某个关键字的数据 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。 Hash 索引和 B+ 树索引的区别： Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询； Hash 索引不支持使用索引进行排序； Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测； Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询； Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。 聚簇索引聚簇索引指将 数据存储 和 索引 放到一起，找到索引也就找到了数据。 3、事务数据库的 事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。 如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。 因此，事务是保持 逻辑数据一致性 和 可恢复性 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性 特性事务具有 4 个特性，通常简称为 ACID，关系型数据库 需要遵循 ACID 规则。 原子性（Atomicity） 事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。 以银行转账事务为例： 如果该事务提交了，则这两个账户的数据将会更新； 如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 撤销 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。 一致性（Consistency） 当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。 以银行转账事务事务为例： 在事务开始之前，所有 账户余额的总额处于一致状态。 在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。 因此，所有账户余额的总额处于不一致状态。 但是当事务完成以后，账户余额的总额再次恢复到一致状态。 隔离性（Isolation） 并发访问数据库 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。 修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。 持久性（Durability） 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 实现DBMS 采用 日志 来保证事务的 原子性、一致性 和 持久性。 日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。 DBMS 采用 锁机制 来实现事务的隔离性。 当多个事务同时更新数据库中相同的数据时，只允许 持有锁的事务 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。 相应的原理 原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql 一致性：一般由代码层面来保证 隔离性：由MVCC来保证 持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复 冲突 脏读（Dirty Read） 一个事务读取了另一个事务未提交的数据。 不可重复读（Non-repeatable Read） 就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。 幻读（Phantom Read） 幻读是指当事务 不是独立执行时 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 插入一行新数据。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。 丢失更新（Lost Update） 两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。 隔离级别SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 并发事务对同一资源的读取深度层次。 由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE） 隔离级别 读数据一致性 脏读 不可重复读 幻读 未提交(RU) 只能保证不读取物理上的损坏 √ √ √ 已提交(RC) 语句级 × √ √ 可重复读(RR) 事务级 × × √ 串行化(SR) 最高级别，事务级 × × × 4、锁从数据库系统的角度，锁模式可分为以下6 种类型： 共享锁（S）：又叫 他读锁。 可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。 排它锁（X）：又叫 独占锁、写锁。 对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。 更新锁（U）： 防止出现 死锁 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。 资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。 意向锁： 表示 SQL Server 需要在 层次结构中的某些底层资源上 获取共享锁或排它锁。 例如，放置在 表级 的 共享意向锁 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。 意向锁可以提高性能，因为 SQL Server 仅在 表级 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 架构锁： 在执行 依赖于表架构的操作 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。 大容量更新锁（BU）： 向表中大容量复制数据并指定了 TABLOCK 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。 关系 在 读取未提交 隔离级别下，读取数据不需要加 共享锁，这样就不会跟被修改的数据上的 排他锁 冲突； 在 读取已提交 隔离级别下，读操作需要加 共享锁，但是在语句执行完以后释放共享锁； 在 可重复读 隔离级别下，读操作需要加 共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁； 可串行化 是限制性最强的隔离级别，因为该级别 锁定整个范围的键，并一直持有锁，直到事务完成。 死锁死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 常见的解决死锁的方法 如果不同程序并发存取多个表，尽量约定 以相同的顺序访问表，可以大大降低死锁机会； 在同一个事务中，尽可能做到 一次锁定所需要的所有资源，减少死锁产生概率； 对于非常容易产生死锁的业务部分，可以尝试使用 升级锁定颗粒度，通过 表级锁 定来减少死锁产生的概率。 乐/悲观锁DBMS 中的 并发控制 的任务是确保在 多个事务同时存取数据库中同一数据 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 读多写少 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。","link":"/Database/Database-Introduction/"},{"title":"Go Module","text":"从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。 在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。 一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。 go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。 参考： 06｜构建模式：Go是怎么解决包依赖管理问题的？ (geekbang.org) 1、Go Module 构建模式语义导入版本机制在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成 按照语义版本规范， 主版本号不同的两个版本是相互不兼容的； 在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本； 补丁版本号也不影响兼容性。 Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。 12345678910// 通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本// 假如这是 v1.x.x 版本import &quot;github.com/sirupsen/logrus&quot; // 如果要导入 v2.x.x 版本import &quot;github.com/sirupsen/logrus/v2&quot;// 甚至可以同时依赖一个包的两个不兼容版本import ( &quot;github.com/sirupsen/logrus&quot; logv2 &quot;github.com/sirupsen/logrus/v2&quot;) Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径 最小版本选择原则依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？ 当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。 不过，Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本” 这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。 2、Go module 版本管理（1）Go Module 创建创建一个 Go Module，通常有如下几个步骤： 通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module； 通过 go mod tidy 命令自动更新当前 module 的依赖信息； 执行 go build，执行新 module 的构建。 （2）为当前 module 添加一个依赖12345# 手动添加$ go get github.com/google/uuid# 自动添加$ go mod tidy （3）升级 / 降级依赖的版本12# 选定指定版本即可$go get github.com/sirupsen/logrus@v1.7.0 （4）移除一个依赖仅从源码中删除对依赖项的导入语句还不够，还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。 go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。 （5）vendorvendor 机制可以对 vendor 目录下缓存的依赖包进行自动管理。 在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非 go build 传入 -mod=mod 的参数。 12345678910$go mod vendor$tree -LF 2 vendorvendor├── github.com/│ ├── google/│ ├── magefile/│ └── sirupsen/├── golang.org/│ └── x/└── modules.txt 3、空导入像下面代码这样的包导入方式被称为“空导入”：import _ &quot;foo&quot; 空导入也是导入，意味着我们将依赖foo这个路径下的包。 由于是空导入，我们并没有显式使用这个包中的任何语法元素。 通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。","link":"/Language/Go-Module/"},{"title":"Gradle——Android Build 构建配置","text":"Android 构建系统会编译应用资源和源代码，然后将它们打包到 APK 或 Android App Bundle 中，供测试、部署、签名和分发。Android Studio 会使用高级构建工具包 Gradle 自动执行和管理构建流程，同时也允许定义灵活的自定义 build 配置。 参考: 配置 build | Android 开发者 | Android Developers 史上最全Android build.gradle配置详解，你懂的！ - 掘金 (juejin.cn) 1、构建流程典型 Android 应用模块的构建流程按照以下常规步骤执行： 编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。 打包器将 DEX 文件和编译后的资源组合成 APK 或 AAB（具体取决于所选的 build 目标）。 必须先为 APK 或 AAB 签名，然后才能将应用安装到 Android 设备或分发到 Google Play 等商店。 打包器使用调试或发布密钥库为 APK 或 AAB 签名： 1. 如果您构建的是调试版应用（即专门用来测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。 2. 如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库（您需要进行配置）为应用签名。如需创建发布密钥库，请参阅[在 Android Studio 中为应用签名](https://developer.android.com/studio/publish/app-signing#studio)。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。 构建流程结束时，您将获得应用的调试版或发布版 APK/AAB，以用于部署、测试或向外部用户发布。 2、配置文件1、Gradle 设置文件settings.gradle 文件位于项目的根目录下，用于指示 Gradle 在构建应用时应将哪些模块包含在内。 123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;hhuer&quot;include(&quot;:app&quot;) 2、项目 build 文件顶层 build.gradle 文件位于项目的根目录下，用于定义适用于项目中所有模块的构建配置。 默认情况下，顶层 build 文件使用 buildscript 代码块定义项目中所有模块共用的 Gradle 代码库和依赖项。 1234567891011121314151617buildscript { // gradle脚本执行所需依赖 repositories { // 配置远程仓库 google() // 引用google上的开源项目 mavenCentral() // 引用 jcenter上的开源项目，现已经替换为 mavenCenter } dependencies { // 配置构建工具 classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0-M1&quot;) }}// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 配置项目全局属性项目包含多个模块时，可以在文件中添加公用配置。 123456789101112buildscript {...}allprojects {...}// 使用mapextra[&quot;compileSdkVersion&quot;] = 28// You can also create properties to specify versions for dependencies.// Having consistent versions between modules can avoid conflicts with behavior.extra[&quot;supportLibVersion&quot;] = &quot;28.0.0&quot;// 或者使用 Kotlin 委托 https://www.runoob.com/kotlin/kotlin-delegated.htmlval compileSdkVersion by extra(31)val supportLibVersion by extra(&quot;28.0.0&quot;) 在模块中使用以下代码引用即可： 123val sdkVersion: Int by rootProject.extra...compileSdkVersion(sdkVersion) 注意：虽然 Gradle 可让您在模块级别定义项目全局属性，但您应避免这样做，因为这样会导致共享这些属性的模块相互结合。模块结合使得以后将模块作为独立项目导出更加困难，并实际妨碍 Gradle 利用并行项目执行加快多模块构建。 3、模块 build 文件模块级 build.gradle 文件位于每个 project/module/ 目录下，用于为其所在的特定模块配置构建设置。您可以通过配置这些 build 设置提供自定义打包选项（如额外的 build 类型和产品变种），以及替换 main/ 应用清单或顶层 build.gradle 文件中的设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}// 上面全局配置的引用val androidTargetSdkVersion: Int by rootProject.extra// 配置项目构建的各种属性android { compileSdk = androidCompileSdkVersion //设置编译时用的Android版本 ... defaultConfig { // app 相关 applicationId = defaultManagerPackageName // 包名 minSdk = androidMinSdkVersion // 最低兼容版本 targetSdk = androidTargetSdkVersion // 目标安卓版本 versionCode = verCode // 版本号 versionName = verName // 版本名称 //若使用AndroidJUnitRunner进行单元测试 //testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } //指定生成安装文件的主要配置，一般包含两个子闭包: //一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写； //另一个是release闭包，用于指定生成正式版安装文件的配置。 buildTypes { release { // 一般使用如下两项 isMinifyEnabled = false //是否对代码进行混淆 proguardFiles(&quot;proguard-rules.pro&quot;) //指定混淆的规则文件 } } compileOptions { sourceCompatibility(androidSourceCompatibility) targetCompatibility(androidTargetCompatibility) } kotlinOptions { jvmTarget = &quot;1.8&quot; } packagingOptions{//打包时的相关配置 //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' }}dependencies { // 项目的依赖 // Dependency on a local library module implementation project(&quot;:mylibrary&quot;) // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3' ...}configurations.all { exclude(group = &quot;androidx.appcompat&quot;, module = &quot;appcompat&quot;)} 4、更多模块配置项设置应用 ID添加构建依赖项Android Gradle 插件可以使用的原生依赖项优化构建速度排查构建性能问题分析构建性能配置 build 变体构建多个 APK合并多个清单文件将构建变量注入清单缩减、混淆处理和优化应用为方法数超过 64K 的应用启用 MultiDex 使用 APK 分析器分析您的 build使用 Maven Publish 插件Gradle 提示与诀窍将构建配置从 Groovy 迁移到 KTS 此部分可以参考 Gradle——从Groovy迁移到KTS - Sakurasou","link":"/Android/Gradle-Build/"},{"title":"Gradle——从Groovy迁移到KTS","text":"在Android Studio中将Gradle配置从 Groovy 迁移到 KTS，即用 Kotlin 代替 Groovy 编写Gradle脚本。 参考： 官方文档 将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers 知乎 快速迁移 Gradle 脚本至 KTS - 知乎 (zhihu.com) 1、转换规则 Groovy 允许使用单引号来定义字符串，而 Kotlin 则要求使用双引号： 即include ':app' -&gt; include &quot;:app&quot; // '(.*?[^\\\\])' 正则替换 &quot;$1&quot; 在 Groovy 中使用 $ 前缀来表示基于句点表达式的字符串插值，但在 Kotlin 中需要使用大括号括住整个变量： 即myRootDirectory = &quot;$project.rootDir/tools&quot; 改为：myRootDirectory = &quot;${project.rootDir}/tools&quot; 显式和隐式 buildTypes：在 KTS 中，仅 debug 和 release buildTypes 是隐式提供的，而 staging 则必须手动创建 12345678910buildTypes getByName(&quot;debug&quot;) { ... } getByName(&quot;release&quot;) { ... } create(&quot;staging&quot;) { ... } 使用 plugins 代码块：给方法调用加上括号 1234567// (\\w+) (([^=\\{\\s]+)(.*)) 正则替换 $1($2)plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;) id(&quot;kotlin-kapt&quot;) id(&quot;androidx.navigation.safeargs.kotlin&quot;)} 更多请参考 Gradle | Kotlin (kotlinlang.org) 2、逐个迁移按上述转换规则逐个迁移以下文件，每迁移一个文件，都 sync 一遍查看是否出现问题。 下列每个迁移前，先把文件扩展名添加为 *.gradle.kts 1、迁移 setting.gradle123456789dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() }}rootProject.name = &quot;your app name&quot;include(&quot;:app&quot;) 2、迁移项目的 build.gradle1234567891011121314buildscript { repositories { google() mavenCentral() } dependencies { classpath(&quot;com.android.tools.build:gradle:7.0.2&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20&quot;) }}tasks.register(&quot;Delete&quot;, Delete::class) { delete(rootProject.buildDir)} 3、迁移模块的 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142plugins { id(&quot;com.android.application&quot;) id(&quot;kotlin-android&quot;)}android { compileSdk = 30 defaultConfig { applicationId = &quot;github.sukieva.hhuer&quot; minSdk = 24 targetSdk = 30 versionCode = 1 versionName = &quot;1.0&quot; } buildTypes { release { isMinifyEnabled = false proguardFiles(&quot;proguard-rules.pro&quot;) } } compileOptions { sourceCompatibility(JavaVersion.VERSION_1_8) targetCompatibility(JavaVersion.VERSION_1_8) } kotlinOptions { jvmTarget = &quot;1.8&quot; }}dependencies { implementation(&quot;androidx.core:core-ktx:1.6.0&quot;) implementation(&quot;androidx.appcompat:appcompat:1.3.1&quot;) implementation(&quot;com.google.android.material:material:1.4.0&quot;) implementation(&quot;androidx.constraintlayout:constraintlayout:2.1.0&quot;) testImplementation(&quot;junit:junit:4.+&quot;) androidTestImplementation(&quot;androidx.test.ext:junit:1.1.3&quot;) androidTestImplementation(&quot;androidx.test.espresso:espresso-core:3.4.0&quot;)} 3、代码优化可以在项目的build.gradle.kts里添加定义属性，在其他配置文件可直接访问。 12345678910val defaultManagerPackageName by extra(&quot;github.sukieva.hhuer&quot;)val verCode by extra(20210924)val verName by extra(&quot;1.0&quot;)val androidTargetSdkVersion by extra(31)val androidMinSdkVersion by extra(27)val androidBuildToolsVersion by extra(&quot;31.0.0&quot;)val androidCompileSdkVersion by extra(31)val androidCompileNdkVersion by extra(&quot;23.0.7599858&quot;)val androidSourceCompatibility by extra(JavaVersion.VERSION_11)val androidTargetCompatibility by extra(JavaVersion.VERSION_11) 3、可能出现的问题1、code insight unavailable因为期间重启过几次Android Studio不太确定怎么排除的，可能切换kotlin到dev版能解决此问题。","link":"/Android/Gradle-Gradle2kts/"},{"title":"哈希内部","text":"哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。 1、散列基本概念散列： 碰撞： 散列函数： 除余法： 例子： m=16*2=32 p=31 散列函数 h(key)=key%p 线性勘察法（开地址法处理碰撞） 例子： 已知n个关键码具有相同的散列值d，若采用线性探查法解决碰撞，则在散列这n个关键码的过程中，共将要发生n(n-1)/2 次碰撞 拉链法解决碰撞 例子： 平均查找长度ASL： 2、常见的三种哈希结构 参考： 哈希表理论基础 当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set（集合） map（映射） 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(logn) O(logn) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表 std::set 和std::multiset 的底层实现是红黑树 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(logn) O(logn) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表 std::map 和std::multimap 的底层实现是红黑树 使用时： 解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的 如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 java里的HashMap ，TreeMap 都是一样的原理。 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。 一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？ 实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。","link":"/Data-structure/Hash-Insider/"},{"title":"Jetpack——Compose","text":"使用 JetpackCompose 的一些笔记。 关键术语 - 组合：Jetpack Compose 在执行可组合项时构建的界面描述。 初始组合：通过首次运行可组合项创建组合。 重组：在数据发生变化时重新运行可组合项以更新组合。 'Surface' A surface container using the 'background' color from the theme 'Divider' is a provided composable function that creates a horizontal divider. 可组合项中的状态可组合函数可以使用 remember 可组合项记住单个对象。 系统会在初始组合期间将由 remember 计算的值存储在组合中，并在重组期间返回存储的值。 remember 既可用于存储可变对象，又可用于存储不可变对象。 mutableStateOf会创建可观察的 MutableState 会创建可观察的 MutableState，后者是与 Compose 运行时集成的可观察类型。 在可组合项中声明 MutableState 对象的方法有三种（等价）： val mutableState = remember { mutableStateOf(default) } var value by remember { mutableStateOf(default) } val (value, setValue) = remember { mutableStateOf(default) } 1234567@Composablefun Counter() { val count = remember { mutableStateOf(0) } Button(onClick = { count.value++ }) { Text(&quot;I've been clicked ${count.value} times&quot;) }} Color primary：main brand color secondary：provide accents Typography","link":"/Android/Jetpack-Compose/"},{"title":"Jetpack——Lifecycle","text":"Lifecycle组件可以让任何一个类都能轻松感知到Activity的生命周期，同时不需要再Activity中编写太多额外的逻辑。 参考： Lifecycle | Android 开发者 | Android Developers Android官方架构组件:Lifecycle详解&amp;原理分析_却把清梅嗅的博客-CSDN博客_lifecycle原理 1、生命周期生命周期和状态事件如图所示： ## 2、Lifecycles 的最佳实践 一般在 ViewModel中观察和控制界面。 保持 UI 控制器（Activity 和 Fragment）尽可能的精简。它们不应该试图去获取它们所需的数据；相反，要用 ViewModel来获取，并且观察 LiveData将数据变化反映到视图中。 尝试编写数据驱动（data-driven）的 UI，即 UI 控制器的责任是在数据改变时更新视图或者将用户的操作通知给 ViewModel。 将数据逻辑放到 ViewModel 类中。ViewModel 应该作为 UI 控制器和应用程序其它部分的连接服务。注意：不是由 ViewModel 负责获取数据（例如：从网络获取）。相反，ViewModel 调用相应的组件获取数据，然后将数据获取结果提供给 UI 控制器。 使用Data Binding来保持视图和 UI 控制器之间的接口干净。这样可以让视图更具声明性，并且尽可能减少在 Activity 和 Fragment 中编写更新代码。如果你喜欢在 Java 中执行该操作，请使用像Butter Knife 这样的库来避免使用样板代码并进行更好的抽象化。 如果 UI 很复杂，可以考虑创建一个 Presenter 类来处理 UI 的修改。虽然通常这样做不是必要的，但可能会让 UI 更容易测试。 不要在 ViewModel 中引用View或者 Activity的 context。因为如果ViewModel存活的比 Activity 时间长（在配置更改的情况下），Activity 将会被泄漏并且无法被正确的回收。","link":"/Android/Jetpack-Lifecycle/"},{"title":"Language——Kotlin","text":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 用了Kotlin就不想回到Java，本文主要记录一些高级用法 参考： Android 上的 Kotlin 协程 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 更多细节可查看：基本语法 - Kotlin 语言中文站 (kotlincn.net) 1、基本知识区间 左闭右闭：0..10 左闭右开：0 unitil 10 (step 2) 降序（左闭右闭）：10 downto 1 类主构造函数12345class Examle(...){ init{ ... }} 次构造函数不常用，一般直接指定默认值 1234class Examle(...){ constructor(...) : this(...){} sonstructor() : this (...){}} 修饰符 public：（默认）对所有类可见 private：对当前类内部可见 protected：对当前类和子类可见 internal：对同一模块的类可见 数据类和单例类 数据类：data class，等同于 Java 中一长串的 bean 单例类：object，等同于 Java 中的单例模式（全局至多只有一个实例） Lambda简而言之，就是可以作为参数传递的代码。 太常用也太多了，写写就会了 2、标准函数只介绍最常用的3个 with一个非扩展函数：上下文对象作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（this）使用。 返回值是 lambda 表达式结果。 接收2个参数： 任意类型的对象 Lambda表达式 12345678910val result = with(obj){ // obj 上下文 &quot;value&quot; // with 返回值}val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)with(numbers) { println(&quot;'with' is called with argument $this&quot;) println(&quot;It contains $size elements&quot;)} run上下文对象 作为接收者（this）来访问。 返回值 是 lambda 表达式结果。 run 和 with 做同样的事情，但是调用方式和 let 一样——作为上下文对象的扩展函数. 当 lambda 表达式同时包含对象初始化和返回值的计算时，run 很有用。 12345678910val result = service.run { port = 8080 query(prepareRequest() + &quot; to port $port&quot;)}// 同样的代码如果用 let() 函数来写:val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)} apply上下文对象 作为接收者（this）来访问。 返回值 是上下文对象本身。 对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用 apply。apply 的常见情况是对象配置。这样的调用可以理解为“将以下赋值操作应用于对象”。 12345val adam = Person(&quot;Adam&quot;).apply { age = 32 city = &quot;London&quot; }println(adam) 函数选择为了选择合适的作用域函数，它们之间的主要区别表。 函数 对象引用 返回值 是否是扩展函数 let it Lambda 表达式结果 是 run this Lambda 表达式结果 是 run - Lambda 表达式结果 不是：调用无需上下文对象 with this Lambda 表达式结果 不是：把上下文对象当做参数 apply this 上下文对象 是 also it 上下文对象 是 3、拓展函数和运算符重载拓展函数基本格式： 123fun ClassName.methodName(pararm: Int):Int{ return 0} 例子： 123fun String.showToast(duration: Int = Toast.LENGTH_SHORT) { Toast.makeToast(MyApp.context, this, duration).show()} 运算符重载例子： 12345class Money(val value:Int){ operator fun plus(money:Money):Money{ return Money(value+money.value) }} 4、高阶函数和内联函数高阶函数如果一个函数接收另一个函数作为参数，或者韩非子的类型是另一个函数，则称之为高阶函数。 基本规则：() -&gt; Unit 例子如下，相当于能嵌套函数 123fun CardItem( onClick: () -&gt; Unit = {}) 内联函数高阶函数实现的 Lambda 表达式在底层被转换为匿名类，每次调用都会创建一个新的匿名类实例，造成额外开销 函数前添加inline可消除开销：inline fun example(){} 5、泛型和委托泛型一般编程模式下，需要给任何一个变量指定具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样的代码会有更好的拓展性。 泛型类： 12345678class MyClass&lt;T&gt;{ fun method(param: T): T{ return param }}val myClass = MyClass&lt;Int&gt;() // 指定 Int 泛型val result = myClass.method(123) // 得到 Int 返回值 泛型方法： 1234567891011class MyClass{ fun &lt;T&gt; method(param: T): T{ return param }}val myClass = MyClass()val result = myClass.method&lt;Int&gt;(123)// kotlin 可以自动识别val result = myClass.method(123) 范围： 可通过 &lt;T : Number&gt;的形式指定范围，此时只允许数字类型，字符串会报错 默认类型可空，即Any?，不想为空可改为Any 委托委托是一种设计模式，操作对象自己不会去处理某段逻辑，而是把工作委托给另外一个辅助对象处理。 类委托： 借助委托可以轻松自己实现类，以下通过Hashset自定义一个类：by是实现委托的关键字 1234class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet{ fun helloworld() = println(&quot;hello world&quot;) override fun isEmpty = false} 属性委托： 将一个属性（字段）的具体实现委托给另一个类去完成 1234567891011121314151617181920class MyClass{ val p by Delegate()}// 调用 p 时，自动调用 Delegate类的 getValue 方法，赋值时调用 setValue 方法// 以下是标准的实现class Delegate{ var propValue: Any? = null // 参数1: 指定该类的委托在什么类可以使用 // 参数2: Kotlin属性操作类，可用于获取各种属性相关的值 operator fun getValue(myClass: MyClass, prop: Kproperty&lt;*&gt;): Any?{ return propValue } operator fun setValue(myClass: MyClass, prop: Kproperty&lt;*&gt;, value: Any?): Any?{ propValue = value } } 泛型实化指定泛型的实际类型 inline fun &lt;reified T&gt; start(block: Intent.() -&gt; Unit = {}){} 此时就可以得到T::class.java类型： 1val intent = Intent(context, T::class.java) 泛型协变和逆变 Todo 6、协程可以理解为轻量级的线程，可以在单线程中模拟多线程效果，与线程不同点在于： 线程依靠操作系统调度实现不同线程切换 协程在编程语言层面实现不同协程切换，大大提高并发编程的运行效率 特点：协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的特点包括： 轻量：可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。 内存泄漏更少：使用结构化并发机制在一个作用域内执行多项操作。 内置取消支持：取消操作会自动在运行中的整个协程层次结构内传播。 Jetpack 集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。 作用域构建器Tips： delay()：让当前协程延迟指定时间再运行，会阻塞挂起函数，只会挂起当前协程，不会影响其他协程执行 suspend：将任意函数声明为挂起函数，挂起函数间可以互相调用 作用域 GlobalScope.launch{}：顶层协程（不建议用） runBlocking{}：作用域内所有代码和子协程没有全部执行完之前一直阻塞当前线程（测试用，生产可能有性能问题） launch：在作用域内创建多个协程 coroutineScope{}：继承外部协程作用域并创建一个子协程，配合suspend使用，和runBlocking类似，用于生产环境 123suspend fun printDot() = coroutineScope{ launch{}} 常用写法 123456val job = Job()val scope = CoroutineScope(job)scope.launch{ //...}job.cancel() // 取消作用域内所有协程 获取执行结果调用async后，代码立即执行，如果调用await()时还没执行完，则会阻塞当前协程，直到获得async执行结果 12345runBlocking{ val result = async{ 5+5 }.await()} withContext是一个挂起函数，可以理解为async的一种简化版写法： 12345runBlocking{ val result = withContext(Dispatchers.Default){ 5+5 }} 线程参数除了coroutineScope，其他函数都可以指定线程参数，withContext必须，其他可选 Dispatchers.Default：默认低并发线程策略 Dispatchers.IO：较高并发的线程策略 Dispatchers.Main：不会开启子线程，在 Android 主线程执行（只在安卓中使用） Android 中要求网络请求必须在线程执行，定义协程也不行","link":"/Language/Language-Kotlin/"},{"title":"Jetpack——ViewModel","text":"ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。 参考： ViewModel 概览 | Android 开发者 | Android Developers 《第一行代码 Android 第3版》 1、生命周期ViewModel的一个重要作用是帮助Activity分担部分工作，专门用来存放与界面相关的数据，减轻Activity负担。 另外，如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。而ViewModel的生命周期和Activity不同，只有Activity退出时才会跟着一起销毁。 ViewModel对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失： 对于 activity，是在 activity 完成时； 对于 fragment，是在 fragment 分离时。 通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel","link":"/Android/Jetpack-ViewModel/"},{"title":"Linux指令——系统管理","text":"Linux中常用的系统工作命令以及系统状态检测命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、常用系统工作命令echo ：在终端输出字符串或变量提取后的值命令描述：echo命令用于在终端输出字符串或变量提取后的值。 命令格式：echo [字符串 | $变量] 命令用法示例： 显示普通字符串 1echo &quot;Hello World&quot; 显示变量首先在shell环境中定义一个临时变量name，使用echo命令将变量name的值显示到终端。 12export name=&quot;Tom&quot;echo $name 显示结果定向至文件以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。 1echo &quot;This is a test text.&quot; &gt; test.txt 如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。 显示命令执行结果以下命令将会在终端显示当前的工作路径。 1echo `pwd` 注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。使用$(command)形式可以达到相同效果。 1echo $(pwd) date ：显示和设置系统的时间和日期命令描述：date命令用于显示和设置系统的时间和日期。 命令格式：date [选项] [+格式] 其中，时间格式的部分控制字符解释如下： 字符说明%a当地时间的星期名缩写（例如： 日，代表星期日）%A当地时间的星期名全称 （例如：星期日）%b当地时间的月名缩写 （例如：一，代表一月）%B当地时间的月名全称 （例如：一月）%c当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）%C世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）%d按月计的日期（例如：01）%D按月计的日期；等于%m/%d/%y%F完整日期格式，等价于 %Y-%m-%d%j按年计的日期（001-366）%p按年计的日期（001-366）%r当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）%R24 小时时间的时和分，等价于 %H:%M%s自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数%T时间，等于%H:%M:%S%U一年中的第几周，以周日为每星期第一天（00-53）%x当地时间下的日期描述 （例如：12/31/99）%X当地时间下的时间描述 （例如：23:13:48）%w一星期中的第几日（0-6），0 代表周一%W一年中的第几周，以周一为每星期第一天（00-53） 命令用法示例： 按照默认格式查看当前系统时间 1date 按照指定格式查看当前系统时间 1date &quot;+%Y-%m-%d %H:%M:%S&quot; 查看今天是当年中的第几天 1date &quot;+%j&quot; 将系统的当前时间设置为2020年02月20日20点20分20秒 1date -s &quot;20200220 20:20:20&quot; 校正系统时间，与网络时间同步a. 安装ntp校时工具 1yum -y install ntp b. 用ntpdate从时间服务器更新时间 1ntpdate time.nist.gov wget ：在终端中下载文件命令描述：在终端中下载文件。 命令格式：wget [参数] 下载地址 参数说明： 参数作用-b后台下载-P下载到指定目录-t最大重试次数-c断点续传-p下载页面内所有资源，包括图片、视频等-r递归下载 命令使用示例： 下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。 1wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png ps ：查看系统中的进程状态命令描述：ps命令用于查看系统中的进程状态。 命令格式：ps [参数] 命令参数说明： 参数作用-a显示现行终端机下的所有程序，包括其他用户的程序-u以用户为主的格式来显示程序状况-x显示没有控制终端的进程，同时显示各个命令的具体路径-e列出程序时，显示每个程序所使用的环境变量-f显示当前所有的进程-t指定终端机编号，并列出属于该终端机的程序的状况 命令使用示例： 1ps -ef | grep sshd top ：动态地监视进程活动与系统负载等信息命令描述：top命令动态地监视进程活动与系统负载等信息。 命令使用示例： 1top 命令输出参数解释： 以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。 统计信息区 第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。 第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。 进程信息区&lt;table&gt; &lt;caption&gt;&lt;/caption&gt;&lt;colgroup&gt;&lt;col&gt;&lt;col&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th data-spm-anchor-id=&quot;a2c6h.13858378.0.i35.25da70089Mos0m&quot;&gt;列名&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PID&lt;/td&gt;&lt;td&gt;进程ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USER&lt;/td&gt;&lt;td&gt;进程所有者的用户名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PR&lt;/td&gt;&lt;td&gt;进程优先级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NI&lt;/td&gt;&lt;td&gt;nice值。负值表示高优先级，正值表示低优先级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VIRT&lt;/td&gt;&lt;td&gt;进程使用的虚拟内存总量，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RES&lt;/td&gt;&lt;td&gt;进程使用的、未被换出的物理内存大小，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SHR&lt;/td&gt;&lt;td data-spm-anchor-id=&quot;a2c6h.13858378.0.i34.25da70089Mos0m&quot;&gt;共享内存大小，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;进程状态&lt;ul&gt;&lt;li&gt;D：不可中断的睡眠状态&lt;/li&gt;&lt;li&gt;R：正在运行&lt;/li&gt;&lt;li&gt;S：睡眠&lt;/li&gt;&lt;li&gt;T：停止&lt;/li&gt;&lt;li&gt;Z：僵尸进程&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%CPU&lt;/td&gt;&lt;td&gt;上次更新到现在的CPU时间占用百分比&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%MEM&lt;/td&gt;&lt;td&gt;进程使用的物理内存百分比&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME+&lt;/td&gt;&lt;td&gt;进程使用的CPU时间总计，单位1/100秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;COMMAND&lt;/td&gt;&lt;td&gt;命令名&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; &lt;/table&gt; 按 q 键退出监控页面。 pidof ：查询指定服务进程的PID值命令描述：pidof命令用于查询指定服务进程的PID值。 命令格式：pidof [服务名称] 命令参数说明： 参数说明-s仅返回一个进程号-c只显示运行在root目录下的进程，这个选项只对root用户有效-o忽略指定进程号的进程-x显示由脚本开启的进程 命令使用示例： 查询出crond服务下的所有进程ID。 1pidof crond kill ：终止指定PID的服务进程命令描述：kill命令用于终止指定PID的服务进程。 kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。 命令格式：kill [参数] [进程PID] 命令使用示例： 删除pid为1247的进程。 1kill -9 1247 killall ：终止指定名称的服务对应的全部进程命令描述：killall命令用于终止指定名称的服务对应的全部进程。 命令格式：killall [进程名称] 命令使用示例： 删除crond服务下的所有进程。 1killall crond reboot ：重启系统命令描述：reboot命令用来重启系统。 命令格式：reboot [-n] [-w] [-d] [-f] [-i] 命令参数说明： -n：保存数据后再重新启动系统。 -w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。 -d：重新启动时不把数据写入记录文件/var/tmp/wtmp。 -f：强制重新开机，不调用shutdown指令的功能。 -i：关闭网络设置之后再重新启动系统。 命令使用示例： 1reboot poweroff ：关闭系统命令描述：poweroff命令用来关闭系统。 命令使用示例： 1poweroff 2、系统状态检测命令ifconfig ：获取网卡配置与网络状态等信息命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。 命令示例： 命令输出说明： 第一部分的第一行显示网卡状态信息。 eth0表示第一块网卡。 UP代表网卡开启状态。 RUNNING代表网卡的网线被接上。 MULTICAST表示支持组播。 第二行显示网卡的网络信息。 inet（IP地址）：172.16.132.195。 broadcast（广播地址）：172.16.143.255。 netmask（掩码地址）：255.255.240.0。 RX表示接收数据包的情况，TX表示发送数据包的情况。 lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。 uname ：查看系统内核与系统版本等信息命令描述：uname命令用于查看系统内核与系统版本等信息。 命令语法：uname [-amnrsv][--help][--version] 命令使用示例： 显示系统信息。 1uname -a 显示当前系统的硬件架构。 1uname -i 显示操作系统发行编号。 1uname -r 显示操作系统名称。 1uname -s 显示主机名称。 1uname -n uptime ：查看系统的负载信息命令描述：uptime 用于查看系统的负载信息。 命令使用示例：命令输出说明： 负载信息命令输出值当前服务器时间14:20:27当前服务器运行时长2 min当前用户数2 users当前负载情况load average: 0.03, 0.04, 0.02（分别取1min，5min，15min的均值） free ：显示当前系统中内存的使用量信息命令描述：free用于显示当前系统中内存的使用量信息。 命令语法：free [-bkmotV][-s &lt;间隔秒数&gt;] 命令参数说明： 参数说明-b以Byte为单位显示内存使用情况-k以KB为单位显示内存使用情况-m以MB为单位显示内存使用情况-h以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。 命令使用示例：命令输出说明： 参数说明total物理内存总数used已经使用的内存数free空间的内存数share多个进程共享的内存总额buff/cache应用使用内存数available可用的内存数Swap虚拟内存（阿里云ECS服务器默认不开启虚拟内存） who ：显示关于当前在本地系统上的所有用户的信息命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。 命令使用示例： 显示当前登录系统的用户 1who 显示用户登录来源 1who -l -H 只显示当前用户 1who -m -H 精简模式显示 1who -q last ：显示用户最近登录信息命令描述： last 命令用于显示用户最近登录信息。 1last history ：显示历史执行过的命令命令描述：history命令用于显示历史执行过的命令。 bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。 命令使用示例： 显示最新10条执行过的命令。 1history 10 清除历史记录。 1history -c","link":"/Linux/Linux-System-Management/"},{"title":"Linux指令——文本处理","text":"如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文本编辑工具Vimvim的三种操作模式： 命令模式（Command mode） 输入模式（Insert mode） 底线命令模式（Last line mode） 三种模式切换快捷键： 模式 快捷键 命令模式 ESC 输入模式 i或a 底线命令模式 : 命令模式在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。 使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。 以下是在命令模式中常用的快捷操作： 操作快捷键光标左移h光标右移l（小写L）光标上移k光标下移j光标移动到下一个单词w光标移动到上一个单词b移动游标到第n行nG移动游标到第一行gg移动游标到最后一行G快速回到上一次光标所在位置Ctrl+o删除当前字符x删除前一个字符X删除整行dd删除一个单词dw或daw删除至行尾d$或D删除至行首d^删除到文档末尾dG删除至文档首部d1G删除n行ndd删除n个连续字符nx将光标所在位置字母变成大写或小写~复制游标所在的整行yy（3yy表示复制3行）粘贴至光标后（下）p粘贴至光标前（上）P剪切dd交换上下行ddp替换整行，即删除游标所在行并进入插入模式cc撤销一次或n次操作u{n}撤销当前行的所有修改U恢复撤销操作Ctrl+r整行将向右缩进&gt;&gt;整行将向左退回&lt;&lt;若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开ZZ 输入模式在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。 底线命令模式在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。 以下是底线命令模式中常用的快捷操作： 操作命令保存:w退出:q保存并退出:wq（:wq!表示强制保存退出）将文件另存为其他文件名:w new_filename显示行号:set nu取消行号:set nonu使本行内容居中:ce使本行文本靠右:ri使本行内容靠左:le向光标之下寻找一个名称为word的字符串:/word向光标之上寻找一个字符串名称为word的字符串:?word重复前一个搜寻的动作:n从第一行到最后一行寻找word1字符串，并将该字符串取代为word2:1,$s/word1/word2/g 或 &nbsp;:%s/word1/word2/g 2、文本文件查看命令cat ：查看内容较少的纯文本文件命令描述：cat命令用于查看内容较少的纯文本文件。 命令格式：cat [选项] [文件] 命令参数说明： 参数说明-n或--number显示行号-b或--number-nonblank显示行号，但是不对空白行进行编号-s或--squeeze-blank当遇到有连续两行以上的空白行，只显示一行的空白行 more ：从前向后分页显示文件内容命令描述：more命令从前向后分页显示文件内容。 常用操作命令： 操作作用Enter向下n行，n需要定义，默认为1行Ctrl+F或空格键（Space）向下滚动一页Ctrl+B向上滚动一页=输出当前行的行号!命令调用Shell执行命令q退出more less ：对文件或其它输出进行分页显示命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。 命令格式：less [参数] 文件 命令参数说明： 参数说明-e当文件显示结束后，自动离开-m显示类似more命令的百分比-N显示每行的行号-s显示连续空行为一行 命令常用操作： 快捷键说明/字符串向下搜索字符串?字符串向上搜索字符串n重复前一个搜索N反向重复前一个搜索b或pageup键向上翻一页空格键或pagedown键向下翻一页u向前翻半页d向后翻半页y向前滚动一行回车键向后滚动一行q退出less命令 命令使用示例： 查看命令历史使用记录并通过less分页显示。 1history | less head ：查看文件开头指定行数的内容命令描述：head命令用于查看文件开头指定行数的内容。 命令格式：head [参数] [文件] 命令参数说明： 参数说明-n [行数]显示开头指定行的文件内容，默认为10-c [字符数]显示开头指定个数的字符数-q不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名 命令使用示例： 查看/etc/passwd文件的前5行内容。 1head -5 /etc/passwd tail ：查看文档的后N行或持续刷新内容命令描述：tail命令用于查看文档的后N行或持续刷新内容。 命令格式：tail [参数] [文件] 命令参数说明： 参数说明-f显示文件最新追加的内容-q当有多个文件参数时，不输出各个文件名-v当有多个文件参数时，总是输出各个文件名-c [字节数]显示文件的尾部n个字节内容-n [行数]显示文件的尾部n行内容 命令使用示例： 查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。 1tail -f -n 10 /var/log/messages stat ：显示文件的详细信息命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。 命令使用示例： 查看/etc/passwd文件的详细信息。 1stat /etc/passwd wc ：统计指定文本的行数、字数、字节数命令描述：wc命令用于统计指定文本的行数、字数、字节数。 命令格式：wc [参数] [文件] 命令参数说明： 参数说明-l只显示行数-w只显示单词数-c只显示字节数 命令使用示例： 统计/etc/passwd文件的行数。 1wc -l /etc/passwd file ：辨识文件类型命令描述： file命令用于辨识文件类型。 命令格式：file [参数] [文件] 命令参数说明： 参数说明-b列出辨识结果时，不显示文件名称-c详细显示指令执行过程，便于排错或分析程序执行的情形-f [文件]指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称-L直接显示符号连接所指向的文件类别 命令使用示例： 查看/var/log/messages文件的文件类型。 1file /var/log/messages diff ：比较文件的差异命令描述：diff命令用于比较文件的差异。 命令格式：diff [文件] [文件] 3、文本处理命令grep ：查找文件里符合条件的字符串命令描述：grep命令用于查找文件里符合条件的字符串。 grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。 在Shell脚本中，grep通过返回一个状态值来表示搜索的状态： 0：匹配成功。 1：匹配失败。 2：搜索的文件不存在。 命令格式：grep [参数] [正则表达式] [文件] 命令常用参数说明： 参数说明-c或--count计算符合样式的列数-d recurse或-r指定要查找的是目录而非文件-e [范本样式]指定字符串做为查找文件内容的样式-E 或 --extended-regexp将样式为延伸的正则表达式来使用-F 或 --fixed-regexp将样式视为固定字符串的列表-G 或 --basic-regexp将样式视为普通的表示法来使用-i 或 --ignore-case忽略字符大小写的差别-n 或 --line-number在显示符合样式的那一行之前，标示出该行的列数编号-v 或 --revert-match显示不包含匹配文本的所有行 命令使用示例： 查看sshd服务配置文件中监听端口配置所在行编号。 1grep -n Port /etc/ssh/ssh_config 查询字符串在文本中出现的行数。 1grep -c localhost /etc/hosts 反向查找，不显示符合条件的行。 12ps -ef | grep sshdps -ef | grep -v grep | grep sshd 以递归的方式查找目录下含有关键字的文件。 1grep -r *.sh /etc 使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。 1grep 'ntp[0-9].aliyun.com' /etc/ntp.conf sed ：文本处理命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。 处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。 接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。 接着处理下一行，这样不断重复，直到文件末尾。 注意： sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。如果要改变源文件，需要使用-i选项。命令格式：sed [参数] [动作] [文件] 参数说明： 参数说明-e [script]执行多个script-f [script文件]执行指定script文件-n仅显示script处理后的结果-i输出到原文件，静默执行（修改原文件） 动作说明： 动作说明a在行后面增加内容c替换行d删除行i在行前面插入p打印相关的行s替换内容 命令使用示例： 删除第3行到最后一行内容。 1sed '3,$d' /etc/passwd 在最后一行新增行。 1sed '$a admin:x:1000:1000:admin:/home/admin:/bin/bash' /etc/passwd 替换内容。 1sed 's/SELINUX=disabled/SELINUX=enforcing/' /etc/selinux/config 替换行。 1sed '1c abcdefg' /etc/passwd awk ：文本处理命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。 命令格式：awk [参数] [脚本] [文件] 参数说明： 参数说明-F fs指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符-f file读取awk脚本-v val=val在执行处理过程之前，设置一个变量var，并给其设置初始值为val 内置变量： 变量用途FS字段分隔符$n指定分隔的第n个字段，如$1、$3分别表示第1、第三列$0当前读入的整行文本内容NF记录当前处理行的字段个数（列数）NR记录当前已读入的行数FNR当前行在源文件中的行号 awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。 和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。 命令使用示例： 查看本机IP地址。 1ifconfig eth0 |awk '/inet/{print $2}' 查看本机剩余磁盘容量。 1df -h |awk '/\\/$/{print $4}' 统计系统用户个数。 1awk -F: '$3&lt;1000{x++} END{print x}' /etc/passwd 输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。 1awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd 输出/etc/passwd文件中前三行记录的用户名和用户uid。 1head -3 /etc/passwd | awk 'BEGIN{FS=&quot;:&quot;;print &quot;name\\tuid&quot;}{print $1,&quot;\\t&quot;$3}END{print &quot;sum lines &quot;NR}' 查看tcp连接数。 1netstat -na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 关闭指定服务的所有的进程。 1ps -ef | grep httpd | awk {'print $2'} | xargs kill -9 cut ：切割字符串命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。 命令格式：cut [参数] [文件] 参数说明： 参数说明-b以字节为单位进行分割-c以字符为单位进行分割-d自定义分隔符，默认为制表符 tr ：对来自标准输入的字符进行替换、压缩和删除命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。 命令格式：tr [参数] [文本] 参数说明： 参数说明-c反选指定字符-d删除指定字符-s将重复的字符缩减成一个字符-t [第一字符集] [第二字符集]删除第一字符集较第二字符集多出的字符，使两个字符集长度相等 命令使用示例： 将输入字符由大写转换为小写。 1echo &quot;HELLO WORLD&quot; | tr 'A-Z' 'a-z' 删除字符。 1echo &quot;hello 123 world 456&quot; | tr -d '0-9' 压缩字符。 1echo &quot;thissss is a text linnnnnnne.&quot; | tr -s ' sn' 产生随机密码。 1cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13","link":"/Linux/Linux-Text-Processing/"},{"title":"主流开源协议","text":"常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类： 宽松自由软件许可协议 Permissive free software licence 著佐权许可证 copyleft license 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 参考： 主流开源协议之间有何异同？ - 知乎 (zhihu.com) 如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com) 1、区别 Permissive free software licence ： 一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。 Copyleft License ： 在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。 两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。 其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。 2、常见开源许可证 MITMIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。 BSDBerkeley Software Distribution license BSD 许可证与 MIT 差不多。 事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。 可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。 ApacheApache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。 Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。 Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。 GPLGPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。 由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。 LGPL更宽松的GPL协议。 与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。 调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。","link":"/Mixed/Open-Source-License/"},{"title":"Linux指令——文件与权限","text":"Linux系统中常用的文件目录管理和文件权限管理命令。 以下所有内容都来自 https://developer.aliyun.com/，仅供自己学习用。 1、文件目录管理命令tree ：以树状图列出目录的内容命令描述：tree命令用于以树状图列出目录的内容。 tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装： 1yum install -y tree 命令使用示例： 1tree /usr/share/wallpapers/ ls ：显示指定工作目录下的内容注意是 L 的小写，不是大写 I 命令描述： ls命令用于显示指定工作目录下的内容。 命令格式：ls [参数] [目录名] 参数说明： 参数 说明 -a 显示所有文件及目录（包括隐藏文件） -l 将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l） -r 将文件反序列出（默认按英文字母正序） -t 将文件按创建时间正序列出 -R 递归遍历目录下文件 pwd ：获取当前工作目录的绝对路径命令描述：获取当前工作目录的绝对路径。 命令使用：pwd cd ：切换工作目录命令描述：cd命令用于切换工作目录。 在路径表示中： 一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。 两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。 cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。 touch ：修改文件或者目录的时间属性命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 命令格式：touch [参数] [文件] 参数说明： 参数 说明 -c 如果指定文件不存在，不会建立新文件 -r 使用参考文件的时间记录 -t 设置文件的时间记录 mkdir ：新建子目录命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。 命令使用示例： 1mkdir -p a/b/c rm ：删除一个文件或者目录命令描述：rm命令用于删除一个文件或者目录。 命令格式：rm [参数] [文件] 参数说明： 参数 说明 -i 删除前逐一询问确认 -f 无需确认，直接删除 -r 删除目录下所有文件 cp ：复制文件或目录命令描述： cp命令主要用于复制文件或目录。 命令格式：cp [参数] [源文件] [目标文件] 参数说明： 参数 说明 -d 复制时保留链接 -f 覆盖已经存在的目标文件而不给出提示 -i 覆盖前询问 -p 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中 -r 复制目录及目录内的所有项目 mv ：为文件或目录改名 / 将文件或目录移入其它位置命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 命令格式：mv [参数] [源文件] [目标文件] 参数说明： 参数 说明-i 若指定目录已有同名文件，则先询问是否覆盖旧文件-f 如果目标文件已经存在，不会询问而直接覆盖 rename ：批量改变文件名命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。 命令格式：rename [原值] [替换值] 2、文件权限管理ls命令可以查看Linux系统上的文件、目录和设备的权限。 1ls -l /boot/ 上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。 第1位表示存档类型，d表示目录，-表示一般文件。 第2~4位表示当前用户的权限（属主权限）。 第5~7位表示同用户组的用户权限（属组权限）。 第8~10位表示不同用户组的用户权限（其他用户权限）。 第11位是一个半角句号.，表示SELinux安全标签。 用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。 例如efi目录的root用户权限为drwxr-xr-x.。 该目录对root用户具有读写和执行所有权限。 该目录对root组其他用户有读和执行权限。 该目录对其他用户有读和执行权限。 所以该权限表示对应八进制权限表示为： 属主权限：4+2+1=7。 属组权限：4+1=5。 其他用户权限：4+1=5。 即755。 chmod ：修改文件权限chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。 将hello.sh文件增加属主的执行权限。 1chmod u+x hello.sh 将hello.sh文件撤销属主的执行权限。 1chmod u-x hello.sh 将hello.sh文件权限修改为八进制表示的744权限。 1chmod 744 hello.sh u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。 chown ：修改文件的属主和属组chown命令修改文件的属主和属组 -R参数以递归方式对子目录和文件进行修改 ls -l命令显示的第三列和第四列就是文件的属主和属组信息。 修改test.txt文件的属主用户为test。 1chown test test.txt 修改test.txt文件的属主和属组为admin。 1chown admin:admin test.txt chgrp ：修改文件的属组chgrp命令用于修改文件的属组。 命令使用示例： 将test.txt文件的属组改为root。 1chgrp root test.txt","link":"/Linux/Linux-Files-And-Permissions/"},{"title":"Queue","text":"与栈类似，队列是一种先进先出的容器适配器。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 1、定义 在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。 2、实现为了实现队列，我们可以使用动态数组和指向队列头部的索引。 简单的参考实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;class MyQueue { private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() {p_start = 0;} /** Insert an element into the queue. Return true if the operation is successful. */ bool enQueue(int x) { data.push_back(x); return true; } /** Delete an element from the queue. Return true if the operation is successful. */ bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; /** Get the front item from the queue. */ int Front() { return data[p_start]; }; /** Checks whether the queue is empty or not. */ bool isEmpty() { return p_start &gt;= data.size(); }};int main() { MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout &lt;&lt; q.Front() &lt;&lt; endl; }} 缺点上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。 所以应该规定数组的长度，一组一组队列的进行使用。","link":"/Data-structure/Queue/"},{"title":"Redis","text":"Redis (Remote Dictionary Server ) 远程字典服务，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。 Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。 和Memcached类似，它支持存储的value类型相对更多，包括： string（字符串） list（链表） set（集合） zset（sorted set 有序集合） hash（哈希类型） 与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。 参考：Redis 教程_w3cschoolRedis使用教程 - 掘金 1、简介Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 优势 性能极高 Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis 与其他 key-value 存储的区别 Redis 运行在内存中但是可以 持久化到磁盘，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。 Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。 Redis 和 MongoDB 的区别更多可见：NoSQL，浅谈redis与mongoDB的区别 - 知乎 性能方面，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB； 可操作性上，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 丰富的查询语言，操作比 Redis 更为便利； 内存及存储方面，MongoDB 适合 大数据量存储，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 虚拟内存特性，突破物理内存限制，数据可以设置时效性； 对于数据持久化和数据恢复，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能； 在数据一致性上，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行； 数据分析上，MongoDB 内置 数据分析功能（mapreduce），而 Redis 不支持数据分析； 应用场景不同，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。 数据类型Redis支持五种数据类型： string（字符串） hash（哈希） list（列表） set（集合） zset(sorted set：有序集合) string最基本的类型，一个key对应一个value。string类型是二进制安全的，即redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 一个键最大能存储512MB。 1234redis 127.0.0.1:6379&gt; set name &quot;sukiu.top&quot;OKredis 127.0.0.1:6379&gt; get name&quot;sukiu.top&quot; Redis 字符串(String)_w3cschool hashRedis hash 是一个键值 (key=&gt;value) 对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个 hash 可以存储 232 - 1键值对（40多亿）。 12345678910111213redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200OKredis 127.0.0.1:6379&gt; hgetall user:11) &quot;username&quot;2) &quot;sukiu.top&quot;3) &quot;password&quot;4) &quot;sukiu.top&quot;5) &quot;points&quot;6) &quot;200&quot;redis 127.0.0.1:6379&gt; hkeys user:11) &quot;username&quot;2) &quot;password&quot;3) &quot;points&quot; Redis 哈希(Hash)_w3cschool listRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 12345678910127.0.0.1:6379&gt; lpush test redis(integer) 1127.0.0.1:6379&gt; lpush test mongodb(integer) 2127.0.0.1:6379&gt; lpush test rabitmq(integer) 3127.0.0.1:6379&gt; lrange test 0 101) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis 列表(List)_w3cschool setRedis 的 Set是 string 类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 123456789101112127.0.0.1:6379&gt; sadd t1 redis(integer) 1127.0.0.1:6379&gt; sadd t1 mongodb(integer) 1127.0.0.1:6379&gt; sadd t1 rabitmq(integer) 1127.0.0.1:6379&gt; sadd t1 rabitmq(integer) 0127.0.0.1:6379&gt; smembers t11) &quot;rabitmq&quot;2) &quot;mongodb&quot;3) &quot;redis&quot; Redis 集合(Set)_w3cschool zset和 set 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 zset 的成员是唯一的,但分数(score)却可以重复。 123456789101112127.0.0.1:6379&gt; zadd t2 0 redis(integer) 1127.0.0.1:6379&gt; zadd t2 0 mongodb(integer) 1127.0.0.1:6379&gt; zadd t2 0 rabitmq(integer) 1127.0.0.1:6379&gt; zadd t2 0 rabitmq(integer) 0127.0.0.1:6379&gt; zrangebyscore t2 0 10001) &quot;mongodb&quot;2) &quot;rabitmq&quot;3) &quot;redis&quot; Redis 有序集合(sorted set)_w3cschool 2、高级持久化 更多：Redis专题：万字长文详解持久化原理 - SegmentFault 思否 Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。Redis支持两种方式的持久化：RDB快照和AOF。 RDBRDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。到目前为止，仍是官方的默认支持方案。 原理： Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。 优点: 适合大规模的数据恢复 对数据的完整性要不高 缺点： 需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了 fork进程的时候，会占用一定的内容空间 AOFAOF（Append Only File），它是Redis的完全持久化策略。 原理： 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。 123456# no-关闭，yes-开启，默认noappendonly yesappendfilename &quot;appendonTy.aof&quot; #持久化的文件的名字# appendfsync always #每次修改都会sync,消耗性能 appendfsync everysec #每秒执行一次sync,可能会丢失这1s的数据# appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快! 优点： 每一次修改都同步，文件的完整会更加好 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点： 相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢 Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 主从复制主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。 前者称为主节点(master/leader) 后者称为从节点(slavel/follower) 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。 默认情况下，每台Redis服务器都是主节点一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点 主从复制的作用主要包括: 数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 集群模式 更多：redis系列之——高可用（主从、哨兵、集群） 主从原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。 哨兵主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 自动选取老大的模式 集群Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。","link":"/Database/Redis/"},{"title":"Priority Queue Go 优先队列","text":"论如何在 Go 语言中使用优先队列。 参考： Go标准库中文文档 (cngolib.com) 1、介绍Go 提供了 container/heap 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 index = 0 的值是最小的，即最小堆。 堆也是实现优先队列 Priority Queue 的常用方式。 堆中元素的类型需要实现 heap.Interface 这个接口： 12345type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1.} 其中 sort.Interface 包括 Len(), Less, Swap 方法。 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041type IntHeap [][2]int // 0 key 1 valuefunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i][1] &lt; h[j][1] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.([2]int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 347. 前 K 个高频元素// https://leetcode-cn.com/problems/top-k-frequent-elements/func topKFrequent(nums []int, k int) []int { m := make(map[int]int) ans := make([]int, k) h := &amp;IntHeap{} heap.Init(h) for _, v := range nums { m[v]++ } for key, value := range m { heap.Push(h, [2]int{key, value}) if h.Len() &gt; k { heap.Pop(h) } } for k &gt; 0 { k-- ans[k] = heap.Pop(h).([2]int)[0] } return ans}","link":"/Data-structure/Priority-Queue/"},{"title":"Monotone Queue 单调队列","text":"“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 参考： 代码随想录 (programmercarl.com) 1、介绍单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下： 2、实现 保证队列里单调递减或递增的原则，所以叫做单调队列。 以下不是固定写法： 12345678910111213141516171819202122232425262728293031323334type MonotoneQueue struct { queue []int}func Constructor() MonotoneQueue { return MonotoneQueue{ queue: make([]int, 0), }}func (this *MonotoneQueue) Front() int { return this.queue[0]}func (this *MonotoneQueue) Back() int { return this.queue[len(this.queue)-1]}func (this *MonotoneQueue) Empty() bool { return len(this.queue) == 0}func (this *MonotoneQueue) Push(x int) { for !this.Empty() &amp;&amp; x &gt; this.Back() { this.queue = this.queue[:len(this.queue)-1] } this.queue = append(this.queue, x)}func (this *MonotoneQueue) Pop(x int) { if !this.Empty() &amp;&amp; this.Front() == x { this.queue = this.queue[1:] }}","link":"/Data-structure/Monotone-Queue/"},{"title":"SQL","text":"SQL 语句可分为以下几类： 数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 CREATE，DROP，ALTER 数据查询语言 DQL（Data Query Language）：即查询操作，以 SELECT 关键字为主 数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 INSERT，UPDATE，DELETE 数据控制功能 DCL（Data Control Language）：即权限控制操作，如 GRANT，REVOKE，COMMIT，ROLLBACK 参考：常用 SQL 语句 - LeetCodeSQL约束 - 掘金 1、键 超键：在关系中，能唯一标识元组的属性集称为关系模式的超键。 一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。 外键：在一个表中存在的另一个表的主键称此表的外键。 外键可以有重复的, 可以是空值。 2、约束约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束： 非空约束（NOT NULL）：保证该字段值一定不为空； 默认约束（DEFAULT）：保证字段有默认值； 主键约束（PRIMARY KEY）：标志一列或者多列，并保证其值在表内的唯一性； 外键约束（FOREIGN KEY）：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值； 唯一约束（UNIQUE）： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）； 检查约束（CHECK）：限制一列的可用值范围。 创建约束 创建表时，在字段描述处，声明指定字段为主键： 1234CREATE TABLE persons ( pid int primary key, -- 添加了主键约束...); 创建表时，在constraint约束区域，声明指定字段为主键： 12345678CREATE TABLE persons ( pid INT, lastname VARCHAR(255), firstname VARCHAR(255), address VARCHAR(255), CONSTRAINT pk_persons PRIMARY KEY (lastname, firstname) -- 添加主键约束, 多个字段, 我们称为联合主键。);-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。 创建表之后，通过修改表结构，声明指定字段为主键： 123-- 添加联合主键约束-- 其他约束类似alter table persons add constraint pk_persons primary key (lastname, firstname); 删除约束123456789101112131415-- 删除主键约束-- ALTER TABLE 表名 DROP PRIMARY KEYalter table persons drop primary key; -- 删除非空约束-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]alter table persons modify lastname varchar(255);-- 删除唯一约束-- ALTER TABLE 表名 DROP INDEX 名称-- 有唯一约束名称, 使用约束名称删除alter table persons drop index uni_persons_address; -- 没有唯一约束名称, 使用字段名删除alter table persons drop index address; 3、SQL语句参考w3cschool即可： 详尽的SQL语句大全分类整理_w3cschool 下面列出一些重点： 关联查询在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。 交叉连接（CROSS JOIN） 除了在 FROM 子句中使用 逗号间隔连接的表 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数 乘以 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 CROSS JOIN 关键字而不是逗号，即以下两个表达式等价： SELECT * FROM A, B SELECT * FROM A CROSS JOIN B 内连接（INNER JOIN） 内连接分为三类，分别是 等值连接：ON A.id = B.id、不等值连接：ON A.id &gt; B.id 和 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid 外连接（LEFT JOIN/RIGHT JOIN） 左外连接：以左表为主，先查询出左表，按照 ON 后的关联条件匹配右表，没有匹配到的用 NULL 填充，可以简写成 LEFT JOIN 右外连接：以右表为主，先查询出右表，按照 ON 后的关联条件匹配左表，没有匹配到的用 NULL 填充，可以简写成 RIGHT JOIN 联合查询（UNION 与 UNION ALL） SELECT * FROM A UNION SELECT * FROM B UNION ... 联合查询就是把多个结果集集中在一起，UNION 前的结果为基准，需要注意的是联合查询的 列数要相等，相同的记录行会合并； 如果使用 UNION ALL，不会合并重复的记录行，所以效率更高。 全连接（FULL JOIN） MySQL 本身不支持全连接，但可以通过联合使用 LEFT JOIN、UNION 和 RIGHT JOIN 来实现。 SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id 子查询多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。 子查询是一个 SELECT 语句，它嵌套在另一个 SELECT、SELECT…INTO 语句、INSERT…INTO 语句、DELETE 语句、 UPDATE 语句或嵌套在另一子查询中。 MySQL 的子查询是多表查询的一个重要组成部分，常常和 连接查询 一起使用，是多表查询的基础。 子查询分为以下四类： 标量子查询 查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。 列子查询 子查询返回的结果集是 N 行一列，该结果通常来自对表的 某个字段 查询返回。 行子查询 子查询返回的结果集是一行 N 列，该结果通常是对表的 某行数据 进行查询而返回的结果集 表子查询 子查询返回的结果集是 N 行 N 列的一个表数据。 char 与 varchar 的区别 char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532； 使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充； 因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间； DROP、DELETE 与 TRUNCATE 的区别 DROP DELETE TRUNCATE SQL 语句类型 DDL DML DDL 回滚 不可回滚 可回滚 不可回滚 删除内容 从数据库中 删除表，所有的数据行，索引和权限也会被删除 表结构还在，删除表的 全部或者一部分数据行 表结构还在，删除表中的 所有数据 删除速度 删除速度最快 删除速度慢，需要逐行删除 删除速度快 在不再需要一张表的时候，采用 DROP在想删除部分数据行时候，用 DELETE在保留表而删除所有数据的时候用 TRUNCATE UNION 与 UNION ALL 的区别 UNION 用于把来自多个 SELECT 语句的结果组合到一个结果集合中，MySQL 会把结果集中 重复的记录删掉 UNION ALL，MySQL 会把所有的记录返回，且效率高于 UNION","link":"/Language/SQL/"},{"title":"Stack","text":"栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。 STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 参考： 队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com) 代码随想录 (programmercarl.com) 1、介绍在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。 与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。 2、实现从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 动态数组实现参考： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack { private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) { data.push_back(x); } /** Checks whether the queue is empty or not. */ bool isEmpty() { return data.empty(); } /** Get the top item from the queue. */ int top() { return data.back(); } /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; }};int main() { MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) { if (!s.isEmpty()) { cout &lt;&lt; s.top() &lt;&lt; endl; } cout &lt;&lt; (s.pop() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl; }}","link":"/Data-structure/Stack/"},{"title":"KMP","text":"KMP主要应用在字符串匹配上。 KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 说明借用了这篇博客的一些插图和理解 next数组就是一个前缀表（prefix table）：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 假设 匹配串 S， 模式串 T 最长公共前后缀 ： ABCAB 公共前后缀 是 AB ABABA 公共前后缀 是 ABA ABCABC 公共前后缀 是 ABC 如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图 又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2 将 j 移到 2 （i=5，j=2） 所以，重点要求 next 数组： next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值（最长公共前后缀的长度） 考虑四种情况： ① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1 ② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0 ③ X [ k ] = X [ j ] 匹配到这个位置说明失配位置前 公共前后缀相等，即 X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度） 那么，X [ 0…k ] = X [ j-k…j ] 所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1) ④ X [ k ] != X [ j ] next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀) 此时，将前缀移到后缀位置，即指针前移到最长公共前后缀的长度位置，可以得出： k = next [ k ] 不过，这样求得的 next 数组还有缺陷： 按照前述，j 移到 最长公共前后缀长度 1 的位置： 这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 X[ j ] = X[ next[ j ] ] 的情况没有意义 代码随想录动图示例： 代码GO12345678910111213141516171819202122232425262728293031323334353637383940func getNext(next []int, s string) { i, j := 0, -1 next[0] = j for i &lt; len(s) { for j !=-1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ if i &gt;= len(s) || j &gt;= len(s) { return } if s[i] == s[j] { // 优化去重 next[i] = next[j] } else { next[i] = j } }}func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := make([]int, len(needle)) getNext(next, needle) i, j := 0, 0 for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) { for j !=-1 &amp;&amp; haystack[i] != needle[j] { j = next[j] } i++ j++ } if j == len(needle) { return i - j } else { return -1 }} C++123456789101112131415161718192021222324252627int nx[maxn];void getnx(string x){ int m=x.size(); int i,j; j=nx[0]=-1; i=0; while (i&lt;m){ while (-1!=j &amp;&amp; x[i]!=x[j]) j=nx[j]; if (x[++i]==x[++j]) nx[i]=nx[j]; else nx[i]=j; }}//输出第一次出现的位置int kmp(string s, string t) { //s为匹配串，t为模式串 int n=s.size(); int m=t.size(); int i=0,j=0; getnx(t); while (i&lt;n &amp;&amp; j&lt;m) { while (-1!=j &amp;&amp; s[i]!=t[j]) j=nx[j]; i++; j++; } if (j==m) return i-j; else return -1;} 性质数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 即最小的循环节 12345678910111213141516171819202122232425func getNext(next []int, s string) { // 计算后缀，不需要去重 i, j := 0, -1 next[0] = j for i &lt; len(s) { for j != -1 &amp;&amp; s[i] != s[j] { // 前后缀不同，向前回退 j = next[j] } i++ j++ next[i] = j }}func repeatedSubstringPattern(s string) bool { // if len(s) == 0 { return false } next := make([]int, len(s)+1) // 多+1 计算末位最长前后缀 getNext(next, s) l := len(s) if next[l] != 0 &amp;&amp; l%(l-next[l]) == 0 { return true } return false}","link":"/Algorithm/String-KMP/"},{"title":"Thanox 情景模式","text":"情景模式简单理解： 什么时候，干什么。 什么时候就是触发条件（condition） 干什么就是动作（actions） 本文分享自用的情景模式，不定期更新~ 官方文档： https://tornaco.github.io/Thanox/6-Profile/ 1、GPS 相关GPS自动开关GPS自动开启 >folded1234567name: &quot;GPS自动开启&quot;description: &quot;打开应用打开GPS，全局变量 gps&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$gps.contains(to) &amp;&amp; !hw.isLocationEnabled()&quot;actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' GPS自动关闭 >folded1234567name: &quot;GPS自动关闭&quot;description: &quot;停止应用关闭GPS，全局变量 gps&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$gps.contains(pkgName) &amp;&amp; hw.isLocationEnabled()&quot;actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 微信小程序开关GPS小程序自动打开GPS >folded1234567name: &quot;小程序自动打开GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI&quot;)'actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' 小程序自动关闭GPS >folded1234567name: &quot;小程序自动关闭GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: 'frontPkgChanged &amp;&amp; hw.isLocationEnabled() &amp;&amp; from == &quot;com.tencent.mm&quot;'actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 微信网页开关GPS微信网页打开GPS >folded1234567name: &quot;微信网页打开GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)'actions: - &quot;hw.enableLocation()&quot; - 'ui.showShortToast(&quot;🎉打开GPS&quot;)' 微信网页关闭GPS >folded1234567name: &quot;微信网页关闭GPS&quot;description: &quot;顾名思义&quot;priority: 2condition: '(activityResumed || frontPkgChanged) &amp;&amp; hw.isLocationEnabled() &amp;&amp; !componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)'actions: - &quot;hw.disableLocation()&quot; - 'ui.showShortToast(&quot;🎉关闭GPS&quot;)' 2、NFC 相关NFC自动开关NFC自动开启 >folded1234567name: &quot;NFC自动开启&quot;description: &quot;打开应用打开NFC，全局变量 nfc&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$nfc.contains(to) &amp;&amp; !hw.isNfcEnabled()&quot;actions: - &quot;hw.enableNfc()&quot; - 'ui.showShortToast(&quot;🎉打开NFC&quot;)' NFC自动关闭 >folded1234567name: &quot;NFC自动关闭&quot;description: &quot;停止应用关闭NFC，全局变量 nfc&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$nfc.contains(pkgName) &amp;&amp; hw.isNfcEnabled()&quot;actions: - &quot;hw.disableNfc()&quot; - 'ui.showShortToast(&quot;🎉关闭NFC&quot;)' 3、冻结相关蓝牙开关冻结BT冻结 >folded1234567name: &quot;BT冻结&quot;description: &quot;蓝牙关闭冻结指定应用，全局变量 btkill&quot;priority: 2condition: &quot;btStateChanged &amp;&amp; btStateOff&quot;actions: - &quot;for (String s : globalVarOf$btkill) { if (pkg.isApplicationEnabled(s)) pkg.disableApplication(s) }&quot; - 'ui.showShortToast(&quot;🎉BT冻结&quot;)' BT解冻 >folded1234567name: &quot;BT解冻&quot;description: &quot;蓝牙打开解冻指定应用，全局变量 btkill&quot;priority: 2condition: &quot;btStateChanged &amp;&amp; btStateOn&quot;actions: - &quot;for (String s : globalVarOf$btkill) { if (!pkg.isApplicationEnabled(s)) pkg.enableApplication(s) }&quot; - 'ui.showShortToast(&quot;🎉BT解冻&quot;)' 游戏开关冻结 自行修改以下 com.oneplus.gamespace 包名 Game冻结 >folded12345678name: &quot;Game冻结&quot;description: &quot;关闭游戏冻结游戏空间，全局变量 game&quot;# 一加专属priority: 2condition: 'taskRemoved &amp;&amp; globalVarOf$game.contains(pkgName) &amp;&amp; pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)'actions: - 'pkg.disableApplication(&quot;com.oneplus.gamespace&quot;)' - 'ui.showShortToast(&quot;🎉冻结游戏空间&quot;)' Game解冻 >folded12345678name: &quot;Game解冻&quot;description: &quot;打开游戏解冻游戏空间，全局变量 game&quot;# 一加专属priority: 2condition: 'frontPkgChanged &amp;&amp; globalVarOf$game.contains(to) &amp;&amp; !pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)'actions: - 'pkg.enableApplication(&quot;com.oneplus.gamespace&quot;)' - 'ui.showShortToast(&quot;🎉解冻游戏空间&quot;)' 4、应用相关APP保活 推荐用乖巧模式的规则来 KEEP 想保持的服务 以下貌似没用，可以开启电池不优化试试 APP保活 >folded12345678name: &quot;APP保活&quot;description: &quot;应用停止运行时重启应用进程，全局变量 apps&quot;# APP 后台不优化priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$apps.contains(pkgName)&quot;actions: - &quot;activity.launchProcessForPackage(pkgName)&quot; - 'ui.showShortToast(&quot;🎉保活app&quot;)' APP休眠APP休眠 >folded123456name: &quot;APP休眠&quot;description: &quot;后台应用休眠，全局变量 idle&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$idle.contains(from)&quot;actions: - &quot;activity.setInactive(from)&quot; 5、Data 相关Data自动开启Data自动开启 >folded1234567name: &quot;Data自动开启&quot;description: &quot;打开应用打开移动数据，全局变量 data&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$data.contains(to) &amp;&amp; !hw.isWifiEnabled() &amp;&amp; !data.isDataEnabled()&quot;actions: - &quot;data.setDataEnabled(true)&quot; - 'ui.showShortToast(&quot;🎉打开移动数据&quot;)' 6、亮度相关自动亮度关闭自动亮度关闭 >folded1234567name: &quot;自动亮度关闭&quot;description: &quot;打开应用关闭自动亮度，全局变量 bright&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$bright.contains(to) &amp;&amp; power.isAutoBrightnessEnabled()&quot;actions: - &quot;power.setAutoBrightnessEnabled(false)&quot; - 'ui.showShortToast(&quot;🎉关闭自动亮度&quot;)' 自动亮度开启自动亮度开启 >folded123456789name: &quot;自动亮度开启&quot;description: &quot;停止应用打开自动亮度，全局变量 bright&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$bright.contains(pkgName) &amp;&amp; !power.isAutoBrightnessEnabled()&quot;actions: - &quot;power.setAutoBrightnessEnabled(true)&quot; - &quot;power.setBrightness(power.getBrightness())&quot; - 'ui.showShortToast(&quot;🎉开启自动亮度&quot;)' 7、状态栏图标相关 隐藏状态栏图标的 shell 命令： settings put secure icon_blacklist 「args」 自行修改 「args」 参数 状态栏图标隐藏状态栏图标隐藏 >folded1234567name: &quot;状态栏图标隐藏&quot;description: &quot;打开应用隐藏状态栏图标,全局变量 bar&quot;priority: 2condition: &quot;frontPkgChanged &amp;&amp; globalVarOf$bar.contains(to)&quot;actions: - 'sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,clock,battery,vpn&quot;)' - 'ui.showShortToast(&quot;🎉隐藏状态栏图标&quot;)' 状态栏图标显示状态栏图标显示 >folded1234567name: &quot;状态栏图标显示&quot;description: &quot;停止应用显示状态栏图标,全局变量 bar&quot;priority: 2condition: &quot;pkgKilled &amp;&amp; globalVarOf$bar.contains(pkgName)&quot;actions: - 'sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,battery,vpn&quot;)' - 'ui.showShortToast(&quot;🎉显示状态栏图标&quot;)'","link":"/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"Bit Operation","slug":"Bit-Operation","link":"/tags/Bit-Operation/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"License","slug":"License","link":"/tags/License/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Thanox","slug":"Thanox","link":"/tags/Thanox/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Data structure","slug":"Data-structure","link":"/categories/Data-structure/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Knowledge","slug":"Knowledge","link":"/categories/Knowledge/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Mixed","slug":"Mixed","link":"/categories/Mixed/"}]}