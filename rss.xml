<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千反田</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2021-12-28T12:40:25.685Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell</title>
    <link href="http://blog.sukiu.top/Language/Shell/"/>
    <id>http://blog.sukiu.top/Language/Shell/</id>
    <published>2021-12-28T12:14:49.000Z</published>
    <updated>2021-12-28T12:40:25.685Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 脚本的一些注意点</p><span id="more"></span><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -e file/dir ] # 如果文件/目录存在  </span><br><span class="line">if [ -f file ] # 如果文件存在  </span><br><span class="line">if [ -d dir ]  # 如果目录存在  </span><br><span class="line">if [ -s file ] # 如果文件存在且非空  </span><br><span class="line">if [ -r file ] # 如果文件存在且可读  </span><br><span class="line">if [ -w file ] # 如果文件存在且可写  </span><br><span class="line">if [ -x file ] # 如果文件存在且可执行</span><br></pre></td></tr></table></figure><h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ int1 -eq int2 ] <span class="comment"># 如果 ==  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ne int2 ] <span class="comment"># 如果 !=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ge int2 ] <span class="comment"># 如果 &gt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -gt int2 ] <span class="comment"># 如果 &gt;  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -le int2 ] <span class="comment"># 如果 &lt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -lt int2 ] <span class="comment"># 如果 &lt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ $string1 == $string2 ] # 如果 == (字符串允许使用赋值号做等号)  </span><br><span class="line">if [ $string1 != $string2 ] # 如果 !=  </span><br><span class="line">if [ -n $string ]           # 如果string 长度非0 </span><br><span class="line">if [ -z $string ]           # 如果string 长度为0  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell 脚本的一些注意点&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://blog.sukiu.top/Algorithm/Backtracking/"/>
    <id>http://blog.sukiu.top/Algorithm/Backtracking/</id>
    <published>2021-12-26T05:15:41.000Z</published>
    <updated>2021-12-30T11:08:28.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回溯的本质是穷举，穷举所有可能，然后选出想要的答案</strong>，如果想让回溯法高效一些，需要进行<strong>剪枝</strong>操作。</p><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><blockquote><p><strong>组合不强调元素顺序，排列强调元素顺序</strong>：</p><p>即 不同顺序的同样元素集合 算作排列，但不算组合</p></blockquote><span id="more"></span><blockquote><p>参考：<br><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p></blockquote><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>看到回溯，感觉和 DFS（深度优先搜索）区别不太大，两者其实是包含关系。</p><p>回溯搜索是 DFS 的一种，对于某一个搜索树来说（搜索树记录路径和状态判断），其主要的区别是：</p><ul><li>回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树</li><li>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种方法使得深度优先搜索法与回溯法没什么区别</li></ul><h2 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h2><blockquote><p>N个数里面按一定规则找出k个数的集合。</p></blockquote><p>直接 DFS 暴搜，如果满足条件返回，再加上适当剪枝即可。</p><blockquote><p>如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>。<br>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p></blockquote><p>例题：<a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= n - (k - tmp.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、切割问题"><a href="#3、切割问题" class="headerlink" title="3、切割问题"></a>3、切割问题</h2><blockquote><p>一个字符串按一定规则有几种切割方式</p></blockquote><p>具体算法类似组合问题，判断函数比较复杂。</p><p>例题：<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(s, idx, i)) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(idx, i - idx + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(s, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、子集问题"><a href="#4、子集问题" class="headerlink" title="4、子集问题"></a>4、子集问题</h2><blockquote><p>一个N个数的集合里有多少符合条件的子集</p></blockquote><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。</strong></p><p>例题：<a href="https://leetcode-cn.com/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、排列问题"><a href="#5、排列问题" class="headerlink" title="5、排列问题"></a>5、排列问题</h2><blockquote><p>N个数按一定规则全排列，有几种排列方式</p><p>排列是区分顺序的，不同顺序的集合算不同排列</p></blockquote><p>和组合问题区别在每次循环的起始位置都是 0，同时用 vis 数组来记录状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6、棋盘问题"><a href="#6、棋盘问题" class="headerlink" title="6、棋盘问题"></a>6、棋盘问题</h2><blockquote><p>N皇后，解数独等等</p></blockquote><p>给回溯函数加上 bool 返回值，找到一组成功解则返回。</p><p>例题：<a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归遍历行</span></span><br><span class="line"><span class="comment">     * 循环遍历列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(row, col, n, chess)) &#123;</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(row + <span class="number">1</span>, n, chess);</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *不能同行（递归过程中进行了同行检查）</span></span><br><span class="line"><span class="comment">     *不能同列</span></span><br><span class="line"><span class="comment">     *不能同斜线 （45度和135度角）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查列，剪枝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠45°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠135°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chess</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n, chess);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;  <span class="comment">// 检查列</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;  <span class="comment">// 检查行</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 3x3</span></span><br><span class="line">        <span class="keyword">int</span> nRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> nCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nRow; i &lt; nRow + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nCol; j &lt; nCol + <span class="number">3</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check</span>(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 9 个数都不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="built_in">dfs</span>(board); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;回溯的本质是穷举，穷举所有可能，然后选出想要的答案&lt;/strong&gt;，如果想让回溯法高效一些，需要进行&lt;strong&gt;剪枝&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;回溯法，一般可以解决如下几种问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/li&gt;
&lt;li&gt;切割问题：一个字符串按一定规则有几种切割方式&lt;/li&gt;
&lt;li&gt;子集问题：一个N个数的集合里有多少符合条件的子集&lt;/li&gt;
&lt;li&gt;排列问题：N个数按一定规则全排列，有几种排列方式&lt;/li&gt;
&lt;li&gt;棋盘问题：N皇后，解数独等等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;组合不强调元素顺序，排列强调元素顺序&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;即 不同顺序的同样元素集合 算作排列，但不算组合&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Backtracking" scheme="http://blog.sukiu.top/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://blog.sukiu.top/Computer-network/Physical-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Physical-Layer/</id>
    <published>2021-12-23T13:47:27.000Z</published>
    <updated>2021-12-23T13:58:07.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>物理层</strong>（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。</p><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong></p><p>物理层主要任务：确定与传输媒体接口有关的一些特性</p><p>四大特性：</p><ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</li><li>规程特性：定义各条物理线路的工作规程和时序关系</li></ul><p>物理层设备：中继器</p><span id="more"></span><h2 id="1、通信方式"><a href="#1、通信方式" class="headerlink" title="1、通信方式"></a>1、通信方式</h2><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232153357.png"><br>主要考虑：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="2、数据交换方式"><a href="#2、数据交换方式" class="headerlink" title="2、数据交换方式"></a>2、数据交换方式</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232156819.png" style="zoom: 40%;" /><h2 id="3、传输介质"><a href="#3、传输介质" class="headerlink" title="3、传输介质"></a>3、传输介质</h2><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><ul><li>无线电波</li><li>微波</li><li>红外线、激光</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。&lt;/p&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;strong&gt;传输数据比特流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理层主要任务：确定与传输媒体接口有关的一些特性&lt;/p&gt;
&lt;p&gt;四大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况&lt;/li&gt;
&lt;li&gt;电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制&lt;/li&gt;
&lt;li&gt;功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途&lt;/li&gt;
&lt;li&gt;规程特性：定义各条物理线路的工作规程和时序关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物理层设备：中继器&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://blog.sukiu.top/Computer-network/Data-Link-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Data-Link-Layer/</id>
    <published>2021-12-23T12:57:35.000Z</published>
    <updated>2021-12-23T13:47:32.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据链路层</strong> 是OSI参考模型中的第二层，介乎于物理层和网络层之间。</p><p>功能：在物理层提供服务的基础上向网络层提供服务</p><ul><li>最基本的服务：<strong>将源自于物理层的数据可靠地传输到相邻结点到目标机网络层</strong></li><li>主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li><li>为网络层提供服务：<ul><li>无确认的无连接服务</li><li>有确认的无连接服务</li><li>有确认的面向连接服务</li></ul></li></ul><p>重要协议：</p><ul><li>PPP（Point to Point Protocol）点-点协议</li></ul><p>链路层设备：</p><ul><li>交换机</li><li>网桥</li></ul><span id="more"></span><blockquote><p>参考：<br>王道考研</p></blockquote><h2 id="1、基本问题"><a href="#1、基本问题" class="headerlink" title="1、基本问题"></a>1、基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>针对用户是透明的；首尾是界定帧，转义字符去除数据部分和首尾相同引起歧义。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>链路层编码针对<strong>一组比特</strong>，通过冗余码的技术实现一组二进制比特串在传输过程中是否出现差错。</p><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><p>主要包括：</p><ul><li>检错编码<ul><li>奇偶校验码</li><li>循环冗余码</li></ul></li><li>纠错编码<ul><li>海明码</li></ul></li></ul><h2 id="2、流量控制"><a href="#2、流量控制" class="headerlink" title="2、流量控制"></a>2、流量控制</h2><p>主要通过滑动窗口协议，根据窗口大小分为：</p><ul><li>停止-等待协议：发送窗口 = 1，接收窗口 = 1</li><li>后退N帧协议（GBN）：发送窗口 &gt; 1，接收窗口 = 1</li><li>选择重传协议（SR）：发送窗口 &gt; 1，接收窗口 &gt; 1</li></ul><table><tr>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232122980.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123547.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123892.png" /></td></tr>       </table><h2 id="3、介质访问控制"><a href="#3、介质访问控制" class="headerlink" title="3、介质访问控制"></a>3、介质访问控制</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232127804.png" style="zoom: 33%;" /><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><blockquote><p>CSMA/CD 为载波侦听多路访问/冲突检测，是像以太网这种广播网络采用的一种机制，我们知道在以太网中多台主机在同一个信道中进行数据传输，CSMA/CD 很好的解决了共享信道通信中出现的问题，它的工作原理主要包括两个部分：</p><ul><li><strong>载波监听</strong>：当使用 CSMA/CD 协议时，总线上的各个节点都在监听信道上是否有信号在传输，如果有的话，表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据。</li><li><strong>冲突检测</strong>：当两个或两个以上节点同时监听到信道空闲，便开始发送数据，此时就会发生碰撞（数据的传输延迟也可能引发碰撞）。当两个帧发生冲突时，数据帧就会破坏而失去了继续传输的意义。在数据的发送过程中，以太网是一直在监听信道的，当检测到当前信道冲突，就立即停止这次传输，避免造成网络资源浪费，同时向信道发送一个「冲突」信号，确保其它节点也发现该冲突。之后采用一种二进制退避策略让待发送数据的节点随机退避一段时间之后重新。</li></ul></blockquote><p>CSMA/CD的工作流程可以概括为：</p><ol><li>先听后发</li><li>边发边听</li><li>冲突停发</li><li>随机重发</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232130101.png" style="zoom:33%;" /><blockquote><p>CSMA/CD: 载波监听多路访问 / 碰撞检测（Detect），用于有线局域网（LAN）<br>CSMA/CA: 载波监听多路访问 / 碰撞避免（Avoid），用于无线局域网（WIFI）</p></blockquote><h2 id="4、PPP-协议"><a href="#4、PPP-协议" class="headerlink" title="4、PPP 协议"></a>4、PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP（点对点） 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232140255.png" style="zoom: 33%;" /><h2 id="5、MAC-地址"><a href="#5、MAC-地址" class="headerlink" title="5、MAC 地址"></a>5、MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><blockquote><p>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。<br>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</p></blockquote><h3 id="为什么需要-MAC-地址"><a href="#为什么需要-MAC-地址" class="headerlink" title="为什么需要 MAC 地址"></a>为什么需要 MAC 地址</h3><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p><h3 id="为什么需要-IP-地址"><a href="#为什么需要-IP-地址" class="headerlink" title="为什么需要 IP 地址"></a>为什么需要 IP 地址</h3><p>光有MAC地址的话，寻址困难。IP地址和地域有关，可以分区域寻址，效率更高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; 是OSI参考模型中的第二层，介乎于物理层和网络层之间。&lt;/p&gt;
&lt;p&gt;功能：在物理层提供服务的基础上向网络层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最基本的服务：&lt;strong&gt;将源自于物理层的数据可靠地传输到相邻结点到目标机网络层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路&lt;/li&gt;
&lt;li&gt;为网络层提供服务：&lt;ul&gt;
&lt;li&gt;无确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的面向连接服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PPP（Point to Point Protocol）点-点协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机&lt;/li&gt;
&lt;li&gt;网桥&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>开源安卓应用推荐</title>
    <link href="http://blog.sukiu.top/Share/Open-Source-Apk-Share/"/>
    <id>http://blog.sukiu.top/Share/Open-Source-Apk-Share/</id>
    <published>2021-12-22T10:11:16.000Z</published>
    <updated>2021-12-22T11:11:30.007Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一些开源的安卓应用，可以在 <a href="https://www.f-droid.org/">F-Droid</a>或 <a href="https://github.com/">GitHub</a> 下载，主要是一些软件的第三方。</p><span id="more"></span><h2 id="F-Droid-第三方"><a href="#F-Droid-第三方" class="headerlink" title="F-Droid 第三方"></a>F-Droid 第三方</h2><h3 id="Aurora-Droid"><a href="#Aurora-Droid" class="headerlink" title="Aurora Droid"></a>Aurora Droid</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.adroid/">Aurora Droid</a></p><p>Aurora 家族成员，界面仿 PlayStroe 风格，不过上次更新已经是3月了，个人体验下来有点卡顿的感觉，没有中文。</p><p>推荐指数：⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss001.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss002.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss003.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss004.png" /></td></tr></table><h3 id="Droid-ify"><a href="#Droid-ify" class="headerlink" title="Droid-ify"></a>Droid-ify</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.looker.droidify/">Droid-ify</a></p><p>FoxyDroid 的 Fork，Matrial you风格，更新勤快，界面简洁且好看，内置了不少仓库，支持中文。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-amoled.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-amoled.png" style="zoom:10%;" /></td></tr></table><h2 id="Play-Stroe-第三方"><a href="#Play-Stroe-第三方" class="headerlink" title="Play Stroe 第三方"></a>Play Stroe 第三方</h2><h3 id="Aurora-Store"><a href="#Aurora-Store" class="headerlink" title="Aurora Store"></a>Aurora Store</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.store/">Aurora Store</a></p><p>Auroara 家族成员，美观且支持匿名登录和选区。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss001.png"/</td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss002.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss003.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss004.png"/></td></tr></table><h2 id="Telegram-第三方"><a href="#Telegram-第三方" class="headerlink" title="Telegram 第三方"></a>Telegram 第三方</h2><h3 id="Nekogram-X"><a href="#Nekogram-X" class="headerlink" title="Nekogram X"></a>Nekogram X</h3><p><a href="https://f-droid.org/zh_Hans/packages/nekox.messenger/">Nekogram X</a></p><p>可以说专门为国人定制的了，自定义选项都很实用，可以自由选择 FCM 推送。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Reddit-第三方"><a href="#Reddit-第三方" class="headerlink" title="Reddit 第三方"></a>Reddit 第三方</h2><h3 id="Infinity-for-Reddit"><a href="#Infinity-for-Reddit" class="headerlink" title="Infinity for Reddit"></a>Infinity for Reddit</h3><p><a href="https://f-droid.org/zh_Hans/packages/ml.docilealligator.infinityforreddit/">Infinity for Reddit</a></p><p>自定义项多，支持安卓12 Material you，没有广告，比官方的好用多了。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/1.png"/</td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/6.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/7.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/8.png"/></td></tr></table><h2 id="Youtube-第三方"><a href="#Youtube-第三方" class="headerlink" title="Youtube 第三方"></a>Youtube 第三方</h2><h3 id="NewPipe"><a href="#NewPipe" class="headerlink" title="NewPipe"></a>NewPipe</h3><p><a href="https://f-droid.org/zh_Hans/packages/org.schabi.newpipe/">NewPipe</a></p><p>不需要登陆，没有广告，更新勤快，对轻度使用者极其友好。<br>可惜不能自定义外观，略丑。</p><p>推荐指数：⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_01.png"/</td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_02.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_06.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_07.png"/></td></tr></table><h2 id="Twitter-第三方"><a href="#Twitter-第三方" class="headerlink" title="Twitter 第三方"></a>Twitter 第三方</h2><h3 id="Twidere-X"><a href="#Twidere-X" class="headerlink" title="Twidere X"></a>Twidere X</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.twidere.twiderex/">Twidere X</a></p><p>支持登录 Twitter 和 Mastodon，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Pixiv-第三方"><a href="#Pixiv-第三方" class="headerlink" title="Pixiv 第三方"></a>Pixiv 第三方</h2><h3 id="Pixiv-Shaft"><a href="#Pixiv-Shaft" class="headerlink" title="Pixiv-Shaft"></a>Pixiv-Shaft</h3><p><a href="https://github.com/CeuiLiSA/Pixiv-Shaft">Pixiv-Shaft</a></p><p>美观，且支持浏览部分热点排序，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-0.jpg"/</td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-3.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-4.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-5.jpg"/></td></tr></table><h2 id="贴吧-第三方"><a href="#贴吧-第三方" class="headerlink" title="贴吧 第三方"></a>贴吧 第三方</h2><h3 id="TiebaLite"><a href="#TiebaLite" class="headerlink" title="TiebaLite"></a>TiebaLite</h3><p><a href="https://github.com/HuanCheng65/TiebaLite">TiebaLite: 贴吧 Lite</a></p><p>测试版仍在更新，评论容易封号，适合只浏览。</p><p>推荐指数：⭐⭐⭐⭐</p><h2 id="V2EX-第三方"><a href="#V2EX-第三方" class="headerlink" title="V2EX 第三方"></a>V2EX 第三方</h2><h3 id="V2er"><a href="#V2er" class="headerlink" title="V2er"></a>V2er</h3><p><a href="https://github.com/v2er-app/Android">V2er.Android</a></p><p>原来付费，现在作者开源了，体验最好的 V2EX 第三方。</p><p>推荐指数：⭐⭐⭐⭐⭐</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;推荐一些开源的安卓应用，可以在 &lt;a href=&quot;https://www.f-droid.org/&quot;&gt;F-Droid&lt;/a&gt;或 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 下载，主要是一些软件的第三方。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://blog.sukiu.top/categories/Share/"/>
    
    
    <category term="App" scheme="http://blog.sukiu.top/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://blog.sukiu.top/Computer-network/Network-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Network-Layer/</id>
    <published>2021-12-22T06:57:49.000Z</published>
    <updated>2021-12-22T10:30:44.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络层</strong>（<strong>Network Layer</strong>）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。<br>由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p><p>网络层协议负责提供<strong>主机</strong>间的逻辑通信；传输层协议负责提供<strong>进程</strong>间的逻辑通信。</p><p>功能：</p><ul><li>路由选择与分组转发 <strong>最佳路径</strong></li><li>异构网络互联</li><li>拥塞控制</li></ul><p>网络层重要协议：</p><ul><li>IP（Internet Protocol）网际互连协议</li></ul><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>ARP（Address Resolution Protocol）地址解析协议</li><li>ICMP（Internet Control Message Protocol）网际控制报文协议</li><li>IGMP（Internet Group Management Protocol）网际组管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esz3b2/">力扣</a><br>王道考研</p></blockquote><h2 id="1、IP"><a href="#1、IP" class="headerlink" title="1、IP"></a>1、IP</h2><p>该协议工作在网络层，主要目的就是为了提高网络的可扩展性。</p><p>和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP 协议族的核心。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221614969.png" style="zoom: 67%;" /><p>IP 协议主要有以下几个作用：</p><ul><li><strong>寻址和路由</strong>：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><p>总长度单位1B，片位移单位8B，首部单位4B</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221622589.png" style="zoom:50%;" /><blockquote><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221624491.png" style="zoom: 60%;" /><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>IP地址由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221637019.png" style="zoom: 33%;" /><p>以上分类还空出一些地址，这些特殊的地址包括：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221639252.png" style="zoom:60%;" /><p>另外还有私有地址（局域网）：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221641441.png" style="zoom: 33%;" /><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221643433.png" style="zoom: 40%;" /><p>子网掩码：主机位全0，其他全1（网络位、子网位）</p><h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>NAT（Network Address Translation)，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。</p><p>该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><blockquote><p>在专用网连接到因特网（公用地址）的路由器上安装NAT软件（NAT路由器），它至少有一个有效的外部全球IP地址</p><ul><li>NAT路由器根据转换表替换源IP地址或者目的IP地址和端口号，所以转发数据报时需查看和转换传输层的端口号</li><li>普通路由器仅工作在网络层，不改变源IP和目的IP</li></ul></blockquote><p>NAT 的实现有三种方式：</p><ul><li>静态转换，一对一，一个私有对应一个公有</li><li>动态转换，一对多，一个私有每次转换的公有不唯一</li><li>端口多路复用，多对一，多个私有共享一个合法的外部IP，映射到了不同的端口上</li></ul><h4 id="CIDR-无分类域间路由选择"><a href="#CIDR-无分类域间路由选择" class="headerlink" title="CIDR 无分类域间路由选择"></a>CIDR 无分类域间路由选择</h4><p>CIDR（Classless Inter-Domain Routing）</p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p><code>IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221647430.png" style="zoom: 40%;" /><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>从根本上解决 IPV4 地址不够的问题。</p><blockquote><p>其他方法：<br>NAT：网络地址转换<br>DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址<br>（DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP）</p></blockquote><p>IPV6 将地址从32位（4B）扩大到了128位（64B）</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221715771.png" style="zoom: 78%;" /><h2 id="2、ARP"><a href="#2、ARP" class="headerlink" title="2、ARP"></a>2、ARP</h2><p>ARP（Address Resolution Protocol）地址解析协议，完成IP地址到MAC地址的映射（解决下一跳走哪的问题）</p><h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><ol><li>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong>，同一局域网内所有主机都能受到该请求</li><li>目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次）</li></ol><h3 id="典型情况"><a href="#典型情况" class="headerlink" title="典型情况"></a>典型情况</h3><ul><li>主机A发给本网络上的主机B：用ARP找到B的硬件地址</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址</li><li>路由器发给本网络的主机B：用ARP找到B的硬件地址</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li></ul><h2 id="3、ICMP"><a href="#3、ICMP" class="headerlink" title="3、ICMP"></a>3、ICMP</h2><p>ICMP（Internet Control Message Protocol）是网际控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）</li><li>辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>Ping</strong>：测试两个主机间的连通性，使用 ICMP 会送请求和回答报文</li><li><strong>TraceRoute</strong>：跟踪一个分组从源点到终点的路径，使用 ICMP 时间超过差错报告报文</li></ul><blockquote><p>ping 不通可能存在的问题：</p><ul><li>首先看网络是否连接正常，检查网卡驱动是否正确安装</li><li>局域网设置问题，检查 IP 地址是否设置正确</li><li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙</li><li>看是否被第三方软件拦截</li><li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到</li></ul></blockquote><h2 id="4、IGMP"><a href="#4、IGMP" class="headerlink" title="4、IGMP"></a>4、IGMP</h2><p>IGMP（Internet Group Management Protocol）网际组管理协议，让路由器知道局域网上是否有主机（的进程）参加或退出某个组播组。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221718842.png" style="zoom: 67%;" /><h2 id="5、路由器"><a href="#5、路由器" class="headerlink" title="5、路由器"></a>5、路由器</h2><p>路由器是网络层设备，通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。</p><p>路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</p><blockquote><p>交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</p></blockquote><h3 id="分组转发流程"><a href="#分组转发流程" class="headerlink" title="分组转发流程"></a>分组转发流程</h3><ol><li>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络</li><li>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器<strong>直接交付</strong>，否则执行 3</li><li>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4</li><li>逐条检查路由表，使用每一行的子网掩码与目的IP匹配。若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5</li><li>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6</li><li>无法找到合适路由，向源主机报错</li></ol><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><ul><li>RIP（Routing Information Protocol）路由信息协议</li><li>OSPF（Open Shortest Path First）开放式最短路径优先</li><li>BGP（Border Gateway Protocol）边界网关协议</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221732310.png" style="zoom:70%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;（&lt;strong&gt;Network Layer&lt;/strong&gt;）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。&lt;br&gt;由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。&lt;/p&gt;
&lt;p&gt;网络层协议负责提供&lt;strong&gt;主机&lt;/strong&gt;间的逻辑通信；传输层协议负责提供&lt;strong&gt;进程&lt;/strong&gt;间的逻辑通信。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由选择与分组转发 &lt;strong&gt;最佳路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;异构网络互联&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP（Internet Protocol）网际互连协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARP（Address Resolution Protocol）地址解析协议&lt;/li&gt;
&lt;li&gt;ICMP（Internet Control Message Protocol）网际控制报文协议&lt;/li&gt;
&lt;li&gt;IGMP（Internet Group Management Protocol）网际组管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="http://blog.sukiu.top/Computer-network/Transport-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Transport-Layer/</id>
    <published>2021-12-21T11:17:05.000Z</published>
    <updated>2021-12-22T07:47:15.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层</strong>（<strong>Transport Layer</strong>）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。</p><p>功能：使用网络层服务，为应用层提供服务</p><ul><li>提供进程和进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li></ul><p>传输层的重要协议：</p><ul><li>TCP（Transmission Control Protocol）传输控制协议</li><li>UDP（User Datagram Protocol）用户数据报协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/">力扣</a><br>王道考研</p></blockquote><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212129515.png" style="zoom:33%;" /><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211934483.png" style="zoom: 40%;" /><blockquote><p>标志位：SYN（Synchronize）、ACK（ACKnowledge Character）<br>序号：seq<br>确认号：ack</p><p>第 2 次握手为什么还要传回 SYN：</p><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（seq）同步给客户端。</p></blockquote><h4 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h4><p>三次握手保证两点：</p><ul><li>保证双方都是双工通信：<ul><li>第一次握手，服务端确定客户端的发送正常</li><li>第二次握手，客户端确认服务端的收发正常</li><li>第三次握手，服务端确定客服端接收正常</li></ul></li><li>如果只有第二次握手，服务端发给客服端的包丢了之后：<ul><li>服务端直接建立了连接，端口就会一直开着</li><li>等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接</li><li>端口越来越多，造成服务器开销的浪费</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211949356.png" alt="image-20211221194951070" style="zoom: 33%;" /><h4 id="握手异常"><a href="#握手异常" class="headerlink" title="握手异常"></a>握手异常</h4><table><thead><tr><th>异常</th><th>如何处理</th><th>备注</th></tr></thead><tbody><tr><td>第一次握手 SYN 包丢失</td><td><strong>服务端</strong>不会进行任何相应的动作<br><strong>客户端</strong>在一段时间内没有收到服务器发来的确认报文， 会等待一段时间后重新发送 SYN 同步报文，<br>若仍没有回应，则重复上述直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1</td><td>客户端超时重传最大次数：<code>tcp_syn_retries</code>，默认5次（Linux 3.7 后为6次）</td></tr><tr><td>第二次握手 SYN、ACK 包丢失</td><td><strong>客户端</strong>会采取第一次握手失败时的动作（超时重传）<br><strong>服务端</strong>此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文（同样超时重传）</td><td>服务端超时重传最大次数：<code>tcp_synack_retries</code>，默认5次</td></tr><tr><td>第三次握手 ACK 包丢失</td><td>两次握手成功，<strong>客户端</strong>进入<code>ESTABLISHED</code>状态，<strong>服务端</strong>进入<code>SYN_REC</code>状态<br><strong>服务端</strong>收不到 ACK，就一直重传 SYN、ACK 包，直到超过最大次数，断开TCP连接<br><strong>客户端</strong>认为自己连接成功，开始向服务器端发送数据，服务端收到来自客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态</td><td></td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211951252.png" style="zoom: 40%;" /><blockquote><p>标志位：Fin（Finish）<br>阶段：FIN-WAIT（半关闭）</p><p>CLOSE-WAIT：是服务端发出第一次挥手（整体第二次）进入的状态</p><p>表示“我准备关闭了，但是还有自己的事情处理一下，你等我处理完”<br>等服务器处理好自己的数据业务，则表示“我准备好了”，再发送 FIN 包</p><p>TIME-WAIT：是第四次挥手后，客户端进入的状态，是客户端必要的等待时间。</p><p>目的是：等待服务端的对应端口关闭与客户端发送到服务端的数据到达（可能出现延迟）</p><p>如果不存在这个步骤就会导致两个问题:</p><ul><li><p>客户端立即关闭后，立即又用同样的端口握手并建立通信，此时上次的连接残留的数据包会被误认为是本次的，造成数据异常</p></li><li><p>客户端直接关闭后，若服务端重新发送 FIN 包，客户端就会回应 RST，会报异常，但是实际没有问题的</p></li></ul><p>MSL（Maximum Segment Lifetime）：指一段 TCP 报文在传输过程中的最大生命周期</p><p>2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长，为的是确认服务器能否接收到客户端发出的 ACK 确认报文</p></blockquote><h4 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h4><p>简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。</p><p>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的：</p><ul><li>当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文</li><li>当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212000734.png" style="zoom:33%;" /><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP 如何保证可靠传输：</p><ul><li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li><li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li><li><strong>流量控制</strong>：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li><li><strong>拥塞控制</strong>：当网络某个节点发生拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li></ul><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p>在已发送但未确认的报文被确认之前，发送方的滑动窗口将不会滑动（类比滑动窗口算法）</p><h4 id="最大连接数限制"><a href="#最大连接数限制" class="headerlink" title="最大连接数限制"></a>最大连接数限制</h4><ul><li><strong>Client 最大 TCP 连接数</strong>：TCP 端口的数据类型是 unsigned short（$2^{16}$），可用端口最多有 65535 个（除端口0）</li><li><strong>Server最大 TCP 连接数</strong>：客户端 IP 数 × 客户端 port 数（理论）</li></ul><blockquote><p>对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 $2^{32}$（IP 数）× $2^{16}$（port 数），即约为$2^{48}$</p></blockquote><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212120334.png" style="zoom: 33%;" /><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><p>常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212127381.png" style="zoom: 40%;" /><blockquote><p><strong>拥塞控制和流量控制的区别：</strong><br>拥塞控制往往是一种全局的控制，防止过多的数据注入到网络之中<br>流量控制往往指点对点通信量的控制，是端到端的问题（TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处）</p></blockquote><h2 id="2、UDP"><a href="#2、UDP" class="headerlink" title="2、UDP"></a>2、UDP</h2><h3 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212131402.png" style="zoom: 33%;" /><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20~60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8个字节</td></tr></tbody></table><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212058636.png" style="zoom: 50%;" /><h3 id="不可靠传输"><a href="#不可靠传输" class="headerlink" title="不可靠传输"></a>不可靠传输</h3><ul><li>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，当对方接收缓冲区满了后就会丢弃，因此 UDP 不能保证数据能够到达目的地</li><li>UDP 没有流量控制和重传机制</li><li>UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号</li></ul><blockquote><p>调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。<br>调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。<br>当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p></blockquote><h2 id="3、More"><a href="#3、More" class="headerlink" title="3、More"></a>3、More</h2><h3 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。<br>通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;（&lt;strong&gt;Transport Layer&lt;/strong&gt;）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。&lt;/p&gt;
&lt;p&gt;功能：使用网络层服务，为应用层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供进程和进程之间的逻辑通信&lt;/li&gt;
&lt;li&gt;复用和分用&lt;/li&gt;
&lt;li&gt;传输层对收到的报文进行差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP（Transmission Control Protocol）传输控制协议&lt;/li&gt;
&lt;li&gt;UDP（User Datagram Protocol）用户数据报协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://blog.sukiu.top/Computer-network/Application-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Application-Layer/</id>
    <published>2021-12-12T07:28:27.000Z</published>
    <updated>2021-12-22T07:47:09.653Z</updated>
    
    <content type="html"><![CDATA[<p><strong>应用层</strong>（<strong>Application layer</strong>）位于 <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" title="OSI模型">OSI模型</a>的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。</p><p>应用层的功能：</p><ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>应用层的重要协议：</p><ul><li>HTTP（HyperText Transfer Protocol）超文本传输协议</li><li>FTP（File Transfer Protocol）文件传输协议<ul><li>TFTP（Trivial File Transfer Protocol）简单文件传输协议</li></ul></li><li>DNS（Domain Name System）域名系统</li><li>SMTP（Simple Mail Transfer Protocol）简单邮件传输协议<ul><li>POP3（Post Office Protocol - Version 3）邮局协议</li></ul></li><li>DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议</li><li>SNMP（Simple Network Management Protocol）简单网络管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eksi0s/">力扣</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP Headers - HTTP | MDN</a></p></blockquote><h2 id="1、HTTP"><a href="#1、HTTP" class="headerlink" title="1、HTTP"></a>1、HTTP</h2><h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(General Header Fields)</li><li>请求头字段(Request Header Fields)</li><li>响应头字段(Response Header Fields)</li><li>实体头字段(Entity Header Fields)</li></ul><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>同时适用于请求和响应消息（客户端和服务器都可以使用），但与最终消息主体中传输的数据无关的消息头。</p><p>可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中是否使用缓存机制</td><td>Cache-Control: no-store</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td>Connection: keep-alive (Upgrade)</td></tr><tr><td>Date</td><td>报文创建时间</td><td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td></tr><tr><td>Trailer</td><td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td><td>Trailer: Expiress</td></tr><tr><td>Transfer-Encoding</td><td>用来改变报文格式</td><td>Transfer-Encoding: chunked</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容中可能存在错误</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h4><p>包含更多有关要获取的资源或客户端本身信息的消息头，如Accept头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器自己允许哪些媒体类型</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>浏览器申明可接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己接收的编码方法</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的响应内容语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于表示 HTTP 协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号</td><td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td></tr><tr><td>If-XXX</td><td>条件请求</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数</td><td>Max-Forwards: 10</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以 0 开始</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td><td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td>User-Agent: Mozilla/……</td></tr></tbody></table><h4 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h4><p>包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头，如Server头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>字段的值表示可用于定义范围的单位</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>创建响应的时间</td><td>Age：5744337</td></tr><tr><td>ETag</td><td>唯一标识分配的资源</td><td>Etag：W/"585cd998-7c0f"</td></tr><tr><td>Location</td><td>表示重定向后的 URL</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>告知客户端多久后再发送请求</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>告知客户端服务器信息</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Vary</td><td>缓存控制</td><td>Vary: Origin</td></tr></tbody></table><h4 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h4><p>请求/响应报文中实体部分的首部，包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型，如Content-Type头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p><strong>非Keep-alive</strong>：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。<br><strong>Keep-alive</strong>：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。</p><h5 id="长连接-or-短链接"><a href="#长连接-or-短链接" class="headerlink" title="长连接 or 短链接"></a>长连接 or 短链接</h5><p><a href="https://blog.csdn.net/luzhensmart/article/details/87186401">http的长连接和短连接（史上最通俗！）以及应用场景_luzhensmart的专栏-CSDN博客_长连接和短连接的使用场景</a></p><p><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接</strong>：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h4 id="报文长度"><a href="#报文长度" class="headerlink" title="报文长度"></a>报文长度</h4><p>长度在响应报文中有两种表现形式。</p><ol><li>对于小点的文件，直接给出 content-length，也就是本次返回的数据长度</li><li>对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分块传输，这也是订好了协议，客户端收到了会进行组装，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</li></ol><p>曾经用 py 写过下载脚本，就利用了分块传输的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_size = <span class="built_in">int</span>(r.headers[<span class="string">&#x27;content-length&#x27;</span>])</span><br><span class="line"><span class="keyword">with</span> tqdm(total=file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, unit_divisor=<span class="number">1024</span>, <span class="built_in">ascii</span>=<span class="literal">True</span>,desc=filename) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            fp.write(chunk)</span><br><span class="line">            bar.update(<span class="built_in">len</span>(chunk))</span><br></pre></td></tr></table></figure><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>HTTP/1.0 定义了三种请求方法：<code>GET</code>, <code>POST</code> 和 <code>HEAD</code> 方法。</p><p>HTTP/1.1 增加了六种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p><p><del>感觉实际生产中很少会用那6种方法，极大的复杂化了api</del></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h4 id="GET-or-POST"><a href="#GET-or-POST" class="headerlink" title="GET or POST"></a>GET or POST</h4><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）</li></ul><blockquote><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。<br>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p></blockquote><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限制</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP包头<br>如果数据是中文或其它字符，则进行BASE64编码。</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><p><strong>长度限制：</strong></p><ul><li>GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</li><li>POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</li></ul><h3 id="HTTP-状态"><a href="#HTTP-状态" class="headerlink" title="HTTP 状态"></a>HTTP 状态</h3><p>HTTP 协议是<strong>无连接无状态</strong>的，并不保存关于客户端的任何信息。<br>通常有两种方法保持会话：</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。</p><blockquote><p>优点：安全性高，因为状态信息保存在服务器端。<br>缺点：由于大型网站往往采用的是分布式服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。<br>【解决方法】：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息</p></blockquote><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。<br>客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。</p><blockquote><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。<br>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据；每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p></blockquote><h4 id="Cookie-被禁用"><a href="#Cookie-被禁用" class="headerlink" title="Cookie 被禁用"></a>Cookie 被禁用</h4><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。</p><p>HTTP 状态码共有 5 种类型：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1XX</td><td>指示信息--表示请求正在处理</td></tr><tr><td>2XX</td><td>成功--表示请求已被成功处理完毕</td></tr><tr><td>3XX</td><td>重定向--要完成的请求需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器端错误--服务器处理请求出现错误</td></tr></tbody></table><p>常见的状态码有如下几种：</p><ul><li><code>200 OK</code> 客户端请求成功</li><li><code>301 Moved Permanently</code> 请求永久重定向</li><li><code>302 Moved Temporarily</code> 请求临时重定向</li><li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li><li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li><li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li><li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><blockquote><p>更多可见 <a href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 状态码_w3cschool</a></p></blockquote><h4 id="面试对状态码常见问法"><a href="#面试对状态码常见问法" class="headerlink" title="面试对状态码常见问法"></a>面试对状态码常见问法</h4><h5 id="状态码-301-和-302-的区别"><a href="#状态码-301-和-302-的区别" class="headerlink" title="状态码 301 和 302 的区别"></a>状态码 301 和 302 的区别</h5><ul><li>301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</li><li>302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</li></ul><h5 id="HTTP-异常状态码"><a href="#HTTP-异常状态码" class="headerlink" title="HTTP 异常状态码"></a>HTTP 异常状态码</h5><p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p><h2 id="2、HTTPS"><a href="#2、HTTPS" class="headerlink" title="2、HTTPS"></a>2、HTTPS</h2><p>HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式：<br>首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性。<br>通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><table>    <tr>    <td>协议</td>    <td>特点</td>    <td>工作方式</td>    </tr>    <tr>        <td>HTTP</td>        <td>        <li>明文传输，数据未加密，安全性较差        <li>默认 80 端口        <li>3 次握手建立连接        </td>        <td>        <ol>        <li>客户端请求服务器 80 端口，建立 TCP 连接        <li>客户端从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文        <li>服务端从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文        <li>通信结束，客户端与服务器关闭连接        </ol>        </td>    </tr>    <tr>        <td>HTTPS</td>        <td>        <li>加密，安全性较好        <li>默认 443 端口        <li>需数字认证机构（Certificate Authority, CA）的证书        <li>除 TCP 的 3 次握手，还需要 SSL 协商        </td>         <td>        <ol>        <li>客户端请求服务器 443 端口，建立 TCP 连接（包括支持算法，密钥长度等）        <li>服务端从双方共同支持的加密算法列表中选择一种返回给客户端（包括密钥组件）        <li>服务器返回自身 CA 证书的报文（包含证书的颁发机构、过期时间、服务端的公钥等信息）        <li>服务端发送一个完成报文通知客户端 SSL 的第一阶段已经<b>协商完成</b>        <li>客户端用本地证书库的根证书校验CA证书，生成随机密码串，用公钥加密发送给服务器，即回应报文        <li>紧接着客户端会发送一个报文提示服务端在此之后的报文是采用密码串加密的        <li>客户端发送一个 finish 报文（包含第一次握手至今所有报文的整体校验值）        <li>服务端同样发送与第 6 步中相同作用的报文，最后发送 finish 报文告诉客户端自己能够正确解密报文        <li>SSL 连接建立        </ol>        </td>    </tr></table><blockquote><p>CA 证书防止的方式：（为什么可以信任 CA 证书）<br>篡改：加密签名与原文签名对比<br>调包：请求域名与证书域名对比</p></blockquote><p>另附 HTTP 版本演变：</p><blockquote><p>直接造访 <a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez4zv6/">HTTP x.x</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161819417.png" style="zoom:67%;" /><h2 id="3、DNS"><a href="#3、DNS" class="headerlink" title="3、DNS"></a>3、DNS</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，提供了主机名和 IP 地址之间相互转换的服务。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161824712.png" style="zoom:80%;" /><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><ul><li><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<strong>帮你查</strong></li><li><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<strong>自己查</strong></li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。</p><p>大多数情况下 DNS 使用 UDP 进行传输，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><p>在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据</li></ul><blockquote><p>因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p></blockquote><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。</p><p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。</p><h4 id="预防手段"><a href="#预防手段" class="headerlink" title="预防手段"></a>预防手段</h4><ul><li>直接使用IP访问</li><li>直接指定DNS服务器（如谷歌的 8.8.8.8）</li></ul><h2 id="4、More"><a href="#4、More" class="headerlink" title="4、More"></a>4、More</h2><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><blockquote><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p></blockquote><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。<br>例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><ul><li>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li><li>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</li><li>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li></ul><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><ul><li>URL，即统一资源定位符 ( <em>Uniform Resource Locator</em> )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</li><li>URI，即统一资源标识符（ <em>Uniform Resource Identifier</em> ），只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL</li></ul><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul><li>其实就是将抓包工具视为中间人，其对于本地而言相当于服务端；而对于真正的服务端而言则相当于客户端；</li><li>抓包工具分别和本地以及服务器都进行TLS握手协商；</li><li>这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书）</li></ul><h3 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程"></a>网页解析全过程</h3><blockquote><p>这部分可以看看：<a href="https://github.com/skyline75489/what-happens-when-zh_CN"> 当···时发生了什么？what-happens-when</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161850389.png" style="zoom:67%;" /><ol><li><strong>DNS 解析</strong>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。</li><li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了</li><li><strong>发送 HTTP 请求</strong>：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</li></ol><blockquote><p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。<br>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p></blockquote><ol start="4"><li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li><li><strong>浏览器渲染</strong>：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li><strong>断开连接</strong>：客户端和服务器通过四次挥手终止 TCP 连接。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;（&lt;strong&gt;Application layer&lt;/strong&gt;）位于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B&quot; title=&quot;OSI模型&quot;&gt;OSI模型&lt;/a&gt;的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。&lt;/p&gt;
&lt;p&gt;应用层的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件传输、访问和管理&lt;/li&gt;
&lt;li&gt;电子邮件&lt;/li&gt;
&lt;li&gt;虚拟终端&lt;/li&gt;
&lt;li&gt;查询服务和远程作业登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP（HyperText Transfer Protocol）超文本传输协议&lt;/li&gt;
&lt;li&gt;FTP（File Transfer Protocol）文件传输协议&lt;ul&gt;
&lt;li&gt;TFTP（Trivial File Transfer Protocol）简单文件传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS（Domain Name System）域名系统&lt;/li&gt;
&lt;li&gt;SMTP（Simple Mail Transfer Protocol）简单邮件传输协议&lt;ul&gt;
&lt;li&gt;POP3（Post Office Protocol - Version 3）邮局协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议&lt;/li&gt;
&lt;li&gt;SNMP（Simple Network Management Protocol）简单网络管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络模型与协议</title>
    <link href="http://blog.sukiu.top/Computer-network/Models-And-Protocols/"/>
    <id>http://blog.sukiu.top/Computer-network/Models-And-Protocols/</id>
    <published>2021-12-09T01:17:18.000Z</published>
    <updated>2021-12-22T07:47:03.627Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络主要有3种模型：</p><ul><li>ISO/OSI参考模型 7层</li><li>TCP/IP参考模型 5层</li><li><strong>TCP/IP参考模型 4层</strong></li></ul><p><strong>OSI</strong>是一种理论下的<strong>模型</strong>，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekz8lr/">力扣</a><br>王道考研</p></blockquote><h2 id="1、参考模型"><a href="#1、参考模型" class="headerlink" title="1、参考模型"></a>1、参考模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。<br>OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112090939525.png" style="zoom:67%;" /><ul><li><strong>应用层</strong>：用户与网络的界面，通过应用程序间的交互来完成特定的网络应用</li></ul><blockquote><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。<br>例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。<br>在应用层交互的数据单元为报文。</p></blockquote><ul><li><strong>表示层</strong>：使通信的应用程序能够解释交换数据的含义<ul><li>数据格式变换 翻译官 <strong>数据描述</strong></li><li>数据加密解密 <strong>数据加密</strong></li><li>数据压缩和恢复 <strong>数据压缩</strong></li></ul></li></ul><blockquote><p>这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p></blockquote><ul><li><strong>会话层</strong>：负责建立、管理和终止表示层实体之间的通信会话。</li></ul><blockquote><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法（类似断点续传）。</p></blockquote><ul><li><p><strong>传输层</strong>：负责主机中两个进程的通信，即端到端通信。<font color="red">传输单位是报文段或用户数据报</font></p><ul><li><em>可</em> 靠传输、不可靠传输</li><li><em>差</em> 错控制</li><li><em>流</em> 量控制</li><li><em>复</em> 用分用（记忆：可差的也能流用？）<ul><li>复用：多个应用层进程可同时使用下面传输层的服务</li><li>分用：传输层把收到的信息分别交付给上面应用层相应的进程</li></ul></li></ul></li><li><p><strong>网络层</strong>：选择合适的网间路由和交换节点，确保数据按时成功传送。<font color="red">传输单位是数据报</font></p><ul><li><p>路由选择与分组转发 <strong>最佳路径</strong></p><blockquote><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。</p></blockquote></li><li><p>流量控制 <strong>发送速度</strong></p></li><li><p>差错控制</p></li><li><p>拥塞控制 <strong>总体速度</strong></p></li></ul></li><li><p><strong>数据链路层</strong>：把网络层传下来的数据报组装成帧。<font color="red">传输单位是帧</font></p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制 <strong>帧错+位错</strong></li><li>流量控制</li><li>访问（接入）控制 <strong>控制对信道的访问</strong></li></ul></li><li><p><strong>物理层</strong>：在物理媒体上实现比特流的透明传输。<font color="red">传输单位是比特</font></p><blockquote><p>尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么</p></blockquote><ul><li>定义接口特性（机械特性、电气特性、功能特性，过程特性）</li><li>定义传输模式 （单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li></ul><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><blockquote><p>由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。<br>三层都在应用程序内实现，程序间无法共享，合三为一就形成了 TCP/IP 模型。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091411643.png" style="zoom: 33%;" /><ul><li><p><strong>应用层</strong><br>  TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。</p><p>  例如：FTP、Telnet、DNS、SMTP 等。</p></li><li><p><strong>传输层</strong></p><p>  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。</p><p>  传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。</p><p>  其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p></li><li><p><strong>网际互联层</strong></p><p>  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。</p><p>  在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。</p><p>  根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。</p><p>  除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p></li><li><p><strong>网络接口层</strong></p><p>  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</p><p>  事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p></li></ul><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091513659.png" style="zoom: 67%;" /><h2 id="2、模型异同"><a href="#2、模型异同" class="headerlink" title="2、模型异同"></a>2、模型异同</h2><p><strong>相同点</strong></p><ul><li><p>OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p></li><li><p>都能够提供面向连接和无连接两种通信服务机制。</p></li></ul><p><strong>不同点</strong></p><ul><li><p>OSI 采用的七层模型； TCP/IP 是四层结构。</p></li><li><p>TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p></li><li><p>OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p></li><li><p>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p></li><li><p>OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091512496.png" alt="image-20211209151215402" style="zoom:50%;" /><h2 id="3、各层协议"><a href="#3、各层协议" class="headerlink" title="3、各层协议"></a>3、各层协议</h2><table>    <tbody><tr><th>OSI 七层网络模型</th><th>TCP/IP 四层概念模型</th><th>对应的网络协议</th>    </tr>    <tr><td>应用层（Application）</td><td rowspan="3">应用层</td>        <td><b>HTTP, FTP, DNS</b>, SMTP,TFTP,NFS, WAIS, Telnet, SNMP</td>    </tr>    <tr><td>表示层（Presentation）</td><td>TIFF, GIF, JPEG, PICT</td>    </tr>    <tr><td>会话层（Session）</td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>    </tr>    <tr><td>传输层（Transport）</td><td>传输层</td>        <td><b>TCP, UDP</b></td>    </tr>    <tr><td>网络层（Network）</td><td>网际层</td>        <td><b>IP</b>, ICMP, ARP, RARP, RIP, IPX</td>    </tr>    <tr><td>数据链路层（Data Link）</td><td rowspan="2">网络接口层</td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>    </tr>    <tr><td>物理层（Physical）</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>    </tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络主要有3种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO/OSI参考模型 7层&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型 5层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP/IP参考模型 4层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;是一种理论下的&lt;strong&gt;模型&lt;/strong&gt;，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://blog.sukiu.top/Database/Redis/"/>
    <id>http://blog.sukiu.top/Database/Redis/</id>
    <published>2021-12-07T01:22:55.000Z</published>
    <updated>2021-12-22T07:46:58.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis (Remote Dictionary Server ) 远程字典服务</strong>，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。</p><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。</p><p>和Memcached类似，它支持存储的value类型相对更多，包括：</p><ul><li>string（字符串）</li><li>list（链表）</li><li>set（集合）</li><li>zset（sorted set 有序集合）</li><li>hash（哈希类型）</li></ul><p>与 memcached 一样，为了保证效率，数据都是缓存在<strong>内存</strong>中。<br>区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://www.w3cschool.cn/redis/">Redis 教程_w3cschool</a><br><a href="https://juejin.cn/post/6909672227734552583">Redis使用教程 - 掘金</a></p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高 </li></ul><blockquote><p>Redis能读的速度是110000次/s,写的速度是81000次/s 。</p></blockquote><ul><li>丰富的数据类型</li></ul><blockquote><p>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p></blockquote><ul><li>原子</li></ul><blockquote><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p></blockquote><ul><li>丰富的特性</li></ul><blockquote><p>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h4 id="Redis-与其他-key-value-存储的区别"><a href="#Redis-与其他-key-value-存储的区别" class="headerlink" title="Redis 与其他 key-value 存储的区别"></a>Redis 与其他 key-value 存储的区别</h4><ul><li>Redis 运行在内存中但是可以 <strong>持久化到磁盘</strong>，重启的时候可以再次加载进行使用。</li><li>Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。</li><li>Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。</li></ul><h4 id="Redis-和-MongoDB-的区别"><a href="#Redis-和-MongoDB-的区别" class="headerlink" title="Redis 和 MongoDB 的区别"></a>Redis 和 MongoDB 的区别</h4><p>更多可见：<a href="https://zhuanlan.zhihu.com/p/86777551">NoSQL，浅谈redis与mongoDB的区别 - 知乎</a></p><ul><li><strong>性能方面</strong>，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB；</li><li><strong>可操作性上</strong>，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 <strong>丰富的查询语言</strong>，操作比 Redis 更为便利；</li><li><strong>内存及存储方面</strong>，MongoDB 适合 <strong>大数据量存储</strong>，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 <strong>虚拟内存特性</strong>，突破物理内存限制，数据可以设置时效性；</li><li><strong>对于数据持久化和数据恢复</strong>，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能；</li><li><strong>在数据一致性上</strong>，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行；</li><li><strong>数据分析上</strong>，MongoDB 内置 <strong>数据分析功能（mapreduce）</strong>，而 Redis 不支持数据分析；</li><li><strong>应用场景不同</strong>，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Redis</code>支持五种数据类型：</p><ul><li><code>string（字符串）</code></li><li><code>hash（哈希）</code></li><li><code>list（列表）</code></li><li><code>set（集合）</code></li><li><code>zset(sorted set：有序集合)</code></li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>最基本的类型，一个<code>key</code>对应一个<code>value</code>。<br><code>string</code>类型是二进制安全的，即<code>redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</p><blockquote><p>一个键最大能存储512MB。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sukiu.top&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-strings.html">Redis 字符串(String)_w3cschool</a></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p><code>Redis hash</code> 是一个键值 <code>(key=&gt;value)</code> 对集合。<br><code>Redis hash</code> 是一个 <code>string</code> 类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象。</p><blockquote><p>每个 <code>hash</code> 可以存储 232 - 1键值对（40多亿）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">3) <span class="string">&quot;password&quot;</span></span><br><span class="line">4) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">5) <span class="string">&quot;points&quot;</span></span><br><span class="line">6) <span class="string">&quot;200&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;password&quot;</span></span><br><span class="line">3) <span class="string">&quot;points&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-hashes.html">Redis 哈希(Hash)_w3cschool</a></p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>Redis</code> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><blockquote><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange <span class="built_in">test</span> 0 10</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-lists.html">Redis 列表(List)_w3cschool</a></p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>Redis</code> 的 <code>Set</code>是 <code>string</code> 类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><blockquote><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd t1 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers t1</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sets.html">Redis 集合(Set)_w3cschool</a></p><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>和 <code>set</code> 不同的是每个元素都会关联一个 <code>double</code> 类型的分数。<code>redis</code> 正是通过分数来为集合中的成员进行从小到大的排序。</p><p><code>zset</code> 的成员是唯一的,但分数<code>(score)</code>却可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd t2 0 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore t2 0 1000</span><br><span class="line">1) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">2) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sorted-sets.html">Redis 有序集合(sorted set)_w3cschool</a></p><h2 id="2、高级"><a href="#2、高级" class="headerlink" title="2、高级"></a>2、高级</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><blockquote><p>更多：<br><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理 - SegmentFault 思否</a></p></blockquote><p>Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。<br>Redis支持两种方式的持久化：RDB快照和AOF。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。<br>它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。<br>到目前为止，仍是官方的默认支持方案。</p><p><strong>原理：</strong> Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><blockquote><p>整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。</p></blockquote><p><strong>优点</strong>:</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要不高</li></ol><p><strong>缺点</strong>：</p><ol><li>需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了</li><li>fork进程的时候，会占用一定的内容空间</li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File），它是Redis的完全持久化策略。</p><p><strong>原理：</strong> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。<br>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no-关闭，yes-开启，默认no</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;appendonTy.aof&quot;</span> <span class="comment">#持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always #每次修改都会sync,消耗性能 </span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒执行一次sync,可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快!</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>每一次修改都同步，文件的完整会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong>：</p><ol><li>相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><ul><li>前者称为主节点(master/leader)</li><li>后者称为从节点(slavel/follower)</li><li>数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</li></ul><blockquote><p>默认情况下，每台Redis服务器都是主节点<br>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</p></blockquote><p>主从复制的作用主要包括:</p><ul><li>数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><blockquote><p>更多：<br><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780">redis系列之——高可用（主从、哨兵、集群）</a></p></blockquote><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><p>原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。<br>redis 为了避免单点故障，也需要部署多台机器。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071701844.png" alt="主从"></p><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。<br>实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 <del>自动选取老大的模式</del></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071704740.png" alt="哨兵" style="zoom:50%;" /><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。<br>在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071707386.png" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Redis (Remote Dictionary Server ) 远程字典服务&lt;/strong&gt;，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。&lt;/p&gt;
&lt;p&gt;Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string（字符串）&lt;/li&gt;
&lt;li&gt;list（链表）&lt;/li&gt;
&lt;li&gt;set（集合）&lt;/li&gt;
&lt;li&gt;zset（sorted set 有序集合）&lt;/li&gt;
&lt;li&gt;hash（哈希类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 memcached 一样，为了保证效率，数据都是缓存在&lt;strong&gt;内存&lt;/strong&gt;中。&lt;br&gt;区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Redis" scheme="http://blog.sukiu.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://blog.sukiu.top/Language/SQL/"/>
    <id>http://blog.sukiu.top/Language/SQL/</id>
    <published>2021-12-02T12:58:04.000Z</published>
    <updated>2021-12-22T07:46:52.547Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 语句可分为以下几类：</p><ul><li>数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 <code>CREATE</code>，<code>DROP</code>，<code>ALTER</code></li><li>数据查询语言 DQL（Data Query Language）：即查询操作，以 <code>SELECT</code> 关键字为主</li><li>数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 <code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code></li><li>数据控制功能 DCL（Data Control Language）：即权限控制操作，如 <code>GRANT</code>，<code>REVOKE</code>，<code>COMMIT</code>，<code>ROLLBACK</code></li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxsgh2/">常用 SQL 语句 - LeetCode</a><br><a href="https://juejin.cn/post/6983974232656969742">SQL约束 - 掘金</a></p></blockquote><h2 id="1、键"><a href="#1、键" class="headerlink" title="1、键"></a>1、键</h2><ul><li><strong>超键</strong>：在关系中，能唯一标识元组的属性集称为关系模式的超键。</li></ul><blockquote><p>一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<br>超键包含候选键和主键。</p></blockquote><ul><li><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</li><li><strong>主键</strong>：数据库表中对储存数据对象予以 <strong>唯一和完整标识的数据列或属性的组合</strong>。</li></ul><blockquote><p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</p></blockquote><ul><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><blockquote><p>外键可以有重复的, 可以是空值。</p></blockquote><h2 id="2、约束"><a href="#2、约束" class="headerlink" title="2、约束"></a>2、约束</h2><p>约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p><ul><li><strong>非空约束（NOT NULL）</strong>：保证该字段值一定不为空；</li><li><strong>默认约束（DEFAULT）</strong>：保证字段有默认值；</li><li><strong>主键约束（PRIMARY KEY）</strong>：标志一列或者多列，并保证其值在表内的唯一性；</li><li><strong>外键约束（FOREIGN KEY）</strong>：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；</li><li><strong>唯一约束（UNIQUE）</strong>： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；</li><li><strong>检查约束（CHECK）</strong>：限制一列的可用值范围。</li></ul><h3 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h3><ol><li>创建表时，在字段描述处，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key, <span class="comment">-- 添加了主键约束</span></span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表时，在constraint约束区域，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">INT</span>,</span><br><span class="line">  lastname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  firstname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> pk_persons <span class="keyword">PRIMARY</span> KEY (lastname, firstname) <span class="comment">-- 添加主键约束, 多个字段, 我们称为联合主键。</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建表之后，通过修改表结构，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加联合主键约束</span></span><br><span class="line"><span class="comment">-- 其他约束类似</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">add</span> <span class="keyword">constraint</span> pk_persons <span class="keyword">primary</span> key (lastname, firstname); </span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除主键约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP PRIMARY KEY</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除非空约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons modify lastname <span class="type">varchar</span>(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP INDEX 名称</span></span><br><span class="line"><span class="comment">-- 有唯一约束名称, 使用约束名称删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index uni_persons_address; </span><br><span class="line"><span class="comment">-- 没有唯一约束名称, 使用字段名删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index address; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、SQL语句"><a href="#3、SQL语句" class="headerlink" title="3、SQL语句"></a>3、SQL语句</h2><p>参考w3cschool即可：</p><blockquote><p><a href="https://www.w3cschool.cn/sql/sql-sentence.html">详尽的SQL语句大全分类整理_w3cschool</a></p></blockquote><p>下面列出一些重点：</p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。</p><ul><li><p><strong>交叉连接（CROSS JOIN）</strong></p><p>  除了在 <code>FROM</code> 子句中使用 <strong>逗号间隔连接的表</strong> 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 <strong>笛卡尔积</strong>，返回到的数据行数等于第一个表中符合查询条件的数据行数 <strong>乘以</strong> 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 <code>CROSS JOIN</code> 关键字而不是逗号，即以下两个表达式等价：</p><p>  <code>SELECT  *  FROM  A, B</code><br>  <code>SELECT  *  FROM  A  CROSS JOIN  B</code></p></li><li><p><strong>内连接（INNER JOIN）</strong></p><p>  内连接分为三类，分别是 <strong>等值连接</strong>：<code>ON A.id = B.id</code>、<strong>不等值连接</strong>：<code>ON A.id &gt; B.id</code> 和 <strong>自连接</strong>：<code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid</code></p></li><li><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><p>  <strong>左外连接</strong>：以左表为主，先查询出左表，按照 <code>ON</code> 后的关联条件匹配右表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>LEFT JOIN</code></p><p>  <strong>右外连接</strong>：以右表为主，先查询出右表，按照 <code>ON</code> 后的关联条件匹配左表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>RIGHT JOIN</code></p></li><li><p><strong>联合查询（UNION 与 UNION ALL）</strong></p><p>  <code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></p><p>  联合查询就是把多个结果集集中在一起，<code>UNION</code> 前的结果为基准，需要注意的是联合查询的 <strong>列数要相等</strong>，相同的记录行会合并；</p><p>  如果使用 <code>UNION ALL</code>，不会合并重复的记录行，所以效率更高。</p></li><li><p><strong>全连接（FULL JOIN）</strong></p><p>  MySQL 本身不支持全连接，但可以通过联合使用 <code>LEFT JOIN</code>、<code>UNION</code> 和 <code>RIGHT JOIN</code> 来实现。</p><p>  <code>SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id</code></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。</p><p>子查询是一个 <code>SELECT</code> 语句，它嵌套在另一个 <code>SELECT</code>、<code>SELECT…INTO</code> 语句、<code>INSERT…INTO</code> 语句、<code>DELETE</code> 语句、 <code>UPDATE</code> 语句或嵌套在另一子查询中。</p><p>MySQL 的子查询是多表查询的一个重要组成部分，常常和 <strong>连接查询</strong> 一起使用，是多表查询的基础。</p><p>子查询分为以下四类：</p><ul><li><p><strong>标量子查询</strong></p><p>  查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。</p></li><li><p><strong>列子查询</strong></p><p>  子查询返回的结果集是 N 行一列，该结果通常来自对表的 <strong>某个字段</strong> 查询返回。</p></li><li><p><strong>行子查询</strong></p><p>  子查询返回的结果集是一行 N 列，该结果通常是对表的 <strong>某行数据</strong> 进行查询而返回的结果集</p></li><li><p><strong>表子查询</strong></p><p>  子查询返回的结果集是 N 行 N 列的一个表数据。</p></li></ul><h3 id="char-与-varchar-的区别"><a href="#char-与-varchar-的区别" class="headerlink" title="char 与 varchar 的区别"></a>char 与 varchar 的区别</h3><ul><li>char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；</li><li>使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；</li></ul><h3 id="DROP、DELETE-与-TRUNCATE-的区别"><a href="#DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="DROP、DELETE 与 TRUNCATE 的区别"></a>DROP、DELETE 与 TRUNCATE 的区别</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">DROP</th><th style="text-align:center">DELETE</th><th style="text-align:center">TRUNCATE</th></tr></thead><tbody><tr><td style="text-align:center">SQL 语句类型</td><td style="text-align:center">DDL</td><td style="text-align:center">DML</td><td style="text-align:center">DDL</td></tr><tr><td style="text-align:center">回滚</td><td style="text-align:center">不可回滚</td><td style="text-align:center">可回滚</td><td style="text-align:center">不可回滚</td></tr><tr><td style="text-align:center">删除内容</td><td style="text-align:center">从数据库中 <strong>删除表</strong>，所有的数据行，索引和权限也会被删除</td><td style="text-align:center">表结构还在，删除表的 <strong>全部或者一部分数据行</strong></td><td style="text-align:center">表结构还在，删除表中的 <strong>所有数据</strong></td></tr><tr><td style="text-align:center">删除速度</td><td style="text-align:center">删除速度最快</td><td style="text-align:center">删除速度慢，需要逐行删除</td><td style="text-align:center">删除速度快</td></tr></tbody></table><blockquote><p>在不再需要一张表的时候，采用 <code>DROP</code><br>在想删除部分数据行时候，用 <code>DELETE</code><br>在保留表而删除所有数据的时候用 <code>TRUNCATE</code></p></blockquote><h3 id="UNION-与-UNION-ALL-的区别"><a href="#UNION-与-UNION-ALL-的区别" class="headerlink" title="UNION 与 UNION ALL 的区别"></a>UNION 与 UNION ALL 的区别</h3><ul><li><code>UNION</code> 用于把来自多个 <code>SELECT</code> 语句的结果组合到一个结果集合中，MySQL 会把结果集中 <strong>重复的记录删掉</strong></li><li><code>UNION ALL</code>，MySQL 会把所有的记录返回，且效率高于 <code>UNION</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL 语句可分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 &lt;code&gt;CREATE&lt;/code&gt;，&lt;code&gt;DROP&lt;/code&gt;，&lt;code&gt;ALTER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据查询语言 DQL（Data Query Language）：即查询操作，以 &lt;code&gt;SELECT&lt;/code&gt; 关键字为主&lt;/li&gt;
&lt;li&gt;数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 &lt;code&gt;INSERT&lt;/code&gt;，&lt;code&gt;UPDATE&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据控制功能 DCL（Data Control Language）：即权限控制操作，如 &lt;code&gt;GRANT&lt;/code&gt;，&lt;code&gt;REVOKE&lt;/code&gt;，&lt;code&gt;COMMIT&lt;/code&gt;，&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
    <category term="SQL" scheme="http://blog.sukiu.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>B Tree</title>
    <link href="http://blog.sukiu.top/Data-structure/B-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/B-Tree/</id>
    <published>2021-11-29T11:07:44.000Z</published>
    <updated>2021-12-22T07:46:47.125Z</updated>
    
    <content type="html"><![CDATA[<p>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。</p><ul><li>特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；</li><li>把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。</li></ul><span id="more"></span><blockquote><p>转载：</p><p><a href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p></blockquote><h2 id="1、B-树-B-tree"><a href="#1、B-树-B-tree" class="headerlink" title="1、B 树(B-tree)"></a>1、B 树(B-tree)</h2><blockquote><p>注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树;</p></blockquote><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构</p><p><strong>规则：</strong></p><ul><li>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉）</li><li>（3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2)</li><li>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子</li></ul><p><strong>例子：</strong></p><p>来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_b.jpg"/></p><h3 id="2、B-树的查询"><a href="#2、B-树的查询" class="headerlink" title="2、B 树的查询"></a>2、B 树的查询</h3><p>如上图我要从上图中找到 E 字母，查找流程如下</p><ul><li>（1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>（2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点；</li><li>（3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；</li></ul><h3 id="3、B-树的插入"><a href="#3、B-树的插入" class="headerlink" title="3、B 树的插入"></a>3、B 树的插入</h3><p>定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来;</p><ul><li>（1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）；</li><li>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li></ul><ol><li>先插入 3、8、31、11 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-e1d65c9c6236d4768c89e8e103e12583_b.jpg"/></li><li>再插入 23、29 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-66cdb6187cbc5227fd8c4aabe7282e6c_b.jpg"/></li><li>再插入 50、28 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-3057eaab2b1764dd51c2a8658791cc98_b.jpg"/></li></ol><h3 id="3、B-树的删除"><a href="#3、B-树的删除" class="headerlink" title="3、B 树的删除"></a>3、B 树的删除</h3><ul><li>（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li><li>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</li><li>（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-a0f981fc847772cb28869927cd4fe66d_b.jpg"/><h2 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a>2、B+树</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p>B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询<u>速度</u>更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别</p><ul><li>（1）B+跟B树不同B+树的<b>非叶子</b>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<b>非叶子</b>节点所能保存的关键字大大增加；</li><li>（2）B+树<b>叶子</b>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）;</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-5f069fd820637db1b877fdd6799a2b67_b.jpg"/><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_b.jpg"/><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>1、B+<b>树的层级更少</b>：相较于 B 树 B+每个<b>非叶子</b>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<b>树查询速度更稳定</b>：B+所有关键字数据地址都存在<b>叶子</b>节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定;</p><p>3、B+<b>树天然具备排序功能：</b>B+树所有的<b>叶子</b>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。</p><p>4、B+<b>树全节点遍历更快：</b>B+树遍历整棵树只需要遍历所有的<b>叶子</b>节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 <b>B 树</b>相对于<b>B+树</b>的优点是，如果经常访问的数据离根节点很近，而<b>B 树</b>的<b>非叶子</b>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<b>B+树</b>快。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="1、相同思想和策略"><a href="#1、相同思想和策略" class="headerlink" title="1、相同思想和策略"></a>1、相同思想和策略</h3><p>从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><h3 id="2、不同的方式的磁盘空间利用"><a href="#2、不同的方式的磁盘空间利用" class="headerlink" title="2、不同的方式的磁盘空间利用"></a>2、不同的方式的磁盘空间利用</h3><p>不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；&lt;/li&gt;
&lt;li&gt;把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://blog.sukiu.top/Database/Database-Introduction/"/>
    <id>http://blog.sukiu.top/Database/Database-Introduction/</id>
    <published>2021-11-27T01:58:35.000Z</published>
    <updated>2021-12-22T07:46:40.622Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库（Database）</strong> 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 <strong>数据库管理系统（DataBase- Management System，DBMS）</strong> 创建和操纵的容器。</p><p><strong>DBMS</strong> 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxhvpv/">数据库知识手册</a></p></blockquote><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>数据库有两种类型，分别是 <strong>关系型数据库</strong> 和 <strong>非关系型数据库</strong>。</p><table><thead><tr><th>数据库类型</th><th>定义</th><th>优点</th><th>缺点</th><th>常见</th></tr></thead><tbody><tr><td>关系型数据库</td><td>建立在关系模型基础上，由多张能互相连接的 <strong>表</strong> 组成的数据库</td><td>    <ol>    <li>使用表结构，格式一致，易于维护；    <li>使用 SQL 语句，可用于复杂查询；    <li>数据存储在磁盘中，安全性高    </ol></td><td>    <ol>    <li>读写性能比较差；    <li>建立在关系模型上，不可避免空间浪费；    <li>固定的表结构，灵活度较低    </ol></td><td>MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等</td></tr><tr><td>非关系型数据库</td><td>非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 <strong>对象</strong> 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</td><td>    <ol>    <li>存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛；    <li>可轻松进行海量数据的维护和处理；    <li>具有可扩展、高并发、高稳定性、成本低的优势；    <li>可以实现数据的分布式处理    </ol></td><td>    <ol>        <li>不提供 SQL 支持；    <li>无事务处理，无法保证数据的完整性和安全性；    <li>功能没有关系型数据库完善    </ol></td><td>Neo4j，Redis，MongoDB 等</td></tr></tbody></table><blockquote><p><strong>SQL</strong> 是 <strong>结构化查询语言（Structured Query Language）</strong> 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。</p><p><strong>MySQL</strong> 是一个 <strong>关系数据库管理系统（RDBMS）</strong>，使用 SQL 执行所有数据库操作。</p></blockquote><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB</li><li>完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB</li><li>传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。</p><p>常用的数据库三大范式为：</p><ul><li><strong>第一范式（1NF）</strong>：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。<strong>关系模式的基本要求</strong></li><li><strong>第二范式（2NF）</strong>：在第一范式的基础上，一个表必须有一个主键，非主键列 <strong>完全依赖</strong> 于主键，而不能是依赖于主键的一部分。<strong>消除部分依赖</strong></li><li><strong>第三范式（3NF）</strong>：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。<strong>消除传递依赖</strong></li></ul><h2 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h2><p>索引是一种 <strong>数据结构</strong>。数据库索引是 DBMS 中一个 <strong>排序的数据结构</strong>，以 <strong>协助快速查询、更新</strong> 数据库表中数据。</p><p>索引的实现通常使用 <a href="https://blog.sukiu.top/Data-structure/B-Tree/">B 树以及变种 B+ 树</a>。</p><p>以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。</p><table><tr><td>优点</td><td>缺点</td></tr><tr><td><ul>    <li>通过创建 <strong>唯一性索引 </strong>，可以保证数据库表中每一行数据的唯一性；    <li> 可以加快数据的  <strong>检索速度 </strong>，这也是创建索引的主要原因；    <li>可以加速表和表之间的连接，特别是在实现  <strong>数据的参考完整性 </strong> 方面特别有意义；    <li>通过使用索引，可以在查询的过程中，使用  <strong>优化隐藏器 </strong>，提高系统性能。</ul></td><td><ul>    <li>时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；    <li>空间上，索引需要占  <strong>物理空间 </strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</ul></td></tr></table><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>数据库索引根据结构分类，主要有 <strong>B 树索引</strong>（使用最频繁）、<strong>Hash 索引</strong> 和 <strong>位图索引</strong> 三种。</p><blockquote><p>关于 B 树可以参考：<a href="https://blog.sukiu.top/Data-structure/B-Tree/">B Tree</a></p></blockquote><p><strong>使用 B+ 树的优点：</strong></p><ul><li>由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。</li><li>B+ 树的叶结点由一条链相连，因此当需要进行一次 <strong>全数据遍历</strong> 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 <strong>大于某个关键字或者小于某个关键字的数据</strong> 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。</li></ul><p><strong>Hash 索引和 B+ 树索引的区别：</strong></p><ul><li>Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；</li><li>Hash 索引不支持使用索引进行排序；</li><li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；</li><li>Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；</li><li>Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。</li></ul><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引指将 <strong>数据存储</strong> 和 <strong>索引</strong> 放到一起，找到索引也就找到了数据。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/1628676447-LHnlSz-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="聚簇索引" style="zoom: 50%;" /><h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>数据库的 <strong>事务</strong>（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p><blockquote><p>如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。</p></blockquote><p>因此，事务是保持 <strong>逻辑数据一致性</strong> 和 <strong>可恢复性</strong> 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>事务具有 4 个特性，通常简称为 ACID，<strong>关系型数据库</strong> 需要遵循 ACID 规则。</p><ul><li><p>原子性（Atomicity）</p><p>  事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</p><blockquote><p>以银行转账事务为例：</p><p>如果该事务提交了，则这两个账户的数据将会更新；</p><p>如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 <strong>撤销</strong> 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。</p></blockquote></li><li><p>一致性（Consistency）</p><p>  当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。</p><blockquote><p>以银行转账事务事务为例：</p><p>在事务开始之前，所有 <strong>账户余额的总额处于一致状态</strong>。</p><p>在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。</p><p>因此，所有账户余额的总额处于不一致状态。</p><p>但是当事务完成以后，账户余额的总额再次恢复到一致状态。</p></blockquote></li><li><p>隔离性（Isolation）</p><p>  <strong>并发访问数据库</strong> 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</p><blockquote><p>修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。</p></blockquote></li><li><p>持久性（Durability）</p><p>  一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>DBMS 采用 <strong>日志</strong> 来保证事务的 <strong>原子性</strong>、<strong>一致性</strong> 和 <strong>持久性</strong>。</p><blockquote><p>日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></blockquote><p>DBMS 采用 <strong>锁机制</strong> 来实现事务的隔离性。</p><blockquote><p>当多个事务同时更新数据库中相同的数据时，只允许 <strong>持有锁的事务</strong> 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></blockquote><p><strong>相应的原理</strong></p><ul><li>原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li><li>一致性：一般由代码层面来保证</li><li>隔离性：由MVCC来保证</li><li>持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul><li><p>脏读（Dirty Read）</p><p>  一个事务读取了另一个事务未提交的数据。</p></li><li><p>不可重复读（Non-repeatable Read）</p><p>  就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。</p></li><li><p>幻读（Phantom Read）</p><p>  幻读是指当事务 <strong>不是独立执行时</strong> 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 <strong>插入一行新数据</strong>。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p></li><li><p>丢失更新（Lost Update）</p><p>  两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 <strong>并发事务对同一资源的读取深度层次</strong>。</p><p>由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE）</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交(RU)</td><td>只能保证不读取物理上的损坏</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交(RC)</td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读(RR)</td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化(SR)</td><td>最高级别，事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>从数据库系统的角度，锁模式可分为以下6 种类型：</p><ul><li><p><strong>共享锁（S）</strong>：又叫 <strong>他读锁</strong>。</p><p>  可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。</p></li><li><p><strong>排它锁（X）</strong>：又叫 <strong>独占锁</strong>、<strong>写锁</strong>。</p><p>  对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。</p></li><li><p><strong>更新锁（U）</strong>：</p><p>  防止出现 <strong>死锁</strong> 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。</p><p>  资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。</p></li><li><p><strong>意向锁</strong>：</p><p>  表示 SQL Server 需要在 <strong>层次结构中的某些底层资源上</strong> 获取共享锁或排它锁。</p><p>  例如，放置在 <strong>表级</strong> 的 <strong>共享意向锁</strong> 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。</p><p>  意向锁可以提高性能，因为 SQL Server 仅在 <strong>表级</strong> 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。</p><p>  意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。</p></li><li><p><strong>架构锁</strong>：</p><p>  在执行 <strong>依赖于表架构的操作</strong> 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。</p></li><li><p><strong>大容量更新锁（BU）</strong>：</p><p>  向表中大容量复制数据并指定了 <code>TABLOCK</code> 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>在 <strong>读取未提交</strong> 隔离级别下，读取数据不需要加 <strong>共享锁</strong>，这样就不会跟被修改的数据上的 <strong>排他锁</strong> 冲突；</li><li>在 <strong>读取已提交</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在语句执行完以后释放共享锁；</li><li>在 <strong>可重复读</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</li><li><strong>可串行化</strong> 是限制性最强的隔离级别，因为该级别 <strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><ul><li>如果不同程序并发存取多个表，尽量约定 <strong>以相同的顺序访问表</strong>，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到 <strong>一次锁定所需要的所有资源</strong>，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用 <strong>升级锁定颗粒度</strong>，通过 <strong>表级锁</strong> 定来减少死锁产生的概率。</li></ul><h3 id="乐-悲观锁"><a href="#乐-悲观锁" class="headerlink" title="乐/悲观锁"></a>乐/悲观锁</h3><p>DBMS 中的 <strong>并发控制</strong> 的任务是确保在 <strong>多个事务同时存取数据库中同一数据</strong> 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 <strong>读多写少</strong> 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库（Database）&lt;/strong&gt; 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 &lt;strong&gt;数据库管理系统（DataBase- Management System，DBMS）&lt;/strong&gt; 创建和操纵的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DBMS&lt;/strong&gt; 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://blog.sukiu.top/Knowledge/Bit-Operation/"/>
    <id>http://blog.sukiu.top/Knowledge/Bit-Operation/</id>
    <published>2021-11-25T11:12:14.000Z</published>
    <updated>2021-12-22T07:46:33.943Z</updated>
    
    <content type="html"><![CDATA[<p>计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。</p><p>位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。</p><p>上述位运算中，只有取反是一元运算，其余的都是二元运算。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math/o2zy8j/">位运算符的概念和性质</a></p></blockquote><h2 id="1、与、或、异或和取反"><a href="#1、与、或、异或和取反" class="headerlink" title="1、与、或、异或和取反"></a>1、与、或、异或和取反</h2><ul><li>与运算的符号是 $\And$ ，运算规则是：全 1 为 1，有 0 为 0</li><li>或运算的符号是 $∣$ ，运算规则是：有 1 为 1，全 0 为 0</li><li>异或运算的符号是 $\oplus$（在代码中用 $\wedge$ 表示异或），运算规则是：相同为 0 ，不同为 1</li><li>取反运算的符号是 $\sim$，运算规则是：0 变 1， 1 变 0</li></ul><h2 id="2、移位运算"><a href="#2、移位运算" class="headerlink" title="2、移位运算"></a>2、移位运算</h2><p>移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。</p><ul><li><p>左移运算的符号是 $&lt;&lt;$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。</p></li><li><p>右移运算的符号是 $&gt;&gt;$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：</p><ul><li>算术右移时，高位补最高位；</li><li>逻辑右移时，高位补 0。</li></ul></li></ul><blockquote><p>C++ 中：<br>对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。<br>Java 中：<br>不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。<br>算术右移的符号是 $&gt;&gt;$，逻辑右移的符号是 $&gt;&gt;&gt;$<br>Go 中：<br>只有算数移位</p></blockquote><h2 id="3、位运算与乘除法"><a href="#3、位运算与乘除法" class="headerlink" title="3、位运算与乘除法"></a>3、位运算与乘除法</h2><p>使用移位运算实现乘除法的效率显著<strong>高</strong>于直接乘除法的效率。</p><ul><li><p>左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$</p><ul><li><p>例如，$29 &lt;&lt; 2 = 116$，等价于 $ 29 \times 4  $</p></li><li><p>当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和：</p><p>  例如，$a \times 6$ 等价于 $(a&lt;&lt;2)+(a&lt;&lt;1)$</p></li><li><p>对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。</p></li></ul></li><li><p>算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$</p><ul><li>例如，$50 &gt;&gt; 2  =  12$ ，等价于 $50 / 4$，结果向下取整</li><li>一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是<strong>不等价</strong>的（只对0和正数成立）</li></ul></li></ul><p>同时，位运算也能用来替代取模运算判断奇偶：</p><ul><li>奇数：$整数&amp;1==1$（二进制最低位是1，就是奇数</li><li>偶数：$整数&amp;1==0$（二进制最低位是0，就是偶数</li></ul><h2 id="4、位运算性质"><a href="#4、位运算性质" class="headerlink" title="4、位运算性质"></a>4、位运算性质</h2><p>此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。</p><ul><li>幂等律：$a \And a = a$ ，$a ∣ a=a$ （注意异或不满足幂等律）</li><li>交换律：$a \And b = b \And a$，$a ∣ b = b ∣ a$，$a \oplus b = b \oplus a$</li><li>结合律：$(a \And b) \And c = a \And (b \And c)$，$(a ∣ b) ∣ c = a ∣ (b ∣ c)$，$(a \oplus b) \oplus c = a \oplus (b \oplus c)$</li><li>分配律：$(a \And b) ∣ c = (a ∣ c) \And (b ∣ c)$，$(a ∣ b) \And c = (a \And c) ∣ (b \And c)$，$(a ⊕ b) \And c = (a \And c) ⊕ (b \And c)$</li><li>德·摩根律：$\sim (a \And b) = ( \sim a) ∣ (\sim b)$ ，$\sim(a ∣ b) = (\sim a) \And (\sim b)$</li><li>取反运算性质：$-1 = \sim 0，-a = \sim (a-1)$</li><li>与运算性质：$a \And 0 = 0$，$a \And (-1) = a$，$a \And (\sim a) = 0$</li><li>或运算性质：$a ∣ 0 = a$，$a ∣ (\sim a) = -1$</li><li>异或运算性质：$a \oplus 0 = a$，$a \oplus a = 0$</li><li>其他性质：<ul><li>$a \And (a-1)$ 的结果：将 a 的二进制表示的最后一个 1 变成 0</li><li>$a \And (-a)$（与 $a \And (\sim (a-1))$ 等价）的结果：只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。&lt;/p&gt;
&lt;p&gt;位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;上述位运算中，只有取反是一元运算，其余的都是二元运算。&lt;/p&gt;</summary>
    
    
    
    <category term="Knowledge" scheme="http://blog.sukiu.top/categories/Knowledge/"/>
    
    
    <category term="Bit Operation" scheme="http://blog.sukiu.top/tags/Bit-Operation/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="http://blog.sukiu.top/Data-structure/Hash-Insider/"/>
    <id>http://blog.sukiu.top/Data-structure/Hash-Insider/</id>
    <published>2021-11-21T08:35:42.000Z</published>
    <updated>2021-12-22T07:46:27.279Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。</p><span id="more"></span><h2 id="1、散列"><a href="#1、散列" class="headerlink" title="1、散列"></a>1、散列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>散列：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200145426.png" style="zoom: 50%;" ><p><strong>碰撞：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200248821.png" style="zoom:50%;" ><p><strong>散列函数：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200340573.png" style="zoom:50%;" ><p><strong>除余法：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200516454.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201009675.png" alt="例子"><br><img src="https://img-blog.csdnimg.cn/20200715200642965.png" alt="例子"></p><center>m=16*2=32<br>p=31<br>散列函数 h(key)=key%p</center> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200920178.png" style="zoom:50%;" ><h3 id="线性勘察法（开地址法处理碰撞）"><a href="#线性勘察法（开地址法处理碰撞）" class="headerlink" title="线性勘察法（开地址法处理碰撞）"></a>线性勘察法（开地址法处理碰撞）</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201346320.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201441361.png" alt="例子"> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201549656.png" style="zoom:50%;" ></p><p>已知n个关键码具有相同的散列值d，若采用<strong>线性探查法</strong>解决碰撞，则在散列这n个关键码的过程中，共将要发生<font color="red">n(n-1)/2</font>    次碰撞</p><h3 id="拉链法解决碰撞"><a href="#拉链法解决碰撞" class="headerlink" title="拉链法解决碰撞"></a>拉链法解决碰撞</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201943887.png" style="zoom:50%;" ><p>例子：</p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202142441.png" style="zoom:50%;" ><p>平均查找长度ASL：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202641565.png" style="zoom:50%;" ><h2 id="2、常见的三种哈希结构"><a href="#2、常见的三种哈希结构" class="headerlink" title="2、常见的三种哈希结构"></a>2、常见的三种哈希结构</h2><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a></p></blockquote><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li>std::unordered_set底层实现为哈希表</li><li>std::set 和std::multiset 的底层实现是红黑树</li></ul><blockquote><p>红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p></blockquote><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li><p>std::unordered_map 底层实现为哈希表</p></li><li><p>std::map 和std::multimap 的底层实现是红黑树</p></li></ul><p>使用时：</p><ul><li>解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的</li><li>如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</li></ul><p>map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><blockquote><p>java里的HashMap ，TreeMap 都是一样的原理。</p></blockquote><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20210104235134572.png" alt="哈希表" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Hash" scheme="http://blog.sukiu.top/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search 二分查找</title>
    <link href="http://blog.sukiu.top/Algorithm/Binary-Search/"/>
    <id>http://blog.sukiu.top/Algorithm/Binary-Search/</id>
    <published>2021-11-21T08:23:43.000Z</published>
    <updated>2021-12-22T07:46:18.781Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找也称折半查找，它是一种效率较高的查找方法。</p><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>数组为有序数组，数组中无重复元素。</p><p>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。</p><ul><li>到底是 while(left &lt; right) 还是 while(left &lt;= right)？</li><li>到底是right = middle呢，还是要right = middle - 1呢？</li></ul><p>区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><h3 id="1、左闭右闭"><a href="#1、左闭右闭" class="headerlink" title="1、左闭右闭"></a>1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，也就是[left, right]</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;  <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        middle := left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &gt; target &#123;</span><br><span class="line">            right = middle - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target &#123;</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、左闭右开"><a href="#2、左闭右开" class="headerlink" title="2、左闭右开"></a>2、左闭右开</h3><p>定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();  <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;    <span class="comment">// left == right在[left, right)是无效的空间</span></span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle;  <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;  <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// nums[middle] == target</span></span><br><span class="line">            <span class="keyword">return</span> middle;      <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找也称折半查找，它是一种效率较高的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Search" scheme="http://blog.sukiu.top/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>Thanox 情景模式</title>
    <link href="http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-17T02:04:33.000Z</published>
    <updated>2021-12-22T07:46:12.625Z</updated>
    
    <content type="html"><![CDATA[<p>情景模式简单理解：</p><blockquote><p>什么时候，干什么。</p></blockquote><ul><li><p>什么时候就是触发条件（condition）</p></li><li><p>干什么就是动作（actions）</p></li></ul><p>本文分享自用的情景模式，不定期更新~</p><span id="more"></span><blockquote><p>官方文档：</p><p><a href="https://tornaco.github.io/Thanox/6-Profile/">https://tornaco.github.io/Thanox/6-Profile/</a></p></blockquote><h2 id="1、GPS-相关"><a href="#1、GPS-相关" class="headerlink" title="1、GPS 相关"></a>1、GPS 相关</h2><h3 id="GPS自动开关"><a href="#GPS自动开关" class="headerlink" title="GPS自动开关"></a>GPS自动开关</h3><figure class="highlight yaml"><figcaption><span>GPS自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$gps.contains(to) &amp;&amp; !hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>GPS自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$gps.contains(pkgName) &amp;&amp; hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信小程序开关GPS"><a href="#微信小程序开关GPS" class="headerlink" title="微信小程序开关GPS"></a>微信小程序开关GPS</h3><figure class="highlight yaml"><figcaption><span>小程序自动打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>小程序自动关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; hw.isLocationEnabled() &amp;&amp; from == &quot;com.tencent.mm&quot;&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信网页开关GPS"><a href="#微信网页开关GPS" class="headerlink" title="微信网页开关GPS"></a>微信网页开关GPS</h3><figure class="highlight yaml"><figcaption><span>微信网页打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>微信网页关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; hw.isLocationEnabled() &amp;&amp; !componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2、NFC-相关"><a href="#2、NFC-相关" class="headerlink" title="2、NFC 相关"></a>2、NFC 相关</h2><h3 id="NFC自动开关"><a href="#NFC自动开关" class="headerlink" title="NFC自动开关"></a>NFC自动开关</h3><figure class="highlight yaml"><figcaption><span>NFC自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$nfc.contains(to) &amp;&amp; !hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>NFC自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$nfc.contains(pkgName) &amp;&amp; hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3、冻结相关"><a href="#3、冻结相关" class="headerlink" title="3、冻结相关"></a>3、冻结相关</h2><h3 id="蓝牙开关冻结"><a href="#蓝牙开关冻结" class="headerlink" title="蓝牙开关冻结"></a>蓝牙开关冻结</h3><figure class="highlight yaml"><figcaption><span>BT冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙关闭冻结指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOff&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (pkg.isApplicationEnabled(s)) pkg.disableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT冻结&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>BT解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙打开解冻指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOn&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (!pkg.isApplicationEnabled(s)) pkg.enableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT解冻&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="游戏开关冻结"><a href="#游戏开关冻结" class="headerlink" title="游戏开关冻结"></a>游戏开关冻结</h3><blockquote><p>自行修改以下 com.oneplus.gamespace 包名</p></blockquote><figure class="highlight yaml"><figcaption><span>Game冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;关闭游戏冻结游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;taskRemoved &amp;&amp; globalVarOf$game.contains(pkgName) &amp;&amp; pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.disableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉冻结游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>Game解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开游戏解冻游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; globalVarOf$game.contains(to) &amp;&amp; !pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.enableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉解冻游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4、应用相关"><a href="#4、应用相关" class="headerlink" title="4、应用相关"></a>4、应用相关</h2><h3 id="APP保活"><a href="#APP保活" class="headerlink" title="APP保活"></a>APP保活</h3><blockquote><p>推荐用乖巧模式的规则来 KEEP 想保持的服务</p><p>以下貌似没用，可以开启电池不优化试试</p></blockquote><figure class="highlight yaml"><figcaption><span>APP保活 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP保活&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;应用停止运行时重启应用进程，全局变量 apps&quot;</span></span><br><span class="line"><span class="comment">#  APP 后台不优化</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$apps.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.launchProcessForPackage(pkgName)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉保活app&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="APP休眠"><a href="#APP休眠" class="headerlink" title="APP休眠"></a>APP休眠</h3><figure class="highlight yaml"><figcaption><span>APP休眠 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP休眠&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;后台应用休眠，全局变量 idle&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$idle.contains(from)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.setInactive(from)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、Data-相关"><a href="#5、Data-相关" class="headerlink" title="5、Data 相关"></a>5、Data 相关</h2><h3 id="Data自动开启"><a href="#Data自动开启" class="headerlink" title="Data自动开启"></a>Data自动开启</h3><figure class="highlight yaml"><figcaption><span>Data自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Data自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开移动数据，全局变量 data&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$data.contains(to) &amp;&amp; !hw.isWifiEnabled() &amp;&amp; !data.isDataEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;data.setDataEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开移动数据&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6、亮度相关"><a href="#6、亮度相关" class="headerlink" title="6、亮度相关"></a>6、亮度相关</h2><h3 id="自动亮度关闭"><a href="#自动亮度关闭" class="headerlink" title="自动亮度关闭"></a>自动亮度关闭</h3><figure class="highlight yaml"><figcaption><span>自动亮度关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用关闭自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bright.contains(to) &amp;&amp; power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(false)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭自动亮度&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="自动亮度开启"><a href="#自动亮度开启" class="headerlink" title="自动亮度开启"></a>自动亮度开启</h3><figure class="highlight yaml"><figcaption><span>自动亮度开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用打开自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bright.contains(pkgName) &amp;&amp; !power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setBrightness(power.getBrightness())&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉开启自动亮度&quot;)&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、状态栏图标相关"><a href="#7、状态栏图标相关" class="headerlink" title="7、状态栏图标相关"></a>7、状态栏图标相关</h2><blockquote><p>隐藏状态栏图标的 shell 命令：</p><p>settings put secure icon_blacklist 「args」</p><p>自行修改 「args」 参数</p></blockquote><h3 id="状态栏图标隐藏"><a href="#状态栏图标隐藏" class="headerlink" title="状态栏图标隐藏"></a>状态栏图标隐藏</h3><figure class="highlight yaml"><figcaption><span>状态栏图标隐藏 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标隐藏&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用隐藏状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bar.contains(to)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,clock,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉隐藏状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="状态栏图标显示"><a href="#状态栏图标显示" class="headerlink" title="状态栏图标显示"></a>状态栏图标显示</h3><figure class="highlight yaml"><figcaption><span>状态栏图标显示 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标显示&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用显示状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bar.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉显示状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;情景模式简单理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候，干什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么时候就是触发条件（condition）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;干什么就是动作（actions）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文分享自用的情景模式，不定期更新~&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="Thanox" scheme="http://blog.sukiu.top/tags/Thanox/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://blog.sukiu.top/Language/Go-Module/"/>
    <id>http://blog.sukiu.top/Language/Go-Module/</id>
    <published>2021-11-17T00:54:42.000Z</published>
    <updated>2021-12-22T07:46:06.166Z</updated>
    
    <content type="html"><![CDATA[<p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。</p><p>一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://time.geekbang.org/column/article/429941">06｜构建模式：Go是怎么解决包依赖管理问题的？ (geekbang.org)</a></p></blockquote><h2 id="1、Go-Module-构建模式"><a href="#1、Go-Module-构建模式" class="headerlink" title="1、Go Module 构建模式"></a>1、Go Module 构建模式</h2><h3 id="语义导入版本机制"><a href="#语义导入版本机制" class="headerlink" title="语义导入版本机制"></a>语义导入版本机制</h3><p>在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/468323b3294cce2ea7f4c1da3699c5a2.png" alt="语义版本号规范" style="zoom: 50%;" /><p>按照语义版本规范，</p><ul><li><strong>主版本号不同</strong>的两个版本是相互<strong>不兼容</strong>的；</li><li>在主版本号相同的情况下，次版本号大都是<strong>向后兼容</strong>次版本号小的版本；</li><li>补丁版本号也不影响兼容性。</li></ul><p>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本</span></span><br><span class="line"><span class="comment">// 假如这是 v1.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus&quot;</span> </span><br><span class="line"><span class="comment">// 如果要导入 v2.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line"><span class="comment">// 甚至可以同时依赖一个包的两个不兼容版本</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">    logv2 <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径</p></blockquote><h3 id="最小版本选择原则"><a href="#最小版本选择原则" class="headerlink" title="最小版本选择原则"></a>最小版本选择原则</h3><p>依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/49eb7aa0458d8ec6131d9e5661155f1b.jpeg" alt="复杂情况" style="zoom: 33%;" /><p>当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 <code>v1.7.0</code>。</p><p>不过，Go 会在该项目依赖项的所有版本中，选出<strong>符合项目整体要求</strong>的“最小版本”</p><p>这个例子中，<code>C v1.3.0</code> 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 <code>C v1.3.0</code>，而不是最新最大的 <code>C v1.7.0</code>。</p><h2 id="2、Go-module-版本管理"><a href="#2、Go-module-版本管理" class="headerlink" title="2、Go module 版本管理"></a>2、Go module 版本管理</h2><h3 id="（1）Go-Module-创建"><a href="#（1）Go-Module-创建" class="headerlink" title="（1）Go Module 创建"></a>（1）Go Module 创建</h3><p>创建一个 Go Module，通常有如下几个步骤：</p><ol><li><p>通过 <code>go mod init</code> 创建 go.mod 文件，将当前项目变为一个 Go Module；</p></li><li><p>通过 <code>go mod tidy</code> 命令自动更新当前 module 的依赖信息；</p></li><li><p>执行 <code>go build</code>，执行新 module 的构建。</p></li></ol><h3 id="（2）为当前-module-添加一个依赖"><a href="#（2）为当前-module-添加一个依赖" class="headerlink" title="（2）为当前 module 添加一个依赖"></a>（2）为当前 module 添加一个依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/google/uuid</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go mod tidy</span></span><br></pre></td></tr></table></figure><h3 id="（3）升级-降级依赖的版本"><a href="#（3）升级-降级依赖的版本" class="headerlink" title="（3）升级 / 降级依赖的版本"></a>（3）升级 / 降级依赖的版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选定指定版本即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">go get github.com/sirupsen/logrus@v1.7.0</span></span><br></pre></td></tr></table></figure><h3 id="（4）移除一个依赖"><a href="#（4）移除一个依赖" class="headerlink" title="（4）移除一个依赖"></a>（4）移除一个依赖</h3><p>仅从源码中删除对依赖项的导入语句还不够，还得用 <code>go mod tidy</code> 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。</p><p><code>go mod tidy</code> 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。</p><h3 id="（5）vendor"><a href="#（5）vendor" class="headerlink" title="（5）vendor"></a>（5）vendor</h3><p>vendor 机制可以对 vendor 目录下缓存的依赖包进行自动管理。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非 go build 传入 <code>-mod=mod</code> 的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">go mod vendor</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tree -LF 2 vendor</span></span><br><span class="line">vendor</span><br><span class="line">├── github.com/</span><br><span class="line">│   ├── google/</span><br><span class="line">│   ├── magefile/</span><br><span class="line">│   └── sirupsen/</span><br><span class="line">├── golang.org/</span><br><span class="line">│   └── x/</span><br><span class="line">└── modules.txt</span><br></pre></td></tr></table></figure><h3 id="3、空导入"><a href="#3、空导入" class="headerlink" title="3、空导入"></a>3、空导入</h3><p>像下面代码这样的包导入方式被称为“空导入”：<code>import _ &quot;foo&quot;</code></p><p>空导入也是导入，意味着我们将依赖foo这个路径下的包。</p><p>由于是空导入，我们并没有显式使用这个包中的任何语法元素。</p><p>通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。&lt;/p&gt;
&lt;p&gt;在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。&lt;/p&gt;
&lt;p&gt;一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。&lt;/p&gt;
&lt;p&gt;go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>主流开源协议</title>
    <link href="http://blog.sukiu.top/Mixed/Open-Source-License/"/>
    <id>http://blog.sukiu.top/Mixed/Open-Source-License/</id>
    <published>2021-11-12T10:49:27.000Z</published>
    <updated>2021-12-22T07:45:59.392Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：</p><ul><li>宽松自由软件许可协议 <em>Permissive free software licence</em></li><li>著佐权许可证 <em>copyleft license</em></li></ul><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/19568896">主流开源协议之间有何异同？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p></blockquote><h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><ul><li><p>Permissive free software licence ：</p><p>  一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。</p></li><li><p>Copyleft License ：</p><p>  在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。</p></li></ul><p>两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。</p><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><h2 id="2、常见开源许可证"><a href="#2、常见开源许可证" class="headerlink" title="2、常见开源许可证"></a>2、常见开源许可证</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free_software_licenses.png" alt="常见许可证" style="zoom:50%;" /><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p><em>Berkeley Software Distribution license</em></p><p>BSD 许可证与 MIT 差不多。</p><p>事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。</p><p>可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。</p><p>Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。</p><p>Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。</p><p>由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/7149baf878e23293b9bd57df076b6e41_r.jpg" alt="简明对比"></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>更宽松的GPL协议。</p><p>与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。</p><p>调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宽松自由软件许可协议 &lt;em&gt;Permissive free software licence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;著佐权许可证 &lt;em&gt;copyleft license&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="License" scheme="http://blog.sukiu.top/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree 二叉搜索树</title>
    <link href="http://blog.sukiu.top/Data-structure/Binary-Search-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/Binary-Search-Tree/</id>
    <published>2021-11-12T02:42:46.000Z</published>
    <updated>2021-12-22T07:45:51.309Z</updated>
    
    <content type="html"><![CDATA[<p>简称 BST，也称二叉排序树或二叉查找树。</p><p>特点：</p><ul><li>任一结点 &gt; 其左子树的所有结点，<br>  并且&lt; 其右子树的所有结点；</li><li>结点的左、右子树，也是二叉排序树；</li><li>每个结点键值唯一（不能重复）</li></ul><p>重要性质：</p><ul><li><strong>中序遍历二叉排序树得到递增序列</strong></li></ul><p>所以判断 1 棵二叉树是否是二叉排序树？<br>只要中序遍历，得到递增序列才是。</p><span id="more"></span><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li>若当前树为空，则新结点为根</li><li>若当前树不空，<br>  将待插入 x 与根比较；<ul><li>若 x 等于根，不用插入</li><li>若 x 大于根，则去右子树(找位置)；</li><li>若 x 小于根，则去左子树(找位置)；</li></ul></li></ul><p>可以总结为：</p><p>插入之前，先查找：</p><ul><li>若找到，不用插入</li><li>若找不到，则在到达的空位置处，放入 x；</li></ul><p>所以最新插入的结点，一定是叶子；</p><img src="https://img-blog.csdnimg.cn/20200512170217478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" width="50%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>从根结点开始，如果树为空，则返回 NULL</p></li><li><p>如果非空，从根结点开始，比较待检索的键值</p><ul><li><p>若相等，则成功；</p></li><li><p>若小于根，<br>  则去根的左子树；</p></li><li><p>若大于根，<br>  则去根的右子树，</p></li></ul></li></ul><figure class="highlight go"><figcaption><span>迭代</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>考虑三种情况：</p><ul><li>① 要删除叶子结点<br>  直接删除，并将父结点指针置为 NULL</li></ul><img src="https://img-blog.csdnimg.cn/20200512170832794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="40%"><ul><li>② 删除只有 1 个孩子的结点<br>  将父结点指针指向要删除结点的孩子结点</li></ul><img src="https://img-blog.csdnimg.cn/20200512170956215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><ul><li>③ 删除有左右子树的结点<br>  用另一个结点替代删除的结点：<ul><li>右子树的最小元素 或者 左子树的最大元素</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200512171205732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">        root.Left = deleteNode(root.Left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">        root.Right = deleteNode(root.Right, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 1 : 以下两个 if 已经处理</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 左</span></span><br><span class="line">        <span class="keyword">return</span> root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 右</span></span><br><span class="line">        <span class="keyword">return</span> root.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 3 ： 使用右子树最小元素</span></span><br><span class="line">    minNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> minNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        minNode = minNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    root.Val = minNode.Val</span><br><span class="line">    root.Right = deleteNode(root.Right, minNode.Val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平均检索长度-ASL"><a href="#平均检索长度-ASL" class="headerlink" title="平均检索长度 ASL"></a>平均检索长度 ASL</h2><p>比较次数：不大于树的深度</p><p>最坏平均查找长度 ASL：(n+1)/2</p><p>最好 ASL：$log2(n)$ (参考二分查找)</p><p><strong>所有操作的复杂度都是 $O(logn)$</strong></p><img src="https://img-blog.csdnimg.cn/2020051217150614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" >]]></content>
    
    
    <summary type="html">&lt;p&gt;简称 BST，也称二叉排序树或二叉查找树。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任一结点 &amp;gt; 其左子树的所有结点，&lt;br&gt;  并且&amp;lt; 其右子树的所有结点；&lt;/li&gt;
&lt;li&gt;结点的左、右子树，也是二叉排序树；&lt;/li&gt;
&lt;li&gt;每个结点键值唯一（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中序遍历二叉排序树得到递增序列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以判断 1 棵二叉树是否是二叉排序树？&lt;br&gt;只要中序遍历，得到递增序列才是。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
</feed>
