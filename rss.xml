<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千反田</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2022-01-23T12:59:14.342Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件管理</title>
    <link href="http://blog.sukiu.top/Operating-System/File-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/File-Management/</id>
    <published>2022-01-21T06:40:38.000Z</published>
    <updated>2022-01-23T12:59:14.342Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统是操作系统中负责管理持久数据的子系统，即负责把用户的文件存到磁盘硬件中。</p><p>因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件是对长期存储介质的抽象。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://juejin.cn/post/6916446785775468557">理解文件系统 - 掘金</a></p></blockquote><h2 id="1、文件"><a href="#1、文件" class="headerlink" title="1、文件"></a>1、文件</h2><p>文件是⼀种抽象机制，它提供了⼀种在磁上保存信息而且方便以后读取的方法。<br>这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘⼯作方式等有关细节。</p><blockquote><p>win95、win98用的都是MS-DOS的文件系统，即FAT-16， win98扩展了FAT-16成为FAT-32。<br>较新版的操作系统NTFS，win8配备ReFS。微软优化FAT,叫作exFAT。<br>prog.c，圆点后面的部分称为文件扩展名。</p></blockquote><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>字节结构：把文件看成字节序列为操作系统提供了最大的灵活度</li><li>记录序列：文件结构上的第⼀步改进，这种模型中，文件是具有固定长度记录的序列</li><li>树：文件在这种结构中由⼀棵记录树构成，每个记录不必具有相同的长度，记录的固定位置上有⼀个键字段。这棵树按“键”字段进行排序，从而可以对特定“键”进行快速查找。</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol><li>普通文件</li><li>目录</li><li>字符特殊文件（UNIX）</li><li>块特殊文件（UNIX）</li></ol><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>除了文件名和数据外，文件还具有<strong>属性</strong>来对文件本身做更具体的描述，这类信息也称为<strong>元数据</strong>。<br>这些属性会存于文件结构中的某些区域中，具体要视该文件的类型而定。</p><p><strong>举例</strong>：</p><ul><li>创建时间、修改时间、存取时间、文件大小、当前大小、所有者等</li><li>保护：对文件的访问限制，谁可以访问文件</li><li>口令：访问文件需要的密码</li><li>只读标志、隐藏标志、系统标志（普通文件或系统文件）、加锁标志、存档标志</li><li>最大长度：文件可能增长到的字节数</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是<strong>存储信息并方便以后检索</strong>。对于存储和检索，不同系统提供了不同的操作。</p><p>文件系统大多都会提供如下的<strong>文件操作</strong>：</p><ul><li>create()：创建不包含任何数据的文件。</li><li>delte()：删除该文件以释放磁盘空间。</li><li>open()：在使用文件之前，先打开文件，目的是把文件属性和磁盘地址表装入内存，以便后续调用的快速访问。</li><li>close()：文件访问结束之后，关闭文件并释放内部空间表空间。</li><li>write()：向文件写数据，如果当前位置是文件尾，那么数据长度会增加；如果当前位置是其中某个位置，那么写入位置的数据将会被覆盖。</li><li>append()：相当于write()在尾部添加数据。</li><li>seek()：随机访问文件，需要指定相对于文件数据开始的位置。</li><li>getAttribute()：读取文件的属性。</li><li>setAttribute()：设置文件的属性。</li><li>rename()：重命名文件。</li></ul><p>一般来说，打开文件将会获得一个<strong>文件描述符</strong>(一个小整数)，通过文件描述符，就可以操作文件。</p><h2 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h2><p>文件系统通常提供目录或文件夹用于记录文件的位置，在很多操作系统中目录本身也是文件</p><p>现在的文件目录结构，大多采用文件树结构。<br>这里的路径，用<strong>路径名</strong>表示，分为<strong>绝对路径名</strong>和<strong>相对路径名</strong>，路径每往下一层，使用分隔符进行分隔。</p><p>分隔符视系统而定，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Windows：\usr\ast\maibox</span><br><span class="line">&gt; Linux: /usr/ast/mailbox</span><br><span class="line">&gt; MULTICS: &gt;usr&gt;ast&gt;mailbox</span><br></pre></td></tr></table></figure><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>对于目录，也提供了相应的操作：</p><ul><li>create(): 创建目录</li><li>delete(): 删除目录</li><li>opendir(): 打开目录</li><li>closedir(): 关闭目录，释放内部表空间</li><li>readdir(): 返回一个目录项，在内存中，以目录项来表达一个目录</li><li>rename(): 重命名</li><li>link(): 链接一个文件，之后能使同一个文件，能通过多个文件路径访问到(后续会提到)</li><li>unlink(): 解除文件的链接</li></ul><h2 id="3、文件系统"><a href="#3、文件系统" class="headerlink" title="3、文件系统"></a>3、文件系统</h2><p>以上内容是以用户（即使用者）的角度看待文件。<br>那么，从文件系统实现者的角度来看，文件系统应该如何实现？</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201232026680.png" style="zoom:67%;" /><p>文件系统存放在磁盘上，磁盘被划分为一个或者多个分区，每个分区中有一个独立的文件系统。<br>磁盘的0号扇区称为<strong>主引导记录（Master Boot Record, MBR）</strong>，用来引导计算机。<br>紧接着，是分区表，用来标记每个分区的起始和结束位置，表中的一个分区被标记为活动分区。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201232028987.png" style="zoom:50%;" /><blockquote><p>当计算机被引导时，BIOS读入并执行MBR。<br>MBR会确定活动分区，读入并执行它的<strong>引导块（boot block）</strong>。引导块中的程序将装载该分区中的系统。<br><strong>超级块</strong>（superblock）包含文件系统的所有关键参数，会被读入内存，其中的信用可用来确定文件系统的魔数、文件系统中的块的数量和其他重要的管理信息。</p><p>空闲块的信息可以用位图或者指针的形式指出，随后跟随的是一组i节点（一种数据结构，用来说明文件的方方面面）。最后，存放了所有其他的文件和目录。</p></blockquote><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配是把每个文件作为⼀连串连续数据块存储在磁盘</p><p><strong>优点：</strong></p><ul><li>实现简单，只需记住开始位置，文件的块数。</li><li>读操作性能好，单个操作就能从磁盘中读出整个文件。只需要一次寻找，之后不再有寻道和旋转延迟。</li></ul><p><strong>缺点：</strong></p><ul><li>尾部会浪费一些空间，以块为存储单位时，无论是否完全使用完块大小，都会占用整个块</li><li>需要知道文件的最终大小，然后，在维护的连续空闲表找到合适的位置存入文件，并且知道文件的最终大小这一问题不可回避。</li><li>随时间迁移，将会产生大量碎片块，使磁盘变得零碎，当一个较大的新文件要加入时，将找不到合适的连续位置，此时要压缩磁盘空间（把文件复制到新位置，以得到更多的连续空间），代价极高。</li></ul><blockquote><p>新建文件时要知道文件的最终大小，使得这一存储方式难以应用于实际场景，但是在一些情形下是可行的。</p><p>如在CD-ROM、DVD、BD（蓝光光盘）上，在它们的场景里，所有的文件的大小是事先知道的，并且在后续的使用中，这些文件的大小也不会改变。</p></blockquote><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>可以为每个文件构造磁盘块链表，每一块的第一个字指向下块，块的其他部分存放数据。</p><p><strong>优点：</strong></p><ul><li>不会因为磁盘碎片浪费存储空间，充分利用磁盘块。</li><li>只需要第一块的磁盘地址，就能找到其他的块。</li></ul><p><strong>缺点：</strong></p><ul><li>随机方法访问很慢，访问块n总是要先访问其面的n-1块。</li><li>指向下一块的指针占据了一些字节，每个磁盘块存储的字节数不再是2的整次幂，因大多数程序以长度为2的整次幂来读写磁盘块，降低了实际系统的运行效率。</li><li>要读出一个完成的文件块时，要从两个磁盘块中获得和拼接信息，带来额外的开销</li></ul><h4 id="内存中的表进行链表分配"><a href="#内存中的表进行链表分配" class="headerlink" title="内存中的表进行链表分配"></a>内存中的表进行链表分配</h4><p>弥补链表分配的不足，可以在内存中建立磁盘块的指针表。</p><p>表项中，使用一个特殊的标记（如-1）表示结束。这样，沿着表就可以文件的所有块。</p><p>这样的表也称为 <strong>FAT（File Allocation Table）</strong> 。</p><p><strong>优点：</strong></p><ul><li>整个块都可以存放数据。</li><li>随机访问也简单得多，虽然仍要顺着链表寻找偏移量（但减少了可能的寻到和旋转延迟）</li><li>不需要磁盘引用</li></ul><p><strong>缺点：</strong></p><ul><li>必须把整个表都放在内存中。假设1TB的磁盘和1KB的块大小，则表需要10亿项，每一项至少要3个字节，则表大小要占用2.4GB内存。因此FAT的应用场景有限，不太实用。</li></ul><h4 id="i-节点"><a href="#i-节点" class="headerlink" title="i 节点"></a>i 节点</h4><p>最普遍的方式，是为每个文件创建一个中数据结构以表示此文件的关键描述，这种数据结构也称为<strong>i节点（index-node）</strong>。</p><p>一个可能的inode结构，记录了文件属性，以及每个文件块对应的磁盘块地址，并能指向其他的inode来记录更多的存储数据。</p><p>这样的机制有很大的优势：</p><ul><li>给定inode，就能找到所有的文件块。</li><li>只有在文件打开时，inode才会存在于内存中，如果每个i节点有n字节，那么k个文件同时打开，inode总共占据kn字节，只需提前保留这么多的空间即可。也就是说，内存中inode占据的大小和文件大小无关，只和同时使用的文件数有关。</li><li>如果一个inode不够存储一个文件占用的所有磁盘块，可以通过最后一个地址之前其他inode得以解决。甚至可以指向其他存放地址的磁盘的磁盘块。</li></ul><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>在读文件之前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应的目录项。</p><ul><li>简单目录：包含固定大⼩的目录，在目录项中有磁盘地址和属性</li><li>采用i节点的系统：把文件属性存放在i节点中而不是目录项中。这种情形下，目录项会更短。</li></ul><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>共享文件与目录的联系称为⼀个链接（link）。<br>这样文件系统本身就是⼀个有向⽆环图（DAG），而不是⼀棵树。</p><ul><li>硬链接：指向目标数据对象的链接，<strong>可以看作是一个既有文件的别名</strong></li></ul><blockquote><p>当目标被删除时，硬链接继续存在，且可以正常打开、编辑。因为他具备一个完整的文件结构。</p><p>当硬链接被删除时，目标文件继续存在，不受影响。</p><p>只有当一个文件 ID 对应的所有硬链接被删除时，数据才真正被标记为删除。</p></blockquote><ul><li>符号链接：指向目标路径的链接，会跳转到符号链接所指向的目标中去，而不改变此时的文件路径</li></ul><blockquote><p>当目标被删除时，符号链接继续存在，但会成为死链，无法打开。</p><p>当符号链接被删除时，它指向的目标不受影响。</p></blockquote><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>将多个文件系统整合到⼀个统⼀的结构中。</p><blockquote><p>⼀个Linux系统可以用<code>ext2</code>作为根文件系统，<code>ext3</code>分区装载在<code>/usr</code>下，另⼀块采用ReiserFS文件系统的硬盘装载在<code>/home</code>下，以及⼀个ISO 9660的CD-ROM临时装载在<code>/mnt</code>下。</p></blockquote><p>从用户的观点来看，只有⼀个文件系统层级。但它们事实上是多种文件系统，对于用户和进程是不可见的。</p><p>绝大多数Unix操作系统都在使用虚拟文件系统（VirtualFile System, VFS）</p><h3 id="文件系统面对的问题"><a href="#文件系统面对的问题" class="headerlink" title="文件系统面对的问题"></a>文件系统面对的问题</h3><h4 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h4><p>几乎所有的文件系统将文件分割成固定大小的块来存储，各块之间不一定相邻。</p><h5 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h5><p>块大小将直接影响此消彼长的两个指标<strong>空间利用率</strong>和<strong>磁盘数据率</strong>。</p><blockquote><p>从历史的观点上来说，文件系统将大⼩设在1~4KB之间。</p><p>但现在随着磁盘超过了1TB，还是将块的大⼩提升到64KB 并且接受浪费的磁盘孔空间，这样也许更好。磁盘空间⼏乎不再会短缺。</p></blockquote><h5 id="空闲块记录"><a href="#空闲块记录" class="headerlink" title="空闲块记录"></a>空闲块记录</h5><p>确定了块大小，需要考虑空闲块如何记录。</p><ul><li>链表记录：链表的每个块中包含尽可能多的空闲磁盘块号。（通常情况下，采用空闲块存放空闲表，这样不会影响存储器）</li><li>位图记录：在位图中，空闲块用1表示，已分配块用0表示。</li></ul><h5 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h5><p>做磁盘备份主要是处理好两个潜在问题中的⼀个：</p><ol><li>从意外的灾难中恢复</li><li>从错误的操作中恢复</li></ol><p>将文件从磁盘转储到磁带，有两种方法，<strong>物理转储</strong>和<strong>逻辑转储</strong>。</p><h4 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h4><p>文件进行修改后，需将所有的修改都写回磁盘，如果在所有的磁盘块都写回磁盘前，系统崩溃，一些被修改的信息可能未被写回磁盘，那么文件系统将不一致。</p><p>因此，文件系统一般都有独立的程序可检查其一致性。</p><p>致性检查分为两种<strong>块的一致性检查</strong>和<strong>文件的一致性检查</strong></p><h4 id="文件系统的性能"><a href="#文件系统的性能" class="headerlink" title="文件系统的性能"></a>文件系统的性能</h4><p>磁盘访问的速度比内存访问的速度慢得多，如果每次读文件时，都从磁盘块中读取，那么IO时间将是大大拖累程序效率。</p><p>主要通过以下方法提高性能：</p><ul><li>高速缓存：减少磁盘访问次数技术是块高速缓存（block cache）或者缓冲区高速缓存（buffer cache）</li><li>块预读：在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。</li><li>减少磁盘臂运动：把可能顺序访问的块放⼀起，当然最好是同⼀柱面上，从而减少磁盘臂的移动次数。</li><li>磁盘碎片整理：移动文件使它们相邻，并把所有的空闲空间放在⼀个或多个大的连续区域内。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件系统是操作系统中负责管理持久数据的子系统，即负责把用户的文件存到磁盘硬件中。&lt;/p&gt;
&lt;p&gt;因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p&gt;
&lt;p&gt;文件是对长期存储介质的抽象。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="File" scheme="http://blog.sukiu.top/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>设备管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Device-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/Device-Management/</id>
    <published>2022-01-21T06:27:49.000Z</published>
    <updated>2022-01-22T05:12:23.211Z</updated>
    
    <content type="html"><![CDATA[<p>磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。</p><p>早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。</p><p>电脑外设就是除主机外的大部分硬件设备都可称作外部设备，或叫外围设备，简称外设。<br>计算机系统没有输入输出设备，就如计算机系统没有软件一样，是毫无意义的。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/or7mr5/">设备管理 - 力扣</a></p></blockquote><h2 id="1、磁盘"><a href="#1、磁盘" class="headerlink" title="1、磁盘"></a>1、磁盘</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211431280.png"  /><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。</p><p>缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。</p><p>如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。</p><p>具体来说，两端的磁道请求更容易出现饥饿现象。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="image" style="zoom:80%;" /><h4 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h4><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="image" style="zoom:80%;" /><h2 id="2、外设"><a href="#2、外设" class="headerlink" title="2、外设"></a>2、外设</h2><h3 id="如何让外设动起来"><a href="#如何让外设动起来" class="headerlink" title="如何让外设动起来"></a>如何让外设动起来</h3><ol><li>CPU 向外设的控制器发送指令，即 out 指令</li><li>形成 ⽂件视图（为了统⼀ out 指令的形式）</li><li>中断（外设处理完事后，需要通知 cpu 继续接手下⼀步处理）</li></ol><h3 id="显示器如何工作"><a href="#显示器如何工作" class="headerlink" title="显示器如何工作"></a>显示器如何工作</h3><blockquote><p>Printf 函数的工作流程</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211437690.png" alt="image-20220121143755635" style="zoom: 67%;" /><h3 id="键盘如何工作"><a href="#键盘如何工作" class="headerlink" title="键盘如何工作"></a>键盘如何工作</h3><ol><li>中断处理（根据扫描码获取 对应的 ascii 码）</li><li>将对应的 ascii 码加入缓冲队列 read_que 中，等待上层程序调用</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。&lt;/p&gt;
&lt;p&gt;早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。&lt;/p&gt;
&lt;p&gt;电脑外设就是除主机外的大部分硬件设备都可称作外部设备，或叫外围设备，简称外设。&lt;br&gt;计算机系统没有输入输出设备，就如计算机系统没有软件一样，是毫无意义的。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Device" scheme="http://blog.sukiu.top/tags/Device/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Memory-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/Memory-Management/</id>
    <published>2022-01-21T05:20:42.000Z</published>
    <updated>2022-01-21T06:23:25.574Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。<br>其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p><p>虚拟内存是内存管理技术的一个极其实用的创新。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/ool031/">内存管理 - leetcode</a></p></blockquote><h2 id="1、页面置换算法"><a href="#1、页面置换算法" class="headerlink" title="1、页面置换算法"></a>1、页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。<br>此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。<br>在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="最佳置换-OPT"><a href="#最佳置换-OPT" class="headerlink" title="最佳置换 OPT"></a>最佳置换 OPT</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><blockquote><p>三个物理块：</p><p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</p><p>开始运行时，先将 7, 0, 1 三个页面装入内存。</p><p>当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p></blockquote><h3 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出 FIFO"></a>先进先出 FIFO</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3 id="最近最久未使用-LRU"><a href="#最近最久未使用-LRU" class="headerlink" title="最近最久未使用 LRU"></a>最近最久未使用 LRU</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><blockquote><p>4，7，0，7，1，0，1，2，1，2，6 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211358376.png"  /></p></blockquote><h3 id="最近未使用-NRU"><a href="#最近未使用-NRU" class="headerlink" title="最近未使用 NRU"></a>最近未使用 NRU</h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。</p><p>可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3 id="第二次机会"><a href="#第二次机会" class="headerlink" title="第二次机会"></a>第二次机会</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><ul><li>当页面被访问 (读或写) 时设置该页面的 R 位为 1。</li><li>需要替换的时候，检查最老页面的 R 位：<ul><li>如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉</li><li>如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211402284.png"  /><h3 id="时钟-Clock"><a href="#时钟-Clock" class="headerlink" title="时钟 Clock"></a>时钟 Clock</h3><p>第二次机会算法需要在链表中移动页面，降低了效率。</p><p>时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211400217.png"  /><h2 id="2、分段"><a href="#2、分段" class="headerlink" title="2、分段"></a>2、分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>如果使用分页系统的⼀维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，⼀个段构成⼀个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png" /><h3 id="纯分段"><a href="#纯分段" class="headerlink" title="纯分段"></a>纯分段</h3><p>分段和分页本质上是不同的，页面是定长的而段不是。</p><p>优点：</p><ul><li>共享：有助于几个进程之间共享过程和数据。 比如共享库</li><li>保护：每个段都可以独立地增大或减小而不会影响其他的段</li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。</p><p>这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分段与分页的比较"><a href="#分段与分页的比较" class="headerlink" title="分段与分页的比较"></a>分段与分页的比较</h3><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：</p><ul><li>分页主要用于实现虚拟内存，从而获得更大的地址空间；</li><li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul></li></ul><h2 id="3、虚拟内存"><a href="#3、虚拟内存" class="headerlink" title="3、虚拟内存"></a>3、虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>属于计算机系统内存管理的⼀种技术，虚拟地址空间构成虚拟内存，它使得应用程序认为自己拥有连续的可用内存空间，但实际上是被分隔的多个物理内存页、以及部分暂时存储在磁盘上的交换分区所构成的。</p><p>虚拟内存的实现通过硬件异常、硬件地址翻译、主存、磁盘以及内核软件共同完成。</p><blockquote><p>地址空间：是物理内存的抽象，是⼀个进程可用于寻址内存的⼀套地址集合</p><p>分页：地址空间被分割成多个块，每⼀块称作⼀页或页面(Page)。每⼀页有连续的地址范围，这些页被映射到连续的物理内存(页框)。</p><p>页表：把虚拟页面(虚拟地址)映射为页框(物理地址)。页表给出了虚拟地址与物理地址的映射关系。从数学的角度说页表是⼀个函数，他的参数是虚拟页号，结果是物理页页框号</p></blockquote><blockquote><p>虚拟内存的思想，整体来看就是：</p><p>通过结合磁盘和内存各自的优势，利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统⼀的抽象。</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h4><p>将虚拟地址直接映射到物理地址，而不必再访问页表，这种设备被称为转换检测缓冲区（TLB）、相联存储器或快表</p><p>⼯作过程：将⼀个虚拟地址放⼊MMU（内存管理单元）中进行转换时，硬件首先通过将该虚拟页号与 TLB 中所有表项同时进行匹配，</p><p>判断虚拟页面是否在其中：</p><ol><li>虚拟页号在TLB中。如果MMU检测⼀个有效的匹配并且访问操作并不违反保护位，则将页框号直接从 TLB 中取出而不必访问页表。</li><li>虚拟页号不在TLB中。如果MMU检测到没有有效的匹配项就会进行正常的页表查询。接着从 TLB 中淘汰⼀个表项，然后用新的页表项替换它。</li></ol><h4 id="加大"><a href="#加大" class="headerlink" title="加大"></a>加大</h4><ul><li><p>多级页表</p></li><li><p>倒排页表</p></li></ul><h3 id="重要能力"><a href="#重要能力" class="headerlink" title="重要能力"></a>重要能力</h3><ul><li>高速缓存</li><li>内存管理</li><li>内存保护：如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存管理是指软件运行时对计算机内存资源的分配和使用的技术。&lt;br&gt;其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。&lt;/p&gt;
&lt;p&gt;虚拟内存是内存管理技术的一个极其实用的创新。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Memory" scheme="http://blog.sukiu.top/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://blog.sukiu.top/Algorithm/All-Sort/"/>
    <id>http://blog.sukiu.top/Algorithm/All-Sort/</id>
    <published>2022-01-19T13:36:14.000Z</published>
    <updated>2022-01-21T05:35:26.665Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><span id="more"></span><blockquote><p>稳定性是指排序过程中，原来相同的元素保持原来的相对位置<br>比如 a[i] = a[j] ，且 i&lt;j , 排序后 i&lt;j 依然成立</p></blockquote><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="(1) 直接插入排序"></a>(1) 直接插入排序</h3><blockquote><p>时间复杂度：O(n^2)，最好 O(n)<br>空间复杂度：O(1)<br>稳定性：稳定</p></blockquote><ul><li>思路：<br>  将开头元素视作已排序<br>  执行下述过程，直到未排序过程消失：</li></ul><ol><li>取出未排序部分的开头元素赋给变量 v</li><li>在已排序部分，将所有比 v 大的元素向后移动一位</li><li>将已取出的元素 v 插入空位</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192140735.png" style="zoom: 67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; v&lt;a[j];j--)</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j]; <span class="comment">// 后移</span></span><br><span class="line">        a[j+<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="(2) 希尔排序"></a>(2) 希尔排序</h3><blockquote><p>时间复杂度：平均 O(n^1.3)，最坏 O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p><strong>缩小增量法</strong></p><ul><li><p>n 个记录，增量为 di，则分组</p><ul><li><p>下标 0, di, 2di, 3di, …… 为 1 组</p></li><li><p>下标 1, di +1, 2di +1, 3di +1, …… 为 1 组</p></li><li><p>下标 2, di +2, 2di +2, 3di +2, …… 为 1 组</p></li><li><p>…… …… …… ……</p></li><li><p>下标 di-1, di+di -1, 2di+di -1, …… 为 1 组</p></li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192141773.png" style="zoom: 80%;"  ><p>思路：</p><ul><li><p>增量为 d1 时，在各组内，进行排序</p></li><li><p>减小增量，重新分组，组内排序</p><ul><li>减小增量：初始：d1 = n/2，则模式：di+1 = di /2</li></ul></li><li><p>重复第 2 步， 直到 di==1，所有记录在同一组，组内排序</p><ul><li>排序均为直接插入排序</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192141543.png" style="zoom:67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 按照 ShellSort 定义写出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, gap;</span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gap; i++)                   <span class="comment">// 分组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + gap; j &lt; n; j += gap)  <span class="comment">// 组内插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - gap]) &#123;            <span class="comment">// 直接插入排序</span></span><br><span class="line">                    <span class="keyword">int</span> v = a[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j - gap; k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; v; k -= gap)</span><br><span class="line">                        a[k + gap] = a[k];  <span class="comment">// 后移</span></span><br><span class="line">                    a[k + gap] = v;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 优化</span></span><br><span class="line"><span class="comment">// - 上述 i 的作用是为了确认 j 的位置，并与组内元素比较</span></span><br><span class="line"><span class="comment">// - 明显每次 gap 与 j-gap 就是组内比较，不需要再分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, gap;</span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = gap; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - gap]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = a[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j - gap; k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; v; k -= gap)</span><br><span class="line">                    a[k + gap] = a[k];  <span class="comment">// 后移</span></span><br><span class="line">                a[k + gap] = v;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="(3) 冒泡排序"></a>(3) 冒泡排序</h3><blockquote><p>时间复杂度：平均 O(n^2)，最坏 O(n^2)，最好 O(n)<br>空间复杂度：O(1)<br>稳定性：稳定</p></blockquote><ul><li>思路：<br>  重复执行下述处理，直到数组中不包含顺序相反的相邻元素：<br>  1、从数组开头开始依次比较相邻两个元素，如果大小关系相反则交换位置</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192140973.png" style="zoom:67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4) 快速排序"></a>(4) 快速排序</h3><blockquote><p>时间复杂度：平均 O(nlogn)，最坏 O(n^2)<br>空间复杂度：平均 O(logn)，最坏 O(n)<br>稳定性：不稳定</p></blockquote><ul><li><p>思路：<br>  以整个数组为对象执行 QuickSort<br>  QuickSort 流程如下：<br>  1、通过分割将对象局部数组分割为前后两个局部数组<br>  2、对前半部分的局部数组执行 QuickSort<br>  3、对后半部分的局部数组执行 QuickSort</p></li><li><p>第 1 趟快排：</p><ul><li><p>从待排序码中，选出 1 个 K（如 R0.key ）</p><ul><li>将小于 k 的记录移动到左边（左子表），</li><li>大于 k 的记录移动到右边（右子表），</li><li>将 k 放在左、右两个子表的分界处</li></ul></li><li><p>左游历下标：i=0， 右游历下标：j=n-1,<br>  取出分区基准：temp=R[0]</p><ul><li>初始空位 R[0]：在左表中，即 R[i]</li></ul></li><li><p>重复以下两种扫描，<strong>直到 i==j （空位置在左，则 j 扫描；空位置在右，则 i 扫描)</strong></p><ul><li>j 向左扫描，直到 R[j].key &lt; temp.key，<br>  将 R[j]移动到空位 R[i]中，则 R[j]为空，令 i++</li><li>i 向右扫描，直到 R[i].key &gt; temp.key，<br>  将 R[i]移动到空位 R[ j]中，则 R[i]为空，令 j - -</li></ul></li><li><p>将“分区基准” temp，放到空位 R[i]中</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192143880.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192144818.png" style="zoom:50%;" ></li></ul></li></ul></li><li><p>第 2 趟快排：</p><ul><li>对 K 左、右两个字表，分别执行 1 趟快排 - 4 个子表<br>  … …</li></ul></li><li><p>直到：各子表长度 ≤1</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192148803.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192149615.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192149319.png" style="zoom:50%;" ></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 快排划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = a[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;                      <span class="comment">// l != r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= p) --r;  <span class="comment">// r 向左扫描</span></span><br><span class="line">        a[l] = a[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= p) ++l;  <span class="comment">// l 向右扫描</span></span><br><span class="line">        a[r] = a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = p;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">Partition</span>(a, l, r);</span><br><span class="line">        <span class="built_in">QuickSort</span>(a, l, p - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(a, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 三数取中优化，此版本快的飞起</span></span><br><span class="line"><span class="comment">// https://www.cnblogs.com/chengxiao/p/6262208.html</span></span><br><span class="line"><span class="comment">// - 左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; mid) i++;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; mid) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; j) <span class="built_in">QuickSort</span>(a, l, j);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r) <span class="built_in">QuickSort</span>(a, i, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="(5) 简单选择排序"></a>(5) 简单选择排序</h3><blockquote><p>时间复杂度：平均 O(n^2)，最坏 O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p>思路：</p><ul><li>重复执行 N-1 次 下述处理：<ol><li>找出未排序部分最小值的位置 minj</li><li>将 minj 位置的元素与未排序部分的起始元素交换</li></ol></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192152371.png" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j]&lt;a[k]) k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i!=k) <span class="built_in">swap</span>(a[i],a[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="(6) 堆排序"></a>(6) 堆排序</h3><blockquote><p>时间复杂度：平均 O(nlogn)，最坏 O(nlogn)，最好 n(nlogn)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p>思路：</p><ul><li><p>将待排序数据建立成大根堆</p><ul><li><p>将待排序记录建成 1 个完全二叉树（<strong>从左往右</strong>插入），再“<strong>从后向前</strong>”依次调整 sift</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192153994.png&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>sift（待调整：x）：<strong>就是让其满足大根堆</strong><ul><li>判断“待调整 x”是否 &gt;左孩子 &amp;&amp; &gt;右孩子<ul><li>是，则无需调整，结束</li><li>否，继续“调整 x”，即：重复，直到 x 与孩子满足堆序性，或 x 成为叶子</li></ul></li></ul></li><li>从<strong>最后结点的父亲</strong>开始，最后结点下标：n-1 父亲下标 p= (n-1-1)/2<ul><li>“从后向前”：依次调整 p, p-1, p-2, …, 0 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192154341.png" style="zoom:50%;" /><ul><li>之后 sift (3)，sift(2)，sift(1)，sift(0)，构成大根堆</li></ul></li></ul></li></ul></li></ul></li><li><p>重复：选出最大值（堆顶）、并<strong>调整</strong>剩余部分（<strong>较大的孩子上升，空位置下降</strong></p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192154904.png" style="zoom: 33%;" /></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155185.png" style="zoom: 50%;" /></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155222.png" style="zoom: 50%;" /></li><li><p>以此类推，直到堆无剩余元素</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155994.png" style="zoom:50%;" /></li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - 图解 https://www.cnblogs.com/chengxiao/p/6129630.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 调整以 k 为根的子树，即 shift 操作</span></span><br><span class="line"><span class="comment">// - 大孩子上升，空位置下降</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  如果左子结点小于右子结点，i指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; a[i] &lt; a[i + <span class="number">1</span>]) i++;</span><br><span class="line">        <span class="comment">//  如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; t) &#123;</span><br><span class="line">            a[k] = a[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[k] = t;  <span class="comment">// t 放在最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// - 建立大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">HeadAdjust</span>(a, i, len);</span><br><span class="line">    <span class="comment">// - 交换堆顶堆低元素 + 调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">HeadAdjust</span>(a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、其他排序"><a href="#4、其他排序" class="headerlink" title="4、其他排序"></a>4、其他排序</h2><h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="(7) 归并排序"></a>(7) 归并排序</h3><blockquote><p>时间复杂度： O(nlogn) (好、坏、平均)<br>空间复杂度：O(n)<br>稳定性：稳定</p></blockquote><p>思路：</p><p>以整个数组为对象执行 mergeSort</p><ul><li>mergeSort：<ol><li>将给定包含 n 个元素的局部数组分割成两个局部数组</li><li>对局部数组分别 mergeSort</li><li>通过 merge 将两个已排序的数组整合为一个数组</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = begin, right = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - begin + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//顺序选取两个有序区的较小元素，存储到t数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="comment">//较小的先存入temp中</span></span><br><span class="line">        <span class="keyword">if</span> (a[left] &lt;= a[right])</span><br><span class="line">            temp[k++] = a[left++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = a[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若比较完之后，有序区仍有剩余，则直接复制到t数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) temp[k++] = a[left++];</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= end) temp[k++] = a[right++];</span><br><span class="line">    <span class="comment">//将排好序的存回arr中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin, k = <span class="number">0</span>; i &lt;= end; i++, k++) a[i] = temp[k];</span><br><span class="line">    <span class="comment">//删除指针，释放空间</span></span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(a, begin, mid);    <span class="comment">// 左侧递归</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end);  <span class="comment">// 右侧递归</span></span><br><span class="line">        <span class="built_in">Merge</span>(a, begin, mid, end);   <span class="comment">// 归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>, begin, mid, end;</span><br><span class="line">    <span class="keyword">while</span> (size &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin + size &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            mid = begin + size - <span class="number">1</span>;</span><br><span class="line">            end = mid + size;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; n - <span class="number">1</span>)  <span class="comment">//第二个序列个数不足size</span></span><br><span class="line">                end = n - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Merge</span>(a, begin, mid, end);</span><br><span class="line">            begin = end + <span class="number">1</span>;  <span class="comment">//下一次归并时第一关序列的下界</span></span><br><span class="line">        &#125;</span><br><span class="line">        size *= <span class="number">2</span>;  <span class="comment">//扩大范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="(8) 基数排序"></a>(8) 基数排序</h3><blockquote><p>时间复杂度： O(d(n+r)) d: d 趟分配和收集<br>空间复杂度：O(r) r: r 个队列<br>稳定性：稳定</p></blockquote><p><strong>看图理解：</strong> <img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" style="zoom:67%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 辅助函数，求数据的最大位数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> maxData = data[<span class="number">0</span>];  <span class="comment">///&lt; 最大数  </span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i]) maxData = data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p) &#123;  </span><br><span class="line">        <span class="comment">// p *= 10; // Maybe overflow  </span></span><br><span class="line">        maxData /= <span class="number">10</span>;  </span><br><span class="line">        ++d;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> d;  </span><br><span class="line"> <span class="comment">/*    </span></span><br><span class="line"><span class="comment"> int d = 1; //保存最大的位数  </span></span><br><span class="line"><span class="comment"> int p = 10;  </span></span><br><span class="line"><span class="comment"> for(int i = 0; i &lt; n; ++i)&#123;  </span></span><br><span class="line"><span class="comment"> while(data[i] &gt;= p)&#123;  </span></span><br><span class="line"><span class="comment"> p *= 10;  </span></span><br><span class="line"><span class="comment"> ++d;  </span></span><br><span class="line"><span class="comment"> &#125;  </span></span><br><span class="line"><span class="comment"> &#125;  </span></span><br><span class="line"><span class="comment"> return d;</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ? 基数排序  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(data, n);  </span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//计数器  </span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= d; i++)  <span class="comment">//进行d次排序  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) count[j] = <span class="number">0</span>;  <span class="comment">//每次分配前清空计数器  </span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;  <span class="comment">//统计每个桶中的记录数  </span></span><br><span class="line">            count[k]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)  </span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j];  <span class="comment">//将tmp中的位置依次分配给每个桶  </span></span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//将所有桶中记录依次收集到tmp中  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;  </span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];  </span><br><span class="line">            count[k]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)  <span class="comment">//将临时数组的内容复制到data中  </span></span><br><span class="line">            data[j] = tmp[j];  </span><br><span class="line">        radix = radix * <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">delete</span>[] tmp;  </span><br><span class="line">    <span class="keyword">delete</span>[] count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、排序比较"><a href="#5、排序比较" class="headerlink" title="5、排序比较"></a>5、排序比较</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192157440.png" style="zoom:50%;" /><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192203045.png" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Sort" scheme="http://blog.sukiu.top/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://blog.sukiu.top/Language/Language-Golang/"/>
    <id>http://blog.sukiu.top/Language/Language-Golang/</id>
    <published>2022-01-19T07:30:14.000Z</published>
    <updated>2022-01-19T08:35:29.259Z</updated>
    
    <content type="html"><![CDATA[<p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://time.geekbang.org/column/intro/100093501?tab=catalog">Tony Bai · Go 语言第一课</a></p></blockquote><h2 id="1、常量"><a href="#1、常量" class="headerlink" title="1、常量"></a>1、常量</h2><p>Go 语言的常量是一种在源码编译期间被创建的语法元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="keyword">float64</span> = <span class="number">3.14159265358979323846</span> <span class="comment">// 单行常量声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以const代码块形式声明常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    size <span class="keyword">int64</span> = <span class="number">4096</span></span><br><span class="line">    i, j, s = <span class="number">13</span>, <span class="number">14</span>, <span class="string">&quot;bar&quot;</span> <span class="comment">// 单行声明多个常量</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>常量的类型只局限于基本数据类型，包括数值类型、字符串类型、布尔类型</p></blockquote><p>Go 语言在常量方面的创新包括下面这几点：</p><ul><li><p>支持无类型常量：</p><p>  可以不显示指定类型，比如 <code>const n = 13</code></p></li><li><p>支持隐式自动转型：</p><p>  对于无类型常量参与的表达式求值，Go 编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的</p></li><li><p>可用于实现枚举：</p><ul><li><p>隐式重复前一个非空表达式</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>iota 是一个预定义标识符，可以从 0 开始自增（位于同一行的 iota 即便出现多次，多个 iota 的值也是一样的）</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span>, <span class="literal">iota</span> + <span class="number">10</span> <span class="comment">// 0, 10 (iota = 0)</span></span><br><span class="line">    Strawberry, Grape <span class="comment">// 1, 11 (iota = 1)</span></span><br><span class="line">    Pear, Watermelon  <span class="comment">// 2, 12 (iota = 2)</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 如果想从 1 开始</span></span><br><span class="line"><span class="comment">// _ = iota // 0 </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2、数组和切片"><a href="#2、数组和切片" class="headerlink" title="2、数组和切片"></a>2、数组和切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一个长度固定的、由同构类型元素组成的连续序列，包含两个重要属性：元素的类型和数组长度（元素的个数）</p><p>数组变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> <span class="comment">// 一维</span></span><br><span class="line"><span class="keyword">var</span> mArr [<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span> <span class="comment">// 多维</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">6</span>]<span class="keyword">int</span> &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,&#125; <span class="comment">// [11 12 13 14 15 16]</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...]<span class="keyword">int</span> &#123; <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>,&#125; <span class="comment">// [21 22 23] ... 自动计算元素个数</span></span><br></pre></td></tr></table></figure><blockquote><p>数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。</p><p>这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针。</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。</p><p>切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。可以说，<strong>切片之于数组就像是文件描述符之于文件</strong>。</p><p>去掉“长度”这一束缚后，切片展现出更为灵活的特性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>切片的<strong>底层数据结构</strong>：在运行时其实是一个三元组结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 是指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 切片的长度，即切片中当前元素的个数</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同</p></blockquote><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>切片的创建根据情况不同，主要通过以下3种方法创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、make 函数</span></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>, <span class="number">10</span>) <span class="comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>) <span class="comment">// cap = len = 6</span></span><br><span class="line"><span class="comment">// 2、数组切片化 array[low : high : max]</span></span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">sl := arr[<span class="number">3</span>:<span class="number">7</span>:<span class="number">9</span>] <span class="comment">// len = high - low ; cap = max - low ; 即数组下标 [3,7)</span></span><br><span class="line"><span class="comment">// 3、切片创建切片 与 方法2 书写方法相同</span></span><br></pre></td></tr></table></figure><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>当通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//1 1创建底层数组 u1（长度1）</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//2 2创建底层数组 u2（长度2 = u1的两倍），拷贝 u1 元素， array 指向 u2   </span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">13</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//3 4创建底层数组 u3（长度4 = u2的两倍），拷贝 u2 元素， array 指向 u3</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">14</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//4 4cap 足够</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">15</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//5 8   创建底层数组 u4（长度8 = u3的两倍），拷贝 u3 元素， array 指向 u4</span></span><br></pre></td></tr></table></figure><h2 id="3、map"><a href="#3、map" class="headerlink" title="3、map"></a>3、map</h2><p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。</p><p>形式：<code>map[key_type]value_type</code></p><blockquote><p>Go 语言中要求，key 的类型必须支持“==”和“!=”两种比较操作符。</p><p>函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。</p></blockquote><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><p>Go 运行时使用一张<strong>哈希表</strong>来实现抽象的 map 类型。</p><p>运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。</p><p>在编译阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建map类型变量实例</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新键值对或给键重新赋值</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span> → v := runtime.mapassign(maptype, m, <span class="string">&quot;key&quot;</span>) v是用于后续存储value的空间的地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某键的值 </span></span><br><span class="line">v := m[<span class="string">&quot;key&quot;</span>]      → v := runtime.mapaccess1(maptype, m, <span class="string">&quot;key&quot;</span>)</span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某键</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)   → runtime.mapdelete(maptype, m, “key”)</span><br></pre></td></tr></table></figure><p><code>hmap</code> 类型是 <code>map</code> 类型的头部结构（header），之前提到的 map 类型的描述符，它存储了后续 map 类型操作所需的所有信息</p><blockquote><p>不要依赖 map 的元素遍历顺序；</p><p>map 不是线程安全的，不支持并发读写；</p><p>不要尝试获取 map 中元素（value）的地址</p></blockquote><p><strong>map扩容：</strong></p><p>当 count &gt; LoadFactor * 2^B 或 overflow bucket 过多时，运行时会自动对 map 进行扩容（ Go 最新 1.17 版本 LoadFactor 设置为 6.5）</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>切片类型，初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用”</p><p>map 类型，因为它内部实现的复杂性，无法“零值可用”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// m = nil</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>         <span class="comment">// 发生运行时异常：panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、使用复合字面值初始化 map 类型变量，</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;     </span><br><span class="line">    x <span class="keyword">float64</span>     </span><br><span class="line">    y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go 允许省略字面值中的元素类型</span></span><br><span class="line">m2 := <span class="keyword">map</span>[Position]<span class="keyword">string</span>&#123;</span><br><span class="line">    Position&#123;<span class="number">29.935523</span>, <span class="number">52.568915</span>&#125;: <span class="string">&quot;school&quot;</span>, <span class="comment">// Postion 可省略，如下</span></span><br><span class="line">    &#123;<span class="number">25.352594</span>, <span class="number">113.304361</span>&#125;: <span class="string">&quot;shopping-mall&quot;</span>,</span><br><span class="line">    &#123;<span class="number">73.224455</span>, <span class="number">111.804306</span>&#125;: <span class="string">&quot;hospital&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、make 函数</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>) <span class="comment">// 未指定初始容量</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">8</span>) <span class="comment">// 指定初始容量为8</span></span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>和切片类型一样，map 也是引用类型。</p><p>这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入，更新相同</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">v := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line">v, ok := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line">    <span class="comment">// &quot;key1&quot;不在map中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key2&quot;</span>) <span class="comment">// 删除&quot;key2&quot;</span></span><br><span class="line"><span class="comment">// 遍历，对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; </span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%d, %d] &quot;</span>, k, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、defer"><a href="#4、defer" class="headerlink" title="4、defer"></a>4、defer</h2><p>defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。</p><ul><li><p>在 Go 中，只有在函数（和方法）内部才能使用 defer</p></li><li><p>defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。</p><p>defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201191633765.png" style="zoom: 50%;" /><p>所以，deferred 函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Process-And-Thread/"/>
    <id>http://blog.sukiu.top/Operating-System/Process-And-Thread/</id>
    <published>2022-01-15T11:03:07.000Z</published>
    <updated>2022-01-16T12:20:34.196Z</updated>
    
    <content type="html"><![CDATA[<p>线程是最小的执行单元，而进程由至少一个线程组成。</p><p>如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/or5lgc/">进程与线程 - 力扣（LeetCode）</a></p></blockquote><h2 id="1、进程概念"><a href="#1、进程概念" class="headerlink" title="1、进程概念"></a>1、进程概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们编译的代码可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU执行内存中指令，这个<strong>运行的程序</strong>被称为进程。</p><p>进程是对运行时程序的封装，操作系统进行资源调度和分配的基本单位。</p><blockquote><p>如果包含线程的话，<strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>独立调度</strong>的基本单位。</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li><p>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程⼀样，都是clone</p></li><li><p>从内核⾥看进程和线程是⼀样的，都有各自不同的PCB</p></li><li><p>进程可以蜕变成线程</p></li><li><p>在linux下，线程最是小的执⾏单位；进程是最小的分配资源单位</p></li></ol><blockquote><p><strong>进程与线程的区别</strong>：</p><p>Ⅰ拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></blockquote><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。</p><p>每个进程占有⼀个进程表项(进程控制块)。</p><blockquote><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p></blockquote><p>该表项是进程存在的唯⼀标识，其包括以下信息：</p><ul><li>进程描述信息： 进程标识符、用户标识符等</li><li>进程控制和管理信息： 进程状态，进程优先级等</li><li>进程资源分配清单： 虚拟内存地址空间信息，打开文件列表，IO设备信息等</li><li>CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续执行</li></ul><p>PCB通过链表形式组织起来，比如有就绪队列、阻塞队列等，方便增删，方便进程管理。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>单个核心在很短时间内分别执行多个进程，称为<strong>并发</strong>（同一时间段）</li><li>多个核⼼同时执行多个进程称为<strong>并行</strong>（同一时刻）</li><li>对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>除了<strong>创建</strong>和<strong>结束</strong>⼀般有三个状态：</p><ul><li><p>运行态： 该时刻进程占用CPU</p></li><li><p>就绪态： 可运行，由于其他进程处于运行状态而暂时停止运行 <strong>等待被调度</strong></p></li><li><p>阻塞态： 该进程正在等待某⼀事件发生（如等待输⼊/输出操作的完成）而暂时停止运行 <strong>等待资源</strong></p><blockquote><p>阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换⼊到物理内存。</p></blockquote></li></ul><p>挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</p><ul><li><p>阻塞挂起状态： 进程在外存（硬盘）并等待某个事件的出现</p></li><li><p>就绪挂起状态： 进程在外存（硬盘），但只要进⼊内存，马上运行</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201152122755.png" style="zoom: 67%;" /><blockquote><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。</li><li>就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态</li><li>运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul></blockquote><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。</p><ol><li>它是⼀个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</li><li>⼀般采用以d结尾的名字</li><li>所有的服务存在于 etc/init.d</li><li>守护进程是个特殊的孤儿进程</li><li>之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示</li><li>Linux 的⼤多数服务器就是用守护进程实现的</li></ol><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>多进程程序，父进程⼀般需要跟踪子进程的退出状态，当子进程退出，父进程在运行，子进程必须等到父进程捕获到了子进程的退出状态才真正结束。在子进程结束后，父进程读取状态前，此时子进程为僵尸进程。</p><p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。</p><p>但是子进程停止在僵尸态会占据内核资源，所以需要避免僵尸进程的产生或立即结束子进程的僵尸态。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>进程结构由以下几个部分组成：代码段、堆栈段、数据段。</p><p>代码段是静态的⼆进制代码，多个程序可以共享。</p><p>父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎⼀样。</p><p>父、子进程共享全部数据，子进程在写数据时会使用写时复制技术将公共的数据重新拷贝⼀份，之后在拷贝出的数 据上进行操作；不是对同⼀块数据进行操作；如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p><h2 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、进程调度</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><h4 id="先来先服务-first-come-first-serverd（FCFS）"><a href="#先来先服务-first-come-first-serverd（FCFS）" class="headerlink" title="先来先服务 first-come first-serverd（FCFS）"></a>先来先服务 first-come first-serverd（FCFS）</h4><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="短作业优先-shortest-job-first（SJF）"><a href="#短作业优先-shortest-job-first（SJF）" class="headerlink" title="短作业优先 shortest job first（SJF）"></a>短作业优先 shortest job first（SJF）</h4><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="最短剩余时间优先-shortest-remaining-time-next（SRTN）"><a href="#最短剩余时间优先-shortest-remaining-time-next（SRTN）" class="headerlink" title="最短剩余时间优先 shortest remaining time next（SRTN）"></a>最短剩余时间优先 shortest remaining time next（SRTN）</h4><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。</p><p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。<br>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系，因为进程切换都要保存进程的信息并且载入新进程的信息</p><ul><li>如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，</p><p>例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="3、进程通信"><a href="#3、进程通信" class="headerlink" title="3、进程通信"></a>3、进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。</p><ul><li><p>同一主机</p><ul><li>无名管道 ：半双工（单方向交替传输）、只能在父子进程或者兄弟进程中使用</li><li>有名管道：（FIFO）去除了管道只能在父子进程中使用的限制。</li><li>信号：信号是软件中断，它是在软件层次上对中断机制的⼀种模拟，是⼀种异步通信的方式</li><li>消息队列：A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。</li></ul><blockquote><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul></blockquote><ul><li>共享存储：存储映射I/O (Memory-mapped I/O) 使⼀个磁盘⽂件与存储空间中的⼀个缓冲区相映射。</li></ul><blockquote><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，可以直接读写内存，所以这是最快的一种 IPC</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p></blockquote><ul><li>信号量：它是一个计数器，用于为多个进程提供对共享数据对象的访问。</li></ul></li><li><p>不同主机</p><ul><li>Socket 套接字</li></ul></li></ul><h2 id="4、进程同步"><a href="#4、进程同步" class="headerlink" title="4、进程同步"></a>4、进程同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>也叫互斥量，互斥锁是⼀种简单的加锁的⽅法来控制对共享资源的访问，互斥锁只有两种状态，即加锁( lock )和解锁 ( unlock )</p><ol><li><p>在访问共享资源后临界区域前，对互斥锁进行加锁</p></li><li><p>在访问完成后释放互斥锁导上的锁</p></li><li><p>对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放</p></li></ol><p>互斥锁的数据类型是： <code>pthread_mutex_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="死锁-DeadLock"><a href="#死锁-DeadLock" class="headerlink" title="死锁 DeadLock"></a>死锁 DeadLock</h3><p>如果⼀个进程集合中的每⼀个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁</p><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>死锁产生必须同时满足四个条件，只要其中任意一条不成立，死锁就不会发生。</p><ul><li><p>互斥条件<br>  进程要求对所分配的资源（比如打印机）进行排他性控制，即在一段时间内某资源只能由一个进程占有。</p><p>  此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>不可剥夺条件<br>  进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。</p></li><li><p>请求并保持条件<br>  进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>循环等待条件<br>  存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p></li></ul><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p><strong>每种类型⼀个资源的死锁检测：</strong></p><p>通过检测有向图中是否存在环来实现，从⼀个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁发生。</p><p><strong>每种类型多个资源的死锁检测：</strong></p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><p><strong>从死锁中恢复：</strong></p><ul><li>利用抢占恢复：将进程挂起，强行取走资源给另⼀个进程使用，用完再放回</li><li>利用回滚恢复：复位到更早的状态，那时它还没有取得所需的资源</li><li>通过杀死进程恢复：杀掉环中的⼀个进程或多个，牺牲掉⼀个环外进程</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>在程序运行之前预防发生死锁，其实就是破坏死锁产生的必要条件，破坏任何一个，死锁都不会发生。</p><ul><li>破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li><li>破坏请求和保持条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</li><li>破坏不可剥夺条件：保证每⼀个进程在任何时刻只能占用⼀个资源，如果请求另⼀个资源必须先释放第⼀个资源。</li><li>破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li><strong>安全状态：</strong>如果没有死锁发⽣，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每⼀个进程运行完毕</li><li><strong>单个资源的银行家算法：</strong>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是<strong>判断对请求的满足是否会进入不安全状态</strong>，如果是，就拒绝请求；否则予以分配。</li><li><strong>多个资源的银行家算法：</strong>如果一个状态不是安全的，需要拒绝进入这个状态。</li></ul><blockquote><p>检查一个状态是否安全的算法如下：</p><ol><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ol></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应⽤。</p><p>为了满⾜当前能够允许多个读出，但只允许⼀个写入的需求，线程提供了读写锁来实现。</p><p><strong>读写锁的特点：</strong></p><ul><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作</li></ul><p>POSIX 定义的读写锁的数据类型是： <code>pthread_rwlock_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 读锁定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 写锁定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。</p><p>条件变量用来自动阻塞⼀个线程，直到某特殊情况发生为止。</p><p>通常条件变量和互斥锁同时使用。相较于mutex而言，条件变量可以减少竞争。</p><p><strong>条件变量的两个动作</strong>：</p><ul><li>条件不满, 阻塞线程</li><li>当条件满足 通知阻塞的线程开始工作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 删除条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct *<span class="keyword">restrict</span> abstime)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><blockquote><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。</strong>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了条件变量以及相关的操作：</p><ul><li><p>wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。</p></li><li><p>signal() 操作用于唤醒被阻塞的进程。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;线程是最小的执行单元，而进程由至少一个线程组成。&lt;/p&gt;
&lt;p&gt;如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。&lt;/p&gt;
&lt;p&gt;多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Thread" scheme="http://blog.sukiu.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://blog.sukiu.top/Algorithm/Dynamic-Programming/"/>
    <id>http://blog.sukiu.top/Algorithm/Dynamic-Programming/</id>
    <published>2022-01-03T05:47:38.000Z</published>
    <updated>2022-01-14T08:50:54.312Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（Dynamic Programming，简称DP），如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>和贪心的区别在于：</p><ul><li>动态规划中每一个状态一定是由上一个状态推导出来的</li><li>贪心没有状态推导，而是从局部直接选最优的，</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p></blockquote><p>卡子哥的<strong>DP五部曲</strong>：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201031418164.png" style="zoom: 50%;" /><h2 id="1、背包问题"><a href="#1、背包问题" class="headerlink" title="1、背包问题"></a>1、背包问题</h2><blockquote><p>对于面试，掌握01背包和完全背包就够用了，最多可以再来一个多重背包。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201061504469.png" style="zoom:80%;" /><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>有N件物品和一个最多能背重量为 <code>W</code> 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。</p><p><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><ol><li><p><code>dp[i][j]</code>：从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少</p></li><li><p>有两个方向推出来<code>dp[i][j]</code>：</p></li></ol><ul><li><p><strong>不放物品 i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为j，里面不放物品i的最大价值</p></li><li><p><strong>放物品 i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]] </code>为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> ，就是背包放物品i得到的最大价值</p></li><li><p>动态转移公式：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])$</p></li></ul><ol start="3"><li>初始化：由递推公式看出，必须初始化<code>dp[0][j]</code>（存放编号0的物品的时候，各个容量的背包所能存放的最大价值）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(bagWeight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>遍历顺序：先遍历物品和先遍历背包重量都可，<strong>先遍历物品</strong>更好理解</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 01背包</span></span><br><span class="line"><span class="comment">- 动态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化, dp[0][j]</span></span><br><span class="line">    <span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; weight[i] &#123; <span class="comment">// 放不下</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><p>滚动数组：把二维 dp 降为一维 dp</p><blockquote><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code></strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）</p><p><strong>倒叙遍历是为了保证物品i只被放入一次</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化 一维</span></span><br><span class="line"><span class="comment">// - dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblemBetter</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> weight &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123; <span class="comment">// 倒序，正序会状态重复</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有 <code>N</code> 件物品和一个最多能背重量为 <code>W</code> 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。</p><p><strong>每件物品能用无数次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><blockquote><p><strong>01背包和完全背包唯一不同就是体现在遍历顺序上：</strong></p><ul><li><p>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p></li><li><p>完全背包的物品是可以添加多次的，所以要从小到大去遍历</p></li></ul><p><strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品, 再遍历背包</span></span><br><span class="line"><span class="comment">// ! 如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先遍历背包, 再遍历物品</span></span><br><span class="line"><span class="comment">// ! 如果求排列数就是外层for遍历背包，内层for循环遍历物品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem2</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weight[i] &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有 <code>N</code> 种物品和一个容量为 <code>V</code> 的背包。第 <code>i</code> 种物品最多有 $M_i$ 件可用，每件耗费的空间是  $C_i$ ，价值是 $W_i$ 。<br>求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p><blockquote><p>每件物品最多有 $M_i$ 件可用，把 $M_i$ 件摊开，其实就是一个01背包问题了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 转换成 01 背包</span></span><br><span class="line"><span class="comment">// - O(m*n*k)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value, nums []<span class="keyword">int</span>, bagweight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagweight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> weight &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bagweight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">            <span class="comment">// 遍历背包个数</span></span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; j-k*weight[i] &gt;= <span class="number">0</span>; k++ &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-k*weight[i]]+k*value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fmt.Println(dp)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagweight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、打家劫舍"><a href="#2、打家劫舍" class="headerlink" title="2、打家劫舍"></a>2、打家劫舍</h2><h3 id="一条边"><a href="#一条边" class="headerlink" title="一条边"></a>一条边</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p></blockquote><p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong></p><p>那么需要考虑2种情况：</p><ul><li>i 偷：$dp[i]=dp[i-2]+nums[i]$</li><li>i 不偷：$dp[i]=dp[i-1]$</li></ul><p>所以动态转移公式为：$dp[i]=max(dp[i-2]+nums[i],dp[i-1])$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="围成圈"><a href="#围成圈" class="headerlink" title="围成圈"></a>围成圈</h3><blockquote><p>在一条边的基础上，收尾相连形成圈</p></blockquote><p>只要比较 首和尾存一个 的两种情况即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robrob</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>),</span><br><span class="line">                   <span class="built_in">robrob</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robrob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="形成树"><a href="#形成树" class="headerlink" title="形成树"></a>形成树</h3><blockquote><p>变成一棵二叉树，树形dp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure></blockquote><p>dp数组记录2个状态：</p><ul><li><p>dp[0]：记录不偷该节点所得到的的最大金钱</p></li><li><p>dp[1]：记录偷该节点所得到的的最大金钱</p></li></ul><blockquote><p>长度为2的数组怎么标记树中每个节点的状态呢？</p><p>在递归的过程中，系统栈会保存每一层递归的参数</p></blockquote><p>左右根顺序（后序）遍历，那么分为 2 种情况：</p><ul><li>根偷：两个子结点不偷 $ = left[0] + right[0] + root-&gt;val$</li><li>根不偷：考虑两个子结点偷 $ = max(left[0], left[1]) + max(right[0], right[1])$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> v2 = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> &#123;v1, v2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、股票问题"><a href="#3、股票问题" class="headerlink" title="3、股票问题"></a>3、股票问题</h2><p>主要通过二维数组记录各个状态，分析好每个状态的转移公式即可。</p><p>也可以滚动数组优化到一维，相当于覆盖前面的状态，不过不容易理解。</p><h3 id="买卖1次"><a href="#买卖1次" class="headerlink" title="买卖1次"></a>买卖1次</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> </p><blockquote><p>虽然有动态规划的思想，但第一感觉还是这样写</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minn = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minn &gt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, prices[i] - minn);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="买卖多次"><a href="#买卖多次" class="headerlink" title="买卖多次"></a>买卖多次</h3><blockquote><p>你可以尽可能地完成更多的交易</p></blockquote><p>二维数组记录2个状态：</p><ul><li><p><code>dp[i][0]</code> ：表示第<code>i</code>天持有股票所得最多现金 </p></li><li><p><code>dp[i][1]</code> ：表示第<code>i</code>天不持有股票所得最多现金</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dp[i][0] 持有股票</span></span><br><span class="line">    <span class="comment">// dp[i][1] 不持有股票</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最多买卖2次"><a href="#最多买卖2次" class="headerlink" title="最多买卖2次"></a>最多买卖2次</h3><blockquote><p>你最多可以完成 <strong>两笔</strong> 交易。</p></blockquote><p>二维数组记录5个状态：</p><ul><li><code>dp[i][0]</code>：无操作</li><li><code>dp[i][1]</code>：第一次买入状态</li><li><code>dp[i][2]</code>：第一次卖出状态</li><li><code>dp[i][3]</code>：第二次买入状态</li><li><code>dp[i][4]</code>：第二次卖出状态</li></ul><blockquote><p>上面的状态不一定是第 i 天买入卖出，只是维持这种状态</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最多买卖k次"><a href="#最多买卖k次" class="headerlink" title="最多买卖k次"></a>最多买卖k次</h3><blockquote><p>你最多可以完成 <strong>k</strong> 笔交易。</p></blockquote><p>照着上面那个维护 $2*k+1$ 个状态即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * k; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="含冷却期"><a href="#含冷却期" class="headerlink" title="含冷却期"></a>含冷却期</h3><blockquote><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)</li></ul></blockquote><p>二维数组记录4个状态：</p><ul><li><code>dp[i][0]</code>：买入状态</li><li><code>dp[i][1]</code>：卖出状态（非冷却期）</li><li><code>dp[i][2]</code>：卖出状态（刚卖出）</li><li><code>dp[i][3]</code>：卖出状态（冷却期）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] =</span><br><span class="line">                <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                   <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="含手续费"><a href="#含手续费" class="headerlink" title="含手续费"></a>含手续费</h3><blockquote><p>每笔交易你只需要为支付一次手续费。</p></blockquote><p>跟买卖多次差不多，添上手续费即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee, dp[i - <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 这里减去手续费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、子序列问题"><a href="#4、子序列问题" class="headerlink" title="4、子序列问题"></a>4、子序列问题</h2><h3 id="子序列不连续"><a href="#子序列不连续" class="headerlink" title="子序列不连续"></a>子序列不连续</h3><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p></blockquote><p><code>dp[i][j]</code>：长度为<code>[0, i - 1]</code>的字符串text1与长度为<code>[0, j - 1]</code>的字符串text2的最长公共子序列</p><p>那么分为两种情况：</p><ul><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>相同</li><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>不相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类似题目：不相交的线</p><p>只是换了种题目说法，解法一模一样，转换过来就是最长公共子序列</p></blockquote><h3 id="子序列连续"><a href="#子序列连续" class="headerlink" title="子序列连续"></a>子序列连续</h3><blockquote><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote><p><code>dp[i][j]</code>：以下标<code>i - 1</code><strong>结尾</strong>的字符串A与以下标<code>j - 1</code><strong>结尾</strong>的字符串B的最长重复子数组</p><p>那么只要考虑<code>nums1[i - 1]</code> 与 <code>nums2[j - 1]</code>相同时，更新长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// else 无事发生，即 dp[i][j] = 0</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><blockquote><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul></blockquote><p><code>dp[i][j]</code> 表示以下标<code>i-1</code>为结尾的字符串word1，和以下标<code>j-1</code>为结尾的字符串word2的最近编辑距离</p><p>那么需要维护以下4种状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure><ul><li>操作一：word1删除一个元素，那么就是以下标 <code>i - 2</code> 为结尾的word1 与 <code>j-1</code> 为结尾的word2的最近编辑距离 再加上一个操作</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p><ul><li>操作二：word2删除一个元素，那么就是以下标 <code>i - 1</code> 为结尾的word1 与 <code>j-2</code> 为结尾的word2的最近编辑距离 再加上一个操作</li></ul><p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p><blockquote><p>word2添加一个元素，相当于word1删除一个元素，即<strong>增删等同</strong></p></blockquote><ul><li><p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</p><p>即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i; <span class="comment">// 删除 i 个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j; <span class="comment">// 删除 j 个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p></blockquote><p><code>dp[i][j]</code>：表示区间范围<code>[i,j]</code> （左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false</p><ul><li><p>当s[i]与s[j]不相等，<code>dp[i][j]</code>一定是false。</p></li><li><p>当s[i]与s[j]相等时，</p><ul><li><p>情况一：下标 i 与 j 相同，同一个字符例如 a，当然是回文子串</p></li><li><p>情况二：下标 i 与 j 相差为1，例如aa，也是文子串</p></li><li><p>情况三：下标 i 与 j 相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看 i 到 j 区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true</p></li></ul></li></ul><p><strong>一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="回文子序列"><a href="#回文子序列" class="headerlink" title="回文子序列"></a>回文子序列</h4><blockquote><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p></blockquote><p><code>dp[i][j]</code>：字符串 s 在<code>[i, j]</code>范围内最长的回文子序列的长度</p><ul><li>如果s[i]与s[j]相同，那么 $dp[i][j] = dp[i + 1][j - 1] + 2$</li><li>如果s[i]与s[j]不相同，那么 $dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划（Dynamic Programming，简称DP），如果某一问题有很多重叠子问题，使用动态规划是最有效的。&lt;/p&gt;
&lt;p&gt;和贪心的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划中每一个状态一定是由上一个状态推导出来的&lt;/li&gt;
&lt;li&gt;贪心没有状态推导，而是从局部直接选最优的，&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="DP" scheme="http://blog.sukiu.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Shell</title>
    <link href="http://blog.sukiu.top/Language/Shell/"/>
    <id>http://blog.sukiu.top/Language/Shell/</id>
    <published>2021-12-28T12:14:49.000Z</published>
    <updated>2022-01-06T07:30:33.209Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 脚本的一些注意点</p><span id="more"></span><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -e file/dir ] <span class="comment"># 如果文件/目录存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -f file ] <span class="comment"># 如果文件存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -d dir ]  <span class="comment"># 如果目录存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -s file ] <span class="comment"># 如果文件存在且非空  </span></span><br><span class="line"><span class="keyword">if</span> [ -r file ] <span class="comment"># 如果文件存在且可读  </span></span><br><span class="line"><span class="keyword">if</span> [ -w file ] <span class="comment"># 如果文件存在且可写  </span></span><br><span class="line"><span class="keyword">if</span> [ -x file ] <span class="comment"># 如果文件存在且可执行</span></span><br></pre></td></tr></table></figure><h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ int1 -eq int2 ] <span class="comment"># 如果 ==  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ne int2 ] <span class="comment"># 如果 !=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ge int2 ] <span class="comment"># 如果 &gt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -gt int2 ] <span class="comment"># 如果 &gt;  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -le int2 ] <span class="comment"># 如果 &lt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -lt int2 ] <span class="comment"># 如果 &lt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$string1</span> == <span class="variable">$string2</span> ] <span class="comment"># 如果 == (字符串允许使用赋值号做等号)  </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$string1</span> != <span class="variable">$string2</span> ] <span class="comment"># 如果 !=  </span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$string</span> ]           <span class="comment"># 如果string 长度非0 </span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$string</span> ]           <span class="comment"># 如果string 长度为0  </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell 脚本的一些注意点&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://blog.sukiu.top/Algorithm/Backtracking/"/>
    <id>http://blog.sukiu.top/Algorithm/Backtracking/</id>
    <published>2021-12-26T05:15:41.000Z</published>
    <updated>2021-12-30T11:08:28.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回溯的本质是穷举，穷举所有可能，然后选出想要的答案</strong>，如果想让回溯法高效一些，需要进行<strong>剪枝</strong>操作。</p><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><blockquote><p><strong>组合不强调元素顺序，排列强调元素顺序</strong>：</p><p>即 不同顺序的同样元素集合 算作排列，但不算组合</p></blockquote><span id="more"></span><blockquote><p>参考：<br><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p></blockquote><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>看到回溯，感觉和 DFS（深度优先搜索）区别不太大，两者其实是包含关系。</p><p>回溯搜索是 DFS 的一种，对于某一个搜索树来说（搜索树记录路径和状态判断），其主要的区别是：</p><ul><li>回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树</li><li>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种方法使得深度优先搜索法与回溯法没什么区别</li></ul><h2 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h2><blockquote><p>N个数里面按一定规则找出k个数的集合。</p></blockquote><p>直接 DFS 暴搜，如果满足条件返回，再加上适当剪枝即可。</p><blockquote><p>如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>。<br>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p></blockquote><p>例题：<a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= n - (k - tmp.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、切割问题"><a href="#3、切割问题" class="headerlink" title="3、切割问题"></a>3、切割问题</h2><blockquote><p>一个字符串按一定规则有几种切割方式</p></blockquote><p>具体算法类似组合问题，判断函数比较复杂。</p><p>例题：<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(s, idx, i)) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(idx, i - idx + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(s, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、子集问题"><a href="#4、子集问题" class="headerlink" title="4、子集问题"></a>4、子集问题</h2><blockquote><p>一个N个数的集合里有多少符合条件的子集</p></blockquote><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。</strong></p><p>例题：<a href="https://leetcode-cn.com/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、排列问题"><a href="#5、排列问题" class="headerlink" title="5、排列问题"></a>5、排列问题</h2><blockquote><p>N个数按一定规则全排列，有几种排列方式</p><p>排列是区分顺序的，不同顺序的集合算不同排列</p></blockquote><p>和组合问题区别在每次循环的起始位置都是 0，同时用 vis 数组来记录状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6、棋盘问题"><a href="#6、棋盘问题" class="headerlink" title="6、棋盘问题"></a>6、棋盘问题</h2><blockquote><p>N皇后，解数独等等</p></blockquote><p>给回溯函数加上 bool 返回值，找到一组成功解则返回。</p><p>例题：<a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归遍历行</span></span><br><span class="line"><span class="comment">     * 循环遍历列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(row, col, n, chess)) &#123;</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(row + <span class="number">1</span>, n, chess);</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *不能同行（递归过程中进行了同行检查）</span></span><br><span class="line"><span class="comment">     *不能同列</span></span><br><span class="line"><span class="comment">     *不能同斜线 （45度和135度角）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查列，剪枝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠45°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠135°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chess</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n, chess);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;  <span class="comment">// 检查列</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;  <span class="comment">// 检查行</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 3x3</span></span><br><span class="line">        <span class="keyword">int</span> nRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> nCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nRow; i &lt; nRow + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nCol; j &lt; nCol + <span class="number">3</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check</span>(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 9 个数都不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="built_in">dfs</span>(board); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;回溯的本质是穷举，穷举所有可能，然后选出想要的答案&lt;/strong&gt;，如果想让回溯法高效一些，需要进行&lt;strong&gt;剪枝&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;回溯法，一般可以解决如下几种问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/li&gt;
&lt;li&gt;切割问题：一个字符串按一定规则有几种切割方式&lt;/li&gt;
&lt;li&gt;子集问题：一个N个数的集合里有多少符合条件的子集&lt;/li&gt;
&lt;li&gt;排列问题：N个数按一定规则全排列，有几种排列方式&lt;/li&gt;
&lt;li&gt;棋盘问题：N皇后，解数独等等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;组合不强调元素顺序，排列强调元素顺序&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;即 不同顺序的同样元素集合 算作排列，但不算组合&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Backtracking" scheme="http://blog.sukiu.top/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://blog.sukiu.top/Computer-network/Physical-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Physical-Layer/</id>
    <published>2021-12-23T13:47:27.000Z</published>
    <updated>2021-12-23T13:58:07.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>物理层</strong>（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。</p><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong></p><p>物理层主要任务：确定与传输媒体接口有关的一些特性</p><p>四大特性：</p><ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</li><li>规程特性：定义各条物理线路的工作规程和时序关系</li></ul><p>物理层设备：中继器</p><span id="more"></span><h2 id="1、通信方式"><a href="#1、通信方式" class="headerlink" title="1、通信方式"></a>1、通信方式</h2><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232153357.png"><br>主要考虑：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="2、数据交换方式"><a href="#2、数据交换方式" class="headerlink" title="2、数据交换方式"></a>2、数据交换方式</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232156819.png" style="zoom: 40%;" /><h2 id="3、传输介质"><a href="#3、传输介质" class="headerlink" title="3、传输介质"></a>3、传输介质</h2><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><ul><li>无线电波</li><li>微波</li><li>红外线、激光</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。&lt;/p&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;strong&gt;传输数据比特流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理层主要任务：确定与传输媒体接口有关的一些特性&lt;/p&gt;
&lt;p&gt;四大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况&lt;/li&gt;
&lt;li&gt;电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制&lt;/li&gt;
&lt;li&gt;功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途&lt;/li&gt;
&lt;li&gt;规程特性：定义各条物理线路的工作规程和时序关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物理层设备：中继器&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://blog.sukiu.top/Computer-network/Data-Link-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Data-Link-Layer/</id>
    <published>2021-12-23T12:57:35.000Z</published>
    <updated>2021-12-23T13:47:32.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据链路层</strong> 是OSI参考模型中的第二层，介乎于物理层和网络层之间。</p><p>功能：在物理层提供服务的基础上向网络层提供服务</p><ul><li>最基本的服务：<strong>将源自于物理层的数据可靠地传输到相邻结点到目标机网络层</strong></li><li>主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li><li>为网络层提供服务：<ul><li>无确认的无连接服务</li><li>有确认的无连接服务</li><li>有确认的面向连接服务</li></ul></li></ul><p>重要协议：</p><ul><li>PPP（Point to Point Protocol）点-点协议</li></ul><p>链路层设备：</p><ul><li>交换机</li><li>网桥</li></ul><span id="more"></span><blockquote><p>参考：<br>王道考研</p></blockquote><h2 id="1、基本问题"><a href="#1、基本问题" class="headerlink" title="1、基本问题"></a>1、基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>针对用户是透明的；首尾是界定帧，转义字符去除数据部分和首尾相同引起歧义。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>链路层编码针对<strong>一组比特</strong>，通过冗余码的技术实现一组二进制比特串在传输过程中是否出现差错。</p><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><p>主要包括：</p><ul><li>检错编码<ul><li>奇偶校验码</li><li>循环冗余码</li></ul></li><li>纠错编码<ul><li>海明码</li></ul></li></ul><h2 id="2、流量控制"><a href="#2、流量控制" class="headerlink" title="2、流量控制"></a>2、流量控制</h2><p>主要通过滑动窗口协议，根据窗口大小分为：</p><ul><li>停止-等待协议：发送窗口 = 1，接收窗口 = 1</li><li>后退N帧协议（GBN）：发送窗口 &gt; 1，接收窗口 = 1</li><li>选择重传协议（SR）：发送窗口 &gt; 1，接收窗口 &gt; 1</li></ul><table><tr>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232122980.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123547.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123892.png" /></td></tr>       </table><h2 id="3、介质访问控制"><a href="#3、介质访问控制" class="headerlink" title="3、介质访问控制"></a>3、介质访问控制</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232127804.png" style="zoom: 33%;" /><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><blockquote><p>CSMA/CD 为载波侦听多路访问/冲突检测，是像以太网这种广播网络采用的一种机制，我们知道在以太网中多台主机在同一个信道中进行数据传输，CSMA/CD 很好的解决了共享信道通信中出现的问题，它的工作原理主要包括两个部分：</p><ul><li><strong>载波监听</strong>：当使用 CSMA/CD 协议时，总线上的各个节点都在监听信道上是否有信号在传输，如果有的话，表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据。</li><li><strong>冲突检测</strong>：当两个或两个以上节点同时监听到信道空闲，便开始发送数据，此时就会发生碰撞（数据的传输延迟也可能引发碰撞）。当两个帧发生冲突时，数据帧就会破坏而失去了继续传输的意义。在数据的发送过程中，以太网是一直在监听信道的，当检测到当前信道冲突，就立即停止这次传输，避免造成网络资源浪费，同时向信道发送一个「冲突」信号，确保其它节点也发现该冲突。之后采用一种二进制退避策略让待发送数据的节点随机退避一段时间之后重新。</li></ul></blockquote><p>CSMA/CD的工作流程可以概括为：</p><ol><li>先听后发</li><li>边发边听</li><li>冲突停发</li><li>随机重发</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232130101.png" style="zoom:33%;" /><blockquote><p>CSMA/CD: 载波监听多路访问 / 碰撞检测（Detect），用于有线局域网（LAN）<br>CSMA/CA: 载波监听多路访问 / 碰撞避免（Avoid），用于无线局域网（WIFI）</p></blockquote><h2 id="4、PPP-协议"><a href="#4、PPP-协议" class="headerlink" title="4、PPP 协议"></a>4、PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP（点对点） 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232140255.png" style="zoom: 33%;" /><h2 id="5、MAC-地址"><a href="#5、MAC-地址" class="headerlink" title="5、MAC 地址"></a>5、MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><blockquote><p>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。<br>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</p></blockquote><h3 id="为什么需要-MAC-地址"><a href="#为什么需要-MAC-地址" class="headerlink" title="为什么需要 MAC 地址"></a>为什么需要 MAC 地址</h3><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p><h3 id="为什么需要-IP-地址"><a href="#为什么需要-IP-地址" class="headerlink" title="为什么需要 IP 地址"></a>为什么需要 IP 地址</h3><p>光有MAC地址的话，寻址困难。IP地址和地域有关，可以分区域寻址，效率更高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; 是OSI参考模型中的第二层，介乎于物理层和网络层之间。&lt;/p&gt;
&lt;p&gt;功能：在物理层提供服务的基础上向网络层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最基本的服务：&lt;strong&gt;将源自于物理层的数据可靠地传输到相邻结点到目标机网络层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路&lt;/li&gt;
&lt;li&gt;为网络层提供服务：&lt;ul&gt;
&lt;li&gt;无确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的面向连接服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PPP（Point to Point Protocol）点-点协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机&lt;/li&gt;
&lt;li&gt;网桥&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>开源安卓应用推荐</title>
    <link href="http://blog.sukiu.top/Share/Open-Source-Apk-Share/"/>
    <id>http://blog.sukiu.top/Share/Open-Source-Apk-Share/</id>
    <published>2021-12-22T10:11:16.000Z</published>
    <updated>2021-12-22T11:11:30.007Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一些开源的安卓应用，可以在 <a href="https://www.f-droid.org/">F-Droid</a>或 <a href="https://github.com/">GitHub</a> 下载，主要是一些软件的第三方。</p><span id="more"></span><h2 id="F-Droid-第三方"><a href="#F-Droid-第三方" class="headerlink" title="F-Droid 第三方"></a>F-Droid 第三方</h2><h3 id="Aurora-Droid"><a href="#Aurora-Droid" class="headerlink" title="Aurora Droid"></a>Aurora Droid</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.adroid/">Aurora Droid</a></p><p>Aurora 家族成员，界面仿 PlayStroe 风格，不过上次更新已经是3月了，个人体验下来有点卡顿的感觉，没有中文。</p><p>推荐指数：⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss001.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss002.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss003.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss004.png" /></td></tr></table><h3 id="Droid-ify"><a href="#Droid-ify" class="headerlink" title="Droid-ify"></a>Droid-ify</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.looker.droidify/">Droid-ify</a></p><p>FoxyDroid 的 Fork，Matrial you风格，更新勤快，界面简洁且好看，内置了不少仓库，支持中文。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-amoled.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-amoled.png" style="zoom:10%;" /></td></tr></table><h2 id="Play-Stroe-第三方"><a href="#Play-Stroe-第三方" class="headerlink" title="Play Stroe 第三方"></a>Play Stroe 第三方</h2><h3 id="Aurora-Store"><a href="#Aurora-Store" class="headerlink" title="Aurora Store"></a>Aurora Store</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.store/">Aurora Store</a></p><p>Auroara 家族成员，美观且支持匿名登录和选区。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss001.png"/</td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss002.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss003.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss004.png"/></td></tr></table><h2 id="Telegram-第三方"><a href="#Telegram-第三方" class="headerlink" title="Telegram 第三方"></a>Telegram 第三方</h2><h3 id="Nekogram-X"><a href="#Nekogram-X" class="headerlink" title="Nekogram X"></a>Nekogram X</h3><p><a href="https://f-droid.org/zh_Hans/packages/nekox.messenger/">Nekogram X</a></p><p>可以说专门为国人定制的了，自定义选项都很实用，可以自由选择 FCM 推送。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Reddit-第三方"><a href="#Reddit-第三方" class="headerlink" title="Reddit 第三方"></a>Reddit 第三方</h2><h3 id="Infinity-for-Reddit"><a href="#Infinity-for-Reddit" class="headerlink" title="Infinity for Reddit"></a>Infinity for Reddit</h3><p><a href="https://f-droid.org/zh_Hans/packages/ml.docilealligator.infinityforreddit/">Infinity for Reddit</a></p><p>自定义项多，支持安卓12 Material you，没有广告，比官方的好用多了。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/1.png"/</td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/6.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/7.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/8.png"/></td></tr></table><h2 id="Youtube-第三方"><a href="#Youtube-第三方" class="headerlink" title="Youtube 第三方"></a>Youtube 第三方</h2><h3 id="NewPipe"><a href="#NewPipe" class="headerlink" title="NewPipe"></a>NewPipe</h3><p><a href="https://f-droid.org/zh_Hans/packages/org.schabi.newpipe/">NewPipe</a></p><p>不需要登陆，没有广告，更新勤快，对轻度使用者极其友好。<br>可惜不能自定义外观，略丑。</p><p>推荐指数：⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_01.png"/</td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_02.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_06.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_07.png"/></td></tr></table><h2 id="Twitter-第三方"><a href="#Twitter-第三方" class="headerlink" title="Twitter 第三方"></a>Twitter 第三方</h2><h3 id="Twidere-X"><a href="#Twidere-X" class="headerlink" title="Twidere X"></a>Twidere X</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.twidere.twiderex/">Twidere X</a></p><p>支持登录 Twitter 和 Mastodon，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Pixiv-第三方"><a href="#Pixiv-第三方" class="headerlink" title="Pixiv 第三方"></a>Pixiv 第三方</h2><h3 id="Pixiv-Shaft"><a href="#Pixiv-Shaft" class="headerlink" title="Pixiv-Shaft"></a>Pixiv-Shaft</h3><p><a href="https://github.com/CeuiLiSA/Pixiv-Shaft">Pixiv-Shaft</a></p><p>美观，且支持浏览部分热点排序，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-0.jpg"/</td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-3.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-4.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-5.jpg"/></td></tr></table><h2 id="贴吧-第三方"><a href="#贴吧-第三方" class="headerlink" title="贴吧 第三方"></a>贴吧 第三方</h2><h3 id="TiebaLite"><a href="#TiebaLite" class="headerlink" title="TiebaLite"></a>TiebaLite</h3><p><a href="https://github.com/HuanCheng65/TiebaLite">TiebaLite: 贴吧 Lite</a></p><p>测试版仍在更新，评论容易封号，适合只浏览。</p><p>推荐指数：⭐⭐⭐⭐</p><h2 id="V2EX-第三方"><a href="#V2EX-第三方" class="headerlink" title="V2EX 第三方"></a>V2EX 第三方</h2><h3 id="V2er"><a href="#V2er" class="headerlink" title="V2er"></a>V2er</h3><p><a href="https://github.com/v2er-app/Android">V2er.Android</a></p><p>原来付费，现在作者开源了，体验最好的 V2EX 第三方。</p><p>推荐指数：⭐⭐⭐⭐⭐</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;推荐一些开源的安卓应用，可以在 &lt;a href=&quot;https://www.f-droid.org/&quot;&gt;F-Droid&lt;/a&gt;或 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 下载，主要是一些软件的第三方。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://blog.sukiu.top/categories/Share/"/>
    
    
    <category term="App" scheme="http://blog.sukiu.top/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://blog.sukiu.top/Computer-network/Network-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Network-Layer/</id>
    <published>2021-12-22T06:57:49.000Z</published>
    <updated>2021-12-22T10:30:44.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络层</strong>（<strong>Network Layer</strong>）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。<br>由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p><p>网络层协议负责提供<strong>主机</strong>间的逻辑通信；传输层协议负责提供<strong>进程</strong>间的逻辑通信。</p><p>功能：</p><ul><li>路由选择与分组转发 <strong>最佳路径</strong></li><li>异构网络互联</li><li>拥塞控制</li></ul><p>网络层重要协议：</p><ul><li>IP（Internet Protocol）网际互连协议</li></ul><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>ARP（Address Resolution Protocol）地址解析协议</li><li>ICMP（Internet Control Message Protocol）网际控制报文协议</li><li>IGMP（Internet Group Management Protocol）网际组管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esz3b2/">力扣</a><br>王道考研</p></blockquote><h2 id="1、IP"><a href="#1、IP" class="headerlink" title="1、IP"></a>1、IP</h2><p>该协议工作在网络层，主要目的就是为了提高网络的可扩展性。</p><p>和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP 协议族的核心。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221614969.png" style="zoom: 67%;" /><p>IP 协议主要有以下几个作用：</p><ul><li><strong>寻址和路由</strong>：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><p>总长度单位1B，片位移单位8B，首部单位4B</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221622589.png" style="zoom:50%;" /><blockquote><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221624491.png" style="zoom: 60%;" /><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>IP地址由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221637019.png" style="zoom: 33%;" /><p>以上分类还空出一些地址，这些特殊的地址包括：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221639252.png" style="zoom:60%;" /><p>另外还有私有地址（局域网）：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221641441.png" style="zoom: 33%;" /><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221643433.png" style="zoom: 40%;" /><p>子网掩码：主机位全0，其他全1（网络位、子网位）</p><h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>NAT（Network Address Translation)，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。</p><p>该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><blockquote><p>在专用网连接到因特网（公用地址）的路由器上安装NAT软件（NAT路由器），它至少有一个有效的外部全球IP地址</p><ul><li>NAT路由器根据转换表替换源IP地址或者目的IP地址和端口号，所以转发数据报时需查看和转换传输层的端口号</li><li>普通路由器仅工作在网络层，不改变源IP和目的IP</li></ul></blockquote><p>NAT 的实现有三种方式：</p><ul><li>静态转换，一对一，一个私有对应一个公有</li><li>动态转换，一对多，一个私有每次转换的公有不唯一</li><li>端口多路复用，多对一，多个私有共享一个合法的外部IP，映射到了不同的端口上</li></ul><h4 id="CIDR-无分类域间路由选择"><a href="#CIDR-无分类域间路由选择" class="headerlink" title="CIDR 无分类域间路由选择"></a>CIDR 无分类域间路由选择</h4><p>CIDR（Classless Inter-Domain Routing）</p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p><code>IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221647430.png" style="zoom: 40%;" /><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>从根本上解决 IPV4 地址不够的问题。</p><blockquote><p>其他方法：<br>NAT：网络地址转换<br>DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址<br>（DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP）</p></blockquote><p>IPV6 将地址从32位（4B）扩大到了128位（64B）</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221715771.png" style="zoom: 78%;" /><h2 id="2、ARP"><a href="#2、ARP" class="headerlink" title="2、ARP"></a>2、ARP</h2><p>ARP（Address Resolution Protocol）地址解析协议，完成IP地址到MAC地址的映射（解决下一跳走哪的问题）</p><h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><ol><li>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong>，同一局域网内所有主机都能受到该请求</li><li>目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次）</li></ol><h3 id="典型情况"><a href="#典型情况" class="headerlink" title="典型情况"></a>典型情况</h3><ul><li>主机A发给本网络上的主机B：用ARP找到B的硬件地址</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址</li><li>路由器发给本网络的主机B：用ARP找到B的硬件地址</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li></ul><h2 id="3、ICMP"><a href="#3、ICMP" class="headerlink" title="3、ICMP"></a>3、ICMP</h2><p>ICMP（Internet Control Message Protocol）是网际控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）</li><li>辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>Ping</strong>：测试两个主机间的连通性，使用 ICMP 会送请求和回答报文</li><li><strong>TraceRoute</strong>：跟踪一个分组从源点到终点的路径，使用 ICMP 时间超过差错报告报文</li></ul><blockquote><p>ping 不通可能存在的问题：</p><ul><li>首先看网络是否连接正常，检查网卡驱动是否正确安装</li><li>局域网设置问题，检查 IP 地址是否设置正确</li><li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙</li><li>看是否被第三方软件拦截</li><li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到</li></ul></blockquote><h2 id="4、IGMP"><a href="#4、IGMP" class="headerlink" title="4、IGMP"></a>4、IGMP</h2><p>IGMP（Internet Group Management Protocol）网际组管理协议，让路由器知道局域网上是否有主机（的进程）参加或退出某个组播组。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221718842.png" style="zoom: 67%;" /><h2 id="5、路由器"><a href="#5、路由器" class="headerlink" title="5、路由器"></a>5、路由器</h2><p>路由器是网络层设备，通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。</p><p>路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</p><blockquote><p>交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</p></blockquote><h3 id="分组转发流程"><a href="#分组转发流程" class="headerlink" title="分组转发流程"></a>分组转发流程</h3><ol><li>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络</li><li>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器<strong>直接交付</strong>，否则执行 3</li><li>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4</li><li>逐条检查路由表，使用每一行的子网掩码与目的IP匹配。若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5</li><li>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6</li><li>无法找到合适路由，向源主机报错</li></ol><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><ul><li>RIP（Routing Information Protocol）路由信息协议</li><li>OSPF（Open Shortest Path First）开放式最短路径优先</li><li>BGP（Border Gateway Protocol）边界网关协议</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221732310.png" style="zoom:70%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;（&lt;strong&gt;Network Layer&lt;/strong&gt;）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。&lt;br&gt;由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。&lt;/p&gt;
&lt;p&gt;网络层协议负责提供&lt;strong&gt;主机&lt;/strong&gt;间的逻辑通信；传输层协议负责提供&lt;strong&gt;进程&lt;/strong&gt;间的逻辑通信。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由选择与分组转发 &lt;strong&gt;最佳路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;异构网络互联&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP（Internet Protocol）网际互连协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARP（Address Resolution Protocol）地址解析协议&lt;/li&gt;
&lt;li&gt;ICMP（Internet Control Message Protocol）网际控制报文协议&lt;/li&gt;
&lt;li&gt;IGMP（Internet Group Management Protocol）网际组管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="http://blog.sukiu.top/Computer-network/Transport-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Transport-Layer/</id>
    <published>2021-12-21T11:17:05.000Z</published>
    <updated>2021-12-22T07:47:15.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层</strong>（<strong>Transport Layer</strong>）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。</p><p>功能：使用网络层服务，为应用层提供服务</p><ul><li>提供进程和进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li></ul><p>传输层的重要协议：</p><ul><li>TCP（Transmission Control Protocol）传输控制协议</li><li>UDP（User Datagram Protocol）用户数据报协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/">力扣</a><br>王道考研</p></blockquote><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212129515.png" style="zoom:33%;" /><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211934483.png" style="zoom: 40%;" /><blockquote><p>标志位：SYN（Synchronize）、ACK（ACKnowledge Character）<br>序号：seq<br>确认号：ack</p><p>第 2 次握手为什么还要传回 SYN：</p><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（seq）同步给客户端。</p></blockquote><h4 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h4><p>三次握手保证两点：</p><ul><li>保证双方都是双工通信：<ul><li>第一次握手，服务端确定客户端的发送正常</li><li>第二次握手，客户端确认服务端的收发正常</li><li>第三次握手，服务端确定客服端接收正常</li></ul></li><li>如果只有第二次握手，服务端发给客服端的包丢了之后：<ul><li>服务端直接建立了连接，端口就会一直开着</li><li>等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接</li><li>端口越来越多，造成服务器开销的浪费</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211949356.png" alt="image-20211221194951070" style="zoom: 33%;" /><h4 id="握手异常"><a href="#握手异常" class="headerlink" title="握手异常"></a>握手异常</h4><table><thead><tr><th>异常</th><th>如何处理</th><th>备注</th></tr></thead><tbody><tr><td>第一次握手 SYN 包丢失</td><td><strong>服务端</strong>不会进行任何相应的动作<br><strong>客户端</strong>在一段时间内没有收到服务器发来的确认报文， 会等待一段时间后重新发送 SYN 同步报文，<br>若仍没有回应，则重复上述直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1</td><td>客户端超时重传最大次数：<code>tcp_syn_retries</code>，默认5次（Linux 3.7 后为6次）</td></tr><tr><td>第二次握手 SYN、ACK 包丢失</td><td><strong>客户端</strong>会采取第一次握手失败时的动作（超时重传）<br><strong>服务端</strong>此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文（同样超时重传）</td><td>服务端超时重传最大次数：<code>tcp_synack_retries</code>，默认5次</td></tr><tr><td>第三次握手 ACK 包丢失</td><td>两次握手成功，<strong>客户端</strong>进入<code>ESTABLISHED</code>状态，<strong>服务端</strong>进入<code>SYN_REC</code>状态<br><strong>服务端</strong>收不到 ACK，就一直重传 SYN、ACK 包，直到超过最大次数，断开TCP连接<br><strong>客户端</strong>认为自己连接成功，开始向服务器端发送数据，服务端收到来自客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态</td><td></td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211951252.png" style="zoom: 40%;" /><blockquote><p>标志位：Fin（Finish）<br>阶段：FIN-WAIT（半关闭）</p><p>CLOSE-WAIT：是服务端发出第一次挥手（整体第二次）进入的状态</p><p>表示“我准备关闭了，但是还有自己的事情处理一下，你等我处理完”<br>等服务器处理好自己的数据业务，则表示“我准备好了”，再发送 FIN 包</p><p>TIME-WAIT：是第四次挥手后，客户端进入的状态，是客户端必要的等待时间。</p><p>目的是：等待服务端的对应端口关闭与客户端发送到服务端的数据到达（可能出现延迟）</p><p>如果不存在这个步骤就会导致两个问题:</p><ul><li><p>客户端立即关闭后，立即又用同样的端口握手并建立通信，此时上次的连接残留的数据包会被误认为是本次的，造成数据异常</p></li><li><p>客户端直接关闭后，若服务端重新发送 FIN 包，客户端就会回应 RST，会报异常，但是实际没有问题的</p></li></ul><p>MSL（Maximum Segment Lifetime）：指一段 TCP 报文在传输过程中的最大生命周期</p><p>2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长，为的是确认服务器能否接收到客户端发出的 ACK 确认报文</p></blockquote><h4 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h4><p>简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。</p><p>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的：</p><ul><li>当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文</li><li>当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212000734.png" style="zoom:33%;" /><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP 如何保证可靠传输：</p><ul><li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li><li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li><li><strong>流量控制</strong>：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li><li><strong>拥塞控制</strong>：当网络某个节点发生拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li></ul><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p>在已发送但未确认的报文被确认之前，发送方的滑动窗口将不会滑动（类比滑动窗口算法）</p><h4 id="最大连接数限制"><a href="#最大连接数限制" class="headerlink" title="最大连接数限制"></a>最大连接数限制</h4><ul><li><strong>Client 最大 TCP 连接数</strong>：TCP 端口的数据类型是 unsigned short（$2^{16}$），可用端口最多有 65535 个（除端口0）</li><li><strong>Server最大 TCP 连接数</strong>：客户端 IP 数 × 客户端 port 数（理论）</li></ul><blockquote><p>对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 $2^{32}$（IP 数）× $2^{16}$（port 数），即约为$2^{48}$</p></blockquote><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212120334.png" style="zoom: 33%;" /><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><p>常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212127381.png" style="zoom: 40%;" /><blockquote><p><strong>拥塞控制和流量控制的区别：</strong><br>拥塞控制往往是一种全局的控制，防止过多的数据注入到网络之中<br>流量控制往往指点对点通信量的控制，是端到端的问题（TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处）</p></blockquote><h2 id="2、UDP"><a href="#2、UDP" class="headerlink" title="2、UDP"></a>2、UDP</h2><h3 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212131402.png" style="zoom: 33%;" /><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20~60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8个字节</td></tr></tbody></table><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212058636.png" style="zoom: 50%;" /><h3 id="不可靠传输"><a href="#不可靠传输" class="headerlink" title="不可靠传输"></a>不可靠传输</h3><ul><li>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，当对方接收缓冲区满了后就会丢弃，因此 UDP 不能保证数据能够到达目的地</li><li>UDP 没有流量控制和重传机制</li><li>UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号</li></ul><blockquote><p>调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。<br>调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。<br>当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p></blockquote><h2 id="3、More"><a href="#3、More" class="headerlink" title="3、More"></a>3、More</h2><h3 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。<br>通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;（&lt;strong&gt;Transport Layer&lt;/strong&gt;）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。&lt;/p&gt;
&lt;p&gt;功能：使用网络层服务，为应用层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供进程和进程之间的逻辑通信&lt;/li&gt;
&lt;li&gt;复用和分用&lt;/li&gt;
&lt;li&gt;传输层对收到的报文进行差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP（Transmission Control Protocol）传输控制协议&lt;/li&gt;
&lt;li&gt;UDP（User Datagram Protocol）用户数据报协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://blog.sukiu.top/Computer-network/Application-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Application-Layer/</id>
    <published>2021-12-12T07:28:27.000Z</published>
    <updated>2021-12-22T07:47:09.653Z</updated>
    
    <content type="html"><![CDATA[<p><strong>应用层</strong>（<strong>Application layer</strong>）位于 <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" title="OSI模型">OSI模型</a>的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。</p><p>应用层的功能：</p><ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>应用层的重要协议：</p><ul><li>HTTP（HyperText Transfer Protocol）超文本传输协议</li><li>FTP（File Transfer Protocol）文件传输协议<ul><li>TFTP（Trivial File Transfer Protocol）简单文件传输协议</li></ul></li><li>DNS（Domain Name System）域名系统</li><li>SMTP（Simple Mail Transfer Protocol）简单邮件传输协议<ul><li>POP3（Post Office Protocol - Version 3）邮局协议</li></ul></li><li>DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议</li><li>SNMP（Simple Network Management Protocol）简单网络管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eksi0s/">力扣</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP Headers - HTTP | MDN</a></p></blockquote><h2 id="1、HTTP"><a href="#1、HTTP" class="headerlink" title="1、HTTP"></a>1、HTTP</h2><h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(General Header Fields)</li><li>请求头字段(Request Header Fields)</li><li>响应头字段(Response Header Fields)</li><li>实体头字段(Entity Header Fields)</li></ul><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>同时适用于请求和响应消息（客户端和服务器都可以使用），但与最终消息主体中传输的数据无关的消息头。</p><p>可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中是否使用缓存机制</td><td>Cache-Control: no-store</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td>Connection: keep-alive (Upgrade)</td></tr><tr><td>Date</td><td>报文创建时间</td><td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td></tr><tr><td>Trailer</td><td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td><td>Trailer: Expiress</td></tr><tr><td>Transfer-Encoding</td><td>用来改变报文格式</td><td>Transfer-Encoding: chunked</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容中可能存在错误</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h4><p>包含更多有关要获取的资源或客户端本身信息的消息头，如Accept头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器自己允许哪些媒体类型</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>浏览器申明可接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己接收的编码方法</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的响应内容语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于表示 HTTP 协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号</td><td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td></tr><tr><td>If-XXX</td><td>条件请求</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数</td><td>Max-Forwards: 10</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以 0 开始</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td><td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td>User-Agent: Mozilla/……</td></tr></tbody></table><h4 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h4><p>包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头，如Server头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>字段的值表示可用于定义范围的单位</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>创建响应的时间</td><td>Age：5744337</td></tr><tr><td>ETag</td><td>唯一标识分配的资源</td><td>Etag：W/"585cd998-7c0f"</td></tr><tr><td>Location</td><td>表示重定向后的 URL</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>告知客户端多久后再发送请求</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>告知客户端服务器信息</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Vary</td><td>缓存控制</td><td>Vary: Origin</td></tr></tbody></table><h4 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h4><p>请求/响应报文中实体部分的首部，包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型，如Content-Type头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p><strong>非Keep-alive</strong>：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。<br><strong>Keep-alive</strong>：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。</p><h5 id="长连接-or-短链接"><a href="#长连接-or-短链接" class="headerlink" title="长连接 or 短链接"></a>长连接 or 短链接</h5><p><a href="https://blog.csdn.net/luzhensmart/article/details/87186401">http的长连接和短连接（史上最通俗！）以及应用场景_luzhensmart的专栏-CSDN博客_长连接和短连接的使用场景</a></p><p><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接</strong>：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h4 id="报文长度"><a href="#报文长度" class="headerlink" title="报文长度"></a>报文长度</h4><p>长度在响应报文中有两种表现形式。</p><ol><li>对于小点的文件，直接给出 content-length，也就是本次返回的数据长度</li><li>对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分块传输，这也是订好了协议，客户端收到了会进行组装，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</li></ol><p>曾经用 py 写过下载脚本，就利用了分块传输的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_size = <span class="built_in">int</span>(r.headers[<span class="string">&#x27;content-length&#x27;</span>])</span><br><span class="line"><span class="keyword">with</span> tqdm(total=file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, unit_divisor=<span class="number">1024</span>, <span class="built_in">ascii</span>=<span class="literal">True</span>,desc=filename) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            fp.write(chunk)</span><br><span class="line">            bar.update(<span class="built_in">len</span>(chunk))</span><br></pre></td></tr></table></figure><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>HTTP/1.0 定义了三种请求方法：<code>GET</code>, <code>POST</code> 和 <code>HEAD</code> 方法。</p><p>HTTP/1.1 增加了六种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p><p><del>感觉实际生产中很少会用那6种方法，极大的复杂化了api</del></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h4 id="GET-or-POST"><a href="#GET-or-POST" class="headerlink" title="GET or POST"></a>GET or POST</h4><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）</li></ul><blockquote><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。<br>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p></blockquote><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限制</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP包头<br>如果数据是中文或其它字符，则进行BASE64编码。</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><p><strong>长度限制：</strong></p><ul><li>GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</li><li>POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</li></ul><h3 id="HTTP-状态"><a href="#HTTP-状态" class="headerlink" title="HTTP 状态"></a>HTTP 状态</h3><p>HTTP 协议是<strong>无连接无状态</strong>的，并不保存关于客户端的任何信息。<br>通常有两种方法保持会话：</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。</p><blockquote><p>优点：安全性高，因为状态信息保存在服务器端。<br>缺点：由于大型网站往往采用的是分布式服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。<br>【解决方法】：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息</p></blockquote><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。<br>客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。</p><blockquote><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。<br>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据；每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p></blockquote><h4 id="Cookie-被禁用"><a href="#Cookie-被禁用" class="headerlink" title="Cookie 被禁用"></a>Cookie 被禁用</h4><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。</p><p>HTTP 状态码共有 5 种类型：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1XX</td><td>指示信息--表示请求正在处理</td></tr><tr><td>2XX</td><td>成功--表示请求已被成功处理完毕</td></tr><tr><td>3XX</td><td>重定向--要完成的请求需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器端错误--服务器处理请求出现错误</td></tr></tbody></table><p>常见的状态码有如下几种：</p><ul><li><code>200 OK</code> 客户端请求成功</li><li><code>301 Moved Permanently</code> 请求永久重定向</li><li><code>302 Moved Temporarily</code> 请求临时重定向</li><li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li><li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li><li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li><li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><blockquote><p>更多可见 <a href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 状态码_w3cschool</a></p></blockquote><h4 id="面试对状态码常见问法"><a href="#面试对状态码常见问法" class="headerlink" title="面试对状态码常见问法"></a>面试对状态码常见问法</h4><h5 id="状态码-301-和-302-的区别"><a href="#状态码-301-和-302-的区别" class="headerlink" title="状态码 301 和 302 的区别"></a>状态码 301 和 302 的区别</h5><ul><li>301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</li><li>302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</li></ul><h5 id="HTTP-异常状态码"><a href="#HTTP-异常状态码" class="headerlink" title="HTTP 异常状态码"></a>HTTP 异常状态码</h5><p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p><h2 id="2、HTTPS"><a href="#2、HTTPS" class="headerlink" title="2、HTTPS"></a>2、HTTPS</h2><p>HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式：<br>首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性。<br>通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><table>    <tr>    <td>协议</td>    <td>特点</td>    <td>工作方式</td>    </tr>    <tr>        <td>HTTP</td>        <td>        <li>明文传输，数据未加密，安全性较差        <li>默认 80 端口        <li>3 次握手建立连接        </td>        <td>        <ol>        <li>客户端请求服务器 80 端口，建立 TCP 连接        <li>客户端从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文        <li>服务端从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文        <li>通信结束，客户端与服务器关闭连接        </ol>        </td>    </tr>    <tr>        <td>HTTPS</td>        <td>        <li>加密，安全性较好        <li>默认 443 端口        <li>需数字认证机构（Certificate Authority, CA）的证书        <li>除 TCP 的 3 次握手，还需要 SSL 协商        </td>         <td>        <ol>        <li>客户端请求服务器 443 端口，建立 TCP 连接（包括支持算法，密钥长度等）        <li>服务端从双方共同支持的加密算法列表中选择一种返回给客户端（包括密钥组件）        <li>服务器返回自身 CA 证书的报文（包含证书的颁发机构、过期时间、服务端的公钥等信息）        <li>服务端发送一个完成报文通知客户端 SSL 的第一阶段已经<b>协商完成</b>        <li>客户端用本地证书库的根证书校验CA证书，生成随机密码串，用公钥加密发送给服务器，即回应报文        <li>紧接着客户端会发送一个报文提示服务端在此之后的报文是采用密码串加密的        <li>客户端发送一个 finish 报文（包含第一次握手至今所有报文的整体校验值）        <li>服务端同样发送与第 6 步中相同作用的报文，最后发送 finish 报文告诉客户端自己能够正确解密报文        <li>SSL 连接建立        </ol>        </td>    </tr></table><blockquote><p>CA 证书防止的方式：（为什么可以信任 CA 证书）<br>篡改：加密签名与原文签名对比<br>调包：请求域名与证书域名对比</p></blockquote><p>另附 HTTP 版本演变：</p><blockquote><p>直接造访 <a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez4zv6/">HTTP x.x</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161819417.png" style="zoom:67%;" /><h2 id="3、DNS"><a href="#3、DNS" class="headerlink" title="3、DNS"></a>3、DNS</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，提供了主机名和 IP 地址之间相互转换的服务。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161824712.png" style="zoom:80%;" /><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><ul><li><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<strong>帮你查</strong></li><li><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<strong>自己查</strong></li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。</p><p>大多数情况下 DNS 使用 UDP 进行传输，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><p>在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据</li></ul><blockquote><p>因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p></blockquote><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。</p><p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。</p><h4 id="预防手段"><a href="#预防手段" class="headerlink" title="预防手段"></a>预防手段</h4><ul><li>直接使用IP访问</li><li>直接指定DNS服务器（如谷歌的 8.8.8.8）</li></ul><h2 id="4、More"><a href="#4、More" class="headerlink" title="4、More"></a>4、More</h2><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><blockquote><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p></blockquote><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。<br>例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><ul><li>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li><li>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</li><li>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li></ul><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><ul><li>URL，即统一资源定位符 ( <em>Uniform Resource Locator</em> )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</li><li>URI，即统一资源标识符（ <em>Uniform Resource Identifier</em> ），只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL</li></ul><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul><li>其实就是将抓包工具视为中间人，其对于本地而言相当于服务端；而对于真正的服务端而言则相当于客户端；</li><li>抓包工具分别和本地以及服务器都进行TLS握手协商；</li><li>这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书）</li></ul><h3 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程"></a>网页解析全过程</h3><blockquote><p>这部分可以看看：<a href="https://github.com/skyline75489/what-happens-when-zh_CN"> 当···时发生了什么？what-happens-when</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161850389.png" style="zoom:67%;" /><ol><li><strong>DNS 解析</strong>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。</li><li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了</li><li><strong>发送 HTTP 请求</strong>：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</li></ol><blockquote><p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。<br>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p></blockquote><ol start="4"><li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li><li><strong>浏览器渲染</strong>：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li><strong>断开连接</strong>：客户端和服务器通过四次挥手终止 TCP 连接。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;（&lt;strong&gt;Application layer&lt;/strong&gt;）位于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B&quot; title=&quot;OSI模型&quot;&gt;OSI模型&lt;/a&gt;的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。&lt;/p&gt;
&lt;p&gt;应用层的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件传输、访问和管理&lt;/li&gt;
&lt;li&gt;电子邮件&lt;/li&gt;
&lt;li&gt;虚拟终端&lt;/li&gt;
&lt;li&gt;查询服务和远程作业登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP（HyperText Transfer Protocol）超文本传输协议&lt;/li&gt;
&lt;li&gt;FTP（File Transfer Protocol）文件传输协议&lt;ul&gt;
&lt;li&gt;TFTP（Trivial File Transfer Protocol）简单文件传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS（Domain Name System）域名系统&lt;/li&gt;
&lt;li&gt;SMTP（Simple Mail Transfer Protocol）简单邮件传输协议&lt;ul&gt;
&lt;li&gt;POP3（Post Office Protocol - Version 3）邮局协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议&lt;/li&gt;
&lt;li&gt;SNMP（Simple Network Management Protocol）简单网络管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络模型与协议</title>
    <link href="http://blog.sukiu.top/Computer-network/Models-And-Protocols/"/>
    <id>http://blog.sukiu.top/Computer-network/Models-And-Protocols/</id>
    <published>2021-12-09T01:17:18.000Z</published>
    <updated>2021-12-22T07:47:03.627Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络主要有3种模型：</p><ul><li>ISO/OSI参考模型 7层</li><li>TCP/IP参考模型 5层</li><li><strong>TCP/IP参考模型 4层</strong></li></ul><p><strong>OSI</strong>是一种理论下的<strong>模型</strong>，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekz8lr/">力扣</a><br>王道考研</p></blockquote><h2 id="1、参考模型"><a href="#1、参考模型" class="headerlink" title="1、参考模型"></a>1、参考模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。<br>OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112090939525.png" style="zoom:67%;" /><ul><li><strong>应用层</strong>：用户与网络的界面，通过应用程序间的交互来完成特定的网络应用</li></ul><blockquote><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。<br>例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。<br>在应用层交互的数据单元为报文。</p></blockquote><ul><li><strong>表示层</strong>：使通信的应用程序能够解释交换数据的含义<ul><li>数据格式变换 翻译官 <strong>数据描述</strong></li><li>数据加密解密 <strong>数据加密</strong></li><li>数据压缩和恢复 <strong>数据压缩</strong></li></ul></li></ul><blockquote><p>这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p></blockquote><ul><li><strong>会话层</strong>：负责建立、管理和终止表示层实体之间的通信会话。</li></ul><blockquote><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法（类似断点续传）。</p></blockquote><ul><li><p><strong>传输层</strong>：负责主机中两个进程的通信，即端到端通信。<font color="red">传输单位是报文段或用户数据报</font></p><ul><li><em>可</em> 靠传输、不可靠传输</li><li><em>差</em> 错控制</li><li><em>流</em> 量控制</li><li><em>复</em> 用分用（记忆：可差的也能流用？）<ul><li>复用：多个应用层进程可同时使用下面传输层的服务</li><li>分用：传输层把收到的信息分别交付给上面应用层相应的进程</li></ul></li></ul></li><li><p><strong>网络层</strong>：选择合适的网间路由和交换节点，确保数据按时成功传送。<font color="red">传输单位是数据报</font></p><ul><li><p>路由选择与分组转发 <strong>最佳路径</strong></p><blockquote><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。</p></blockquote></li><li><p>流量控制 <strong>发送速度</strong></p></li><li><p>差错控制</p></li><li><p>拥塞控制 <strong>总体速度</strong></p></li></ul></li><li><p><strong>数据链路层</strong>：把网络层传下来的数据报组装成帧。<font color="red">传输单位是帧</font></p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制 <strong>帧错+位错</strong></li><li>流量控制</li><li>访问（接入）控制 <strong>控制对信道的访问</strong></li></ul></li><li><p><strong>物理层</strong>：在物理媒体上实现比特流的透明传输。<font color="red">传输单位是比特</font></p><blockquote><p>尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么</p></blockquote><ul><li>定义接口特性（机械特性、电气特性、功能特性，过程特性）</li><li>定义传输模式 （单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li></ul><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><blockquote><p>由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。<br>三层都在应用程序内实现，程序间无法共享，合三为一就形成了 TCP/IP 模型。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091411643.png" style="zoom: 33%;" /><ul><li><p><strong>应用层</strong><br>  TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。</p><p>  例如：FTP、Telnet、DNS、SMTP 等。</p></li><li><p><strong>传输层</strong></p><p>  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。</p><p>  传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。</p><p>  其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p></li><li><p><strong>网际互联层</strong></p><p>  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。</p><p>  在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。</p><p>  根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。</p><p>  除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p></li><li><p><strong>网络接口层</strong></p><p>  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</p><p>  事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p></li></ul><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091513659.png" style="zoom: 67%;" /><h2 id="2、模型异同"><a href="#2、模型异同" class="headerlink" title="2、模型异同"></a>2、模型异同</h2><p><strong>相同点</strong></p><ul><li><p>OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p></li><li><p>都能够提供面向连接和无连接两种通信服务机制。</p></li></ul><p><strong>不同点</strong></p><ul><li><p>OSI 采用的七层模型； TCP/IP 是四层结构。</p></li><li><p>TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p></li><li><p>OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p></li><li><p>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p></li><li><p>OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091512496.png" alt="image-20211209151215402" style="zoom:50%;" /><h2 id="3、各层协议"><a href="#3、各层协议" class="headerlink" title="3、各层协议"></a>3、各层协议</h2><table>    <tbody><tr><th>OSI 七层网络模型</th><th>TCP/IP 四层概念模型</th><th>对应的网络协议</th>    </tr>    <tr><td>应用层（Application）</td><td rowspan="3">应用层</td>        <td><b>HTTP, FTP, DNS</b>, SMTP,TFTP,NFS, WAIS, Telnet, SNMP</td>    </tr>    <tr><td>表示层（Presentation）</td><td>TIFF, GIF, JPEG, PICT</td>    </tr>    <tr><td>会话层（Session）</td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>    </tr>    <tr><td>传输层（Transport）</td><td>传输层</td>        <td><b>TCP, UDP</b></td>    </tr>    <tr><td>网络层（Network）</td><td>网际层</td>        <td><b>IP</b>, ICMP, ARP, RARP, RIP, IPX</td>    </tr>    <tr><td>数据链路层（Data Link）</td><td rowspan="2">网络接口层</td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>    </tr>    <tr><td>物理层（Physical）</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>    </tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络主要有3种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO/OSI参考模型 7层&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型 5层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP/IP参考模型 4层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;是一种理论下的&lt;strong&gt;模型&lt;/strong&gt;，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://blog.sukiu.top/Database/Redis/"/>
    <id>http://blog.sukiu.top/Database/Redis/</id>
    <published>2021-12-07T01:22:55.000Z</published>
    <updated>2021-12-22T07:46:58.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis (Remote Dictionary Server ) 远程字典服务</strong>，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。</p><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。</p><p>和Memcached类似，它支持存储的value类型相对更多，包括：</p><ul><li>string（字符串）</li><li>list（链表）</li><li>set（集合）</li><li>zset（sorted set 有序集合）</li><li>hash（哈希类型）</li></ul><p>与 memcached 一样，为了保证效率，数据都是缓存在<strong>内存</strong>中。<br>区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://www.w3cschool.cn/redis/">Redis 教程_w3cschool</a><br><a href="https://juejin.cn/post/6909672227734552583">Redis使用教程 - 掘金</a></p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高 </li></ul><blockquote><p>Redis能读的速度是110000次/s,写的速度是81000次/s 。</p></blockquote><ul><li>丰富的数据类型</li></ul><blockquote><p>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p></blockquote><ul><li>原子</li></ul><blockquote><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p></blockquote><ul><li>丰富的特性</li></ul><blockquote><p>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h4 id="Redis-与其他-key-value-存储的区别"><a href="#Redis-与其他-key-value-存储的区别" class="headerlink" title="Redis 与其他 key-value 存储的区别"></a>Redis 与其他 key-value 存储的区别</h4><ul><li>Redis 运行在内存中但是可以 <strong>持久化到磁盘</strong>，重启的时候可以再次加载进行使用。</li><li>Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。</li><li>Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。</li></ul><h4 id="Redis-和-MongoDB-的区别"><a href="#Redis-和-MongoDB-的区别" class="headerlink" title="Redis 和 MongoDB 的区别"></a>Redis 和 MongoDB 的区别</h4><p>更多可见：<a href="https://zhuanlan.zhihu.com/p/86777551">NoSQL，浅谈redis与mongoDB的区别 - 知乎</a></p><ul><li><strong>性能方面</strong>，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB；</li><li><strong>可操作性上</strong>，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 <strong>丰富的查询语言</strong>，操作比 Redis 更为便利；</li><li><strong>内存及存储方面</strong>，MongoDB 适合 <strong>大数据量存储</strong>，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 <strong>虚拟内存特性</strong>，突破物理内存限制，数据可以设置时效性；</li><li><strong>对于数据持久化和数据恢复</strong>，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能；</li><li><strong>在数据一致性上</strong>，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行；</li><li><strong>数据分析上</strong>，MongoDB 内置 <strong>数据分析功能（mapreduce）</strong>，而 Redis 不支持数据分析；</li><li><strong>应用场景不同</strong>，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Redis</code>支持五种数据类型：</p><ul><li><code>string（字符串）</code></li><li><code>hash（哈希）</code></li><li><code>list（列表）</code></li><li><code>set（集合）</code></li><li><code>zset(sorted set：有序集合)</code></li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>最基本的类型，一个<code>key</code>对应一个<code>value</code>。<br><code>string</code>类型是二进制安全的，即<code>redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</p><blockquote><p>一个键最大能存储512MB。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sukiu.top&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-strings.html">Redis 字符串(String)_w3cschool</a></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p><code>Redis hash</code> 是一个键值 <code>(key=&gt;value)</code> 对集合。<br><code>Redis hash</code> 是一个 <code>string</code> 类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象。</p><blockquote><p>每个 <code>hash</code> 可以存储 232 - 1键值对（40多亿）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">3) <span class="string">&quot;password&quot;</span></span><br><span class="line">4) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">5) <span class="string">&quot;points&quot;</span></span><br><span class="line">6) <span class="string">&quot;200&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;password&quot;</span></span><br><span class="line">3) <span class="string">&quot;points&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-hashes.html">Redis 哈希(Hash)_w3cschool</a></p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>Redis</code> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><blockquote><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange <span class="built_in">test</span> 0 10</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-lists.html">Redis 列表(List)_w3cschool</a></p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>Redis</code> 的 <code>Set</code>是 <code>string</code> 类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><blockquote><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd t1 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers t1</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sets.html">Redis 集合(Set)_w3cschool</a></p><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>和 <code>set</code> 不同的是每个元素都会关联一个 <code>double</code> 类型的分数。<code>redis</code> 正是通过分数来为集合中的成员进行从小到大的排序。</p><p><code>zset</code> 的成员是唯一的,但分数<code>(score)</code>却可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd t2 0 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore t2 0 1000</span><br><span class="line">1) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">2) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sorted-sets.html">Redis 有序集合(sorted set)_w3cschool</a></p><h2 id="2、高级"><a href="#2、高级" class="headerlink" title="2、高级"></a>2、高级</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><blockquote><p>更多：<br><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理 - SegmentFault 思否</a></p></blockquote><p>Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。<br>Redis支持两种方式的持久化：RDB快照和AOF。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。<br>它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。<br>到目前为止，仍是官方的默认支持方案。</p><p><strong>原理：</strong> Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><blockquote><p>整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。</p></blockquote><p><strong>优点</strong>:</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要不高</li></ol><p><strong>缺点</strong>：</p><ol><li>需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了</li><li>fork进程的时候，会占用一定的内容空间</li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File），它是Redis的完全持久化策略。</p><p><strong>原理：</strong> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。<br>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no-关闭，yes-开启，默认no</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;appendonTy.aof&quot;</span> <span class="comment">#持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always #每次修改都会sync,消耗性能 </span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒执行一次sync,可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快!</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>每一次修改都同步，文件的完整会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong>：</p><ol><li>相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><ul><li>前者称为主节点(master/leader)</li><li>后者称为从节点(slavel/follower)</li><li>数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</li></ul><blockquote><p>默认情况下，每台Redis服务器都是主节点<br>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</p></blockquote><p>主从复制的作用主要包括:</p><ul><li>数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><blockquote><p>更多：<br><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780">redis系列之——高可用（主从、哨兵、集群）</a></p></blockquote><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><p>原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。<br>redis 为了避免单点故障，也需要部署多台机器。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071701844.png" alt="主从"></p><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。<br>实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 <del>自动选取老大的模式</del></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071704740.png" alt="哨兵" style="zoom:50%;" /><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。<br>在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071707386.png" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Redis (Remote Dictionary Server ) 远程字典服务&lt;/strong&gt;，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。&lt;/p&gt;
&lt;p&gt;Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string（字符串）&lt;/li&gt;
&lt;li&gt;list（链表）&lt;/li&gt;
&lt;li&gt;set（集合）&lt;/li&gt;
&lt;li&gt;zset（sorted set 有序集合）&lt;/li&gt;
&lt;li&gt;hash（哈希类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 memcached 一样，为了保证效率，数据都是缓存在&lt;strong&gt;内存&lt;/strong&gt;中。&lt;br&gt;区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Redis" scheme="http://blog.sukiu.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://blog.sukiu.top/Language/SQL/"/>
    <id>http://blog.sukiu.top/Language/SQL/</id>
    <published>2021-12-02T12:58:04.000Z</published>
    <updated>2021-12-22T07:46:52.547Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 语句可分为以下几类：</p><ul><li>数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 <code>CREATE</code>，<code>DROP</code>，<code>ALTER</code></li><li>数据查询语言 DQL（Data Query Language）：即查询操作，以 <code>SELECT</code> 关键字为主</li><li>数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 <code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code></li><li>数据控制功能 DCL（Data Control Language）：即权限控制操作，如 <code>GRANT</code>，<code>REVOKE</code>，<code>COMMIT</code>，<code>ROLLBACK</code></li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxsgh2/">常用 SQL 语句 - LeetCode</a><br><a href="https://juejin.cn/post/6983974232656969742">SQL约束 - 掘金</a></p></blockquote><h2 id="1、键"><a href="#1、键" class="headerlink" title="1、键"></a>1、键</h2><ul><li><strong>超键</strong>：在关系中，能唯一标识元组的属性集称为关系模式的超键。</li></ul><blockquote><p>一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<br>超键包含候选键和主键。</p></blockquote><ul><li><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</li><li><strong>主键</strong>：数据库表中对储存数据对象予以 <strong>唯一和完整标识的数据列或属性的组合</strong>。</li></ul><blockquote><p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</p></blockquote><ul><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><blockquote><p>外键可以有重复的, 可以是空值。</p></blockquote><h2 id="2、约束"><a href="#2、约束" class="headerlink" title="2、约束"></a>2、约束</h2><p>约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p><ul><li><strong>非空约束（NOT NULL）</strong>：保证该字段值一定不为空；</li><li><strong>默认约束（DEFAULT）</strong>：保证字段有默认值；</li><li><strong>主键约束（PRIMARY KEY）</strong>：标志一列或者多列，并保证其值在表内的唯一性；</li><li><strong>外键约束（FOREIGN KEY）</strong>：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；</li><li><strong>唯一约束（UNIQUE）</strong>： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；</li><li><strong>检查约束（CHECK）</strong>：限制一列的可用值范围。</li></ul><h3 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h3><ol><li>创建表时，在字段描述处，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key, <span class="comment">-- 添加了主键约束</span></span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表时，在constraint约束区域，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">INT</span>,</span><br><span class="line">  lastname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  firstname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> pk_persons <span class="keyword">PRIMARY</span> KEY (lastname, firstname) <span class="comment">-- 添加主键约束, 多个字段, 我们称为联合主键。</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建表之后，通过修改表结构，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加联合主键约束</span></span><br><span class="line"><span class="comment">-- 其他约束类似</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">add</span> <span class="keyword">constraint</span> pk_persons <span class="keyword">primary</span> key (lastname, firstname); </span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除主键约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP PRIMARY KEY</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除非空约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons modify lastname <span class="type">varchar</span>(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP INDEX 名称</span></span><br><span class="line"><span class="comment">-- 有唯一约束名称, 使用约束名称删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index uni_persons_address; </span><br><span class="line"><span class="comment">-- 没有唯一约束名称, 使用字段名删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index address; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、SQL语句"><a href="#3、SQL语句" class="headerlink" title="3、SQL语句"></a>3、SQL语句</h2><p>参考w3cschool即可：</p><blockquote><p><a href="https://www.w3cschool.cn/sql/sql-sentence.html">详尽的SQL语句大全分类整理_w3cschool</a></p></blockquote><p>下面列出一些重点：</p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。</p><ul><li><p><strong>交叉连接（CROSS JOIN）</strong></p><p>  除了在 <code>FROM</code> 子句中使用 <strong>逗号间隔连接的表</strong> 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 <strong>笛卡尔积</strong>，返回到的数据行数等于第一个表中符合查询条件的数据行数 <strong>乘以</strong> 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 <code>CROSS JOIN</code> 关键字而不是逗号，即以下两个表达式等价：</p><p>  <code>SELECT  *  FROM  A, B</code><br>  <code>SELECT  *  FROM  A  CROSS JOIN  B</code></p></li><li><p><strong>内连接（INNER JOIN）</strong></p><p>  内连接分为三类，分别是 <strong>等值连接</strong>：<code>ON A.id = B.id</code>、<strong>不等值连接</strong>：<code>ON A.id &gt; B.id</code> 和 <strong>自连接</strong>：<code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid</code></p></li><li><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><p>  <strong>左外连接</strong>：以左表为主，先查询出左表，按照 <code>ON</code> 后的关联条件匹配右表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>LEFT JOIN</code></p><p>  <strong>右外连接</strong>：以右表为主，先查询出右表，按照 <code>ON</code> 后的关联条件匹配左表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>RIGHT JOIN</code></p></li><li><p><strong>联合查询（UNION 与 UNION ALL）</strong></p><p>  <code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></p><p>  联合查询就是把多个结果集集中在一起，<code>UNION</code> 前的结果为基准，需要注意的是联合查询的 <strong>列数要相等</strong>，相同的记录行会合并；</p><p>  如果使用 <code>UNION ALL</code>，不会合并重复的记录行，所以效率更高。</p></li><li><p><strong>全连接（FULL JOIN）</strong></p><p>  MySQL 本身不支持全连接，但可以通过联合使用 <code>LEFT JOIN</code>、<code>UNION</code> 和 <code>RIGHT JOIN</code> 来实现。</p><p>  <code>SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id</code></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。</p><p>子查询是一个 <code>SELECT</code> 语句，它嵌套在另一个 <code>SELECT</code>、<code>SELECT…INTO</code> 语句、<code>INSERT…INTO</code> 语句、<code>DELETE</code> 语句、 <code>UPDATE</code> 语句或嵌套在另一子查询中。</p><p>MySQL 的子查询是多表查询的一个重要组成部分，常常和 <strong>连接查询</strong> 一起使用，是多表查询的基础。</p><p>子查询分为以下四类：</p><ul><li><p><strong>标量子查询</strong></p><p>  查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。</p></li><li><p><strong>列子查询</strong></p><p>  子查询返回的结果集是 N 行一列，该结果通常来自对表的 <strong>某个字段</strong> 查询返回。</p></li><li><p><strong>行子查询</strong></p><p>  子查询返回的结果集是一行 N 列，该结果通常是对表的 <strong>某行数据</strong> 进行查询而返回的结果集</p></li><li><p><strong>表子查询</strong></p><p>  子查询返回的结果集是 N 行 N 列的一个表数据。</p></li></ul><h3 id="char-与-varchar-的区别"><a href="#char-与-varchar-的区别" class="headerlink" title="char 与 varchar 的区别"></a>char 与 varchar 的区别</h3><ul><li>char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；</li><li>使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；</li></ul><h3 id="DROP、DELETE-与-TRUNCATE-的区别"><a href="#DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="DROP、DELETE 与 TRUNCATE 的区别"></a>DROP、DELETE 与 TRUNCATE 的区别</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">DROP</th><th style="text-align:center">DELETE</th><th style="text-align:center">TRUNCATE</th></tr></thead><tbody><tr><td style="text-align:center">SQL 语句类型</td><td style="text-align:center">DDL</td><td style="text-align:center">DML</td><td style="text-align:center">DDL</td></tr><tr><td style="text-align:center">回滚</td><td style="text-align:center">不可回滚</td><td style="text-align:center">可回滚</td><td style="text-align:center">不可回滚</td></tr><tr><td style="text-align:center">删除内容</td><td style="text-align:center">从数据库中 <strong>删除表</strong>，所有的数据行，索引和权限也会被删除</td><td style="text-align:center">表结构还在，删除表的 <strong>全部或者一部分数据行</strong></td><td style="text-align:center">表结构还在，删除表中的 <strong>所有数据</strong></td></tr><tr><td style="text-align:center">删除速度</td><td style="text-align:center">删除速度最快</td><td style="text-align:center">删除速度慢，需要逐行删除</td><td style="text-align:center">删除速度快</td></tr></tbody></table><blockquote><p>在不再需要一张表的时候，采用 <code>DROP</code><br>在想删除部分数据行时候，用 <code>DELETE</code><br>在保留表而删除所有数据的时候用 <code>TRUNCATE</code></p></blockquote><h3 id="UNION-与-UNION-ALL-的区别"><a href="#UNION-与-UNION-ALL-的区别" class="headerlink" title="UNION 与 UNION ALL 的区别"></a>UNION 与 UNION ALL 的区别</h3><ul><li><code>UNION</code> 用于把来自多个 <code>SELECT</code> 语句的结果组合到一个结果集合中，MySQL 会把结果集中 <strong>重复的记录删掉</strong></li><li><code>UNION ALL</code>，MySQL 会把所有的记录返回，且效率高于 <code>UNION</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL 语句可分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 &lt;code&gt;CREATE&lt;/code&gt;，&lt;code&gt;DROP&lt;/code&gt;，&lt;code&gt;ALTER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据查询语言 DQL（Data Query Language）：即查询操作，以 &lt;code&gt;SELECT&lt;/code&gt; 关键字为主&lt;/li&gt;
&lt;li&gt;数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 &lt;code&gt;INSERT&lt;/code&gt;，&lt;code&gt;UPDATE&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据控制功能 DCL（Data Control Language）：即权限控制操作，如 &lt;code&gt;GRANT&lt;/code&gt;，&lt;code&gt;REVOKE&lt;/code&gt;，&lt;code&gt;COMMIT&lt;/code&gt;，&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
    <category term="SQL" scheme="http://blog.sukiu.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>B Tree</title>
    <link href="http://blog.sukiu.top/Data-structure/B-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/B-Tree/</id>
    <published>2021-11-29T11:07:44.000Z</published>
    <updated>2021-12-22T07:46:47.125Z</updated>
    
    <content type="html"><![CDATA[<p>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。</p><ul><li>特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；</li><li>把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。</li></ul><span id="more"></span><blockquote><p>转载：</p><p><a href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p></blockquote><h2 id="1、B-树-B-tree"><a href="#1、B-树-B-tree" class="headerlink" title="1、B 树(B-tree)"></a>1、B 树(B-tree)</h2><blockquote><p>注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树;</p></blockquote><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构</p><p><strong>规则：</strong></p><ul><li>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉）</li><li>（3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2)</li><li>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子</li></ul><p><strong>例子：</strong></p><p>来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_b.jpg"/></p><h3 id="2、B-树的查询"><a href="#2、B-树的查询" class="headerlink" title="2、B 树的查询"></a>2、B 树的查询</h3><p>如上图我要从上图中找到 E 字母，查找流程如下</p><ul><li>（1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>（2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点；</li><li>（3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；</li></ul><h3 id="3、B-树的插入"><a href="#3、B-树的插入" class="headerlink" title="3、B 树的插入"></a>3、B 树的插入</h3><p>定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来;</p><ul><li>（1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）；</li><li>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li></ul><ol><li>先插入 3、8、31、11 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-e1d65c9c6236d4768c89e8e103e12583_b.jpg"/></li><li>再插入 23、29 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-66cdb6187cbc5227fd8c4aabe7282e6c_b.jpg"/></li><li>再插入 50、28 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-3057eaab2b1764dd51c2a8658791cc98_b.jpg"/></li></ol><h3 id="3、B-树的删除"><a href="#3、B-树的删除" class="headerlink" title="3、B 树的删除"></a>3、B 树的删除</h3><ul><li>（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li><li>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</li><li>（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-a0f981fc847772cb28869927cd4fe66d_b.jpg"/><h2 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a>2、B+树</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p>B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询<u>速度</u>更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别</p><ul><li>（1）B+跟B树不同B+树的<b>非叶子</b>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<b>非叶子</b>节点所能保存的关键字大大增加；</li><li>（2）B+树<b>叶子</b>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）;</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-5f069fd820637db1b877fdd6799a2b67_b.jpg"/><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_b.jpg"/><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>1、B+<b>树的层级更少</b>：相较于 B 树 B+每个<b>非叶子</b>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<b>树查询速度更稳定</b>：B+所有关键字数据地址都存在<b>叶子</b>节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定;</p><p>3、B+<b>树天然具备排序功能：</b>B+树所有的<b>叶子</b>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。</p><p>4、B+<b>树全节点遍历更快：</b>B+树遍历整棵树只需要遍历所有的<b>叶子</b>节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 <b>B 树</b>相对于<b>B+树</b>的优点是，如果经常访问的数据离根节点很近，而<b>B 树</b>的<b>非叶子</b>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<b>B+树</b>快。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="1、相同思想和策略"><a href="#1、相同思想和策略" class="headerlink" title="1、相同思想和策略"></a>1、相同思想和策略</h3><p>从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><h3 id="2、不同的方式的磁盘空间利用"><a href="#2、不同的方式的磁盘空间利用" class="headerlink" title="2、不同的方式的磁盘空间利用"></a>2、不同的方式的磁盘空间利用</h3><p>不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；&lt;/li&gt;
&lt;li&gt;把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://blog.sukiu.top/Database/Database-Introduction/"/>
    <id>http://blog.sukiu.top/Database/Database-Introduction/</id>
    <published>2021-11-27T01:58:35.000Z</published>
    <updated>2021-12-22T07:46:40.622Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库（Database）</strong> 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 <strong>数据库管理系统（DataBase- Management System，DBMS）</strong> 创建和操纵的容器。</p><p><strong>DBMS</strong> 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxhvpv/">数据库知识手册</a></p></blockquote><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>数据库有两种类型，分别是 <strong>关系型数据库</strong> 和 <strong>非关系型数据库</strong>。</p><table><thead><tr><th>数据库类型</th><th>定义</th><th>优点</th><th>缺点</th><th>常见</th></tr></thead><tbody><tr><td>关系型数据库</td><td>建立在关系模型基础上，由多张能互相连接的 <strong>表</strong> 组成的数据库</td><td>    <ol>    <li>使用表结构，格式一致，易于维护；    <li>使用 SQL 语句，可用于复杂查询；    <li>数据存储在磁盘中，安全性高    </ol></td><td>    <ol>    <li>读写性能比较差；    <li>建立在关系模型上，不可避免空间浪费；    <li>固定的表结构，灵活度较低    </ol></td><td>MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等</td></tr><tr><td>非关系型数据库</td><td>非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 <strong>对象</strong> 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</td><td>    <ol>    <li>存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛；    <li>可轻松进行海量数据的维护和处理；    <li>具有可扩展、高并发、高稳定性、成本低的优势；    <li>可以实现数据的分布式处理    </ol></td><td>    <ol>        <li>不提供 SQL 支持；    <li>无事务处理，无法保证数据的完整性和安全性；    <li>功能没有关系型数据库完善    </ol></td><td>Neo4j，Redis，MongoDB 等</td></tr></tbody></table><blockquote><p><strong>SQL</strong> 是 <strong>结构化查询语言（Structured Query Language）</strong> 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。</p><p><strong>MySQL</strong> 是一个 <strong>关系数据库管理系统（RDBMS）</strong>，使用 SQL 执行所有数据库操作。</p></blockquote><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB</li><li>完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB</li><li>传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。</p><p>常用的数据库三大范式为：</p><ul><li><strong>第一范式（1NF）</strong>：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。<strong>关系模式的基本要求</strong></li><li><strong>第二范式（2NF）</strong>：在第一范式的基础上，一个表必须有一个主键，非主键列 <strong>完全依赖</strong> 于主键，而不能是依赖于主键的一部分。<strong>消除部分依赖</strong></li><li><strong>第三范式（3NF）</strong>：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。<strong>消除传递依赖</strong></li></ul><h2 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h2><p>索引是一种 <strong>数据结构</strong>。数据库索引是 DBMS 中一个 <strong>排序的数据结构</strong>，以 <strong>协助快速查询、更新</strong> 数据库表中数据。</p><p>索引的实现通常使用 <a href="https://blog.sukiu.top/Data-structure/B-Tree/">B 树以及变种 B+ 树</a>。</p><p>以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。</p><table><tr><td>优点</td><td>缺点</td></tr><tr><td><ul>    <li>通过创建 <strong>唯一性索引 </strong>，可以保证数据库表中每一行数据的唯一性；    <li> 可以加快数据的  <strong>检索速度 </strong>，这也是创建索引的主要原因；    <li>可以加速表和表之间的连接，特别是在实现  <strong>数据的参考完整性 </strong> 方面特别有意义；    <li>通过使用索引，可以在查询的过程中，使用  <strong>优化隐藏器 </strong>，提高系统性能。</ul></td><td><ul>    <li>时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；    <li>空间上，索引需要占  <strong>物理空间 </strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</ul></td></tr></table><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>数据库索引根据结构分类，主要有 <strong>B 树索引</strong>（使用最频繁）、<strong>Hash 索引</strong> 和 <strong>位图索引</strong> 三种。</p><blockquote><p>关于 B 树可以参考：<a href="https://blog.sukiu.top/Data-structure/B-Tree/">B Tree</a></p></blockquote><p><strong>使用 B+ 树的优点：</strong></p><ul><li>由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。</li><li>B+ 树的叶结点由一条链相连，因此当需要进行一次 <strong>全数据遍历</strong> 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 <strong>大于某个关键字或者小于某个关键字的数据</strong> 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。</li></ul><p><strong>Hash 索引和 B+ 树索引的区别：</strong></p><ul><li>Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；</li><li>Hash 索引不支持使用索引进行排序；</li><li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；</li><li>Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；</li><li>Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。</li></ul><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引指将 <strong>数据存储</strong> 和 <strong>索引</strong> 放到一起，找到索引也就找到了数据。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/1628676447-LHnlSz-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="聚簇索引" style="zoom: 50%;" /><h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>数据库的 <strong>事务</strong>（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p><blockquote><p>如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。</p></blockquote><p>因此，事务是保持 <strong>逻辑数据一致性</strong> 和 <strong>可恢复性</strong> 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>事务具有 4 个特性，通常简称为 ACID，<strong>关系型数据库</strong> 需要遵循 ACID 规则。</p><ul><li><p>原子性（Atomicity）</p><p>  事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</p><blockquote><p>以银行转账事务为例：</p><p>如果该事务提交了，则这两个账户的数据将会更新；</p><p>如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 <strong>撤销</strong> 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。</p></blockquote></li><li><p>一致性（Consistency）</p><p>  当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。</p><blockquote><p>以银行转账事务事务为例：</p><p>在事务开始之前，所有 <strong>账户余额的总额处于一致状态</strong>。</p><p>在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。</p><p>因此，所有账户余额的总额处于不一致状态。</p><p>但是当事务完成以后，账户余额的总额再次恢复到一致状态。</p></blockquote></li><li><p>隔离性（Isolation）</p><p>  <strong>并发访问数据库</strong> 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</p><blockquote><p>修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。</p></blockquote></li><li><p>持久性（Durability）</p><p>  一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>DBMS 采用 <strong>日志</strong> 来保证事务的 <strong>原子性</strong>、<strong>一致性</strong> 和 <strong>持久性</strong>。</p><blockquote><p>日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></blockquote><p>DBMS 采用 <strong>锁机制</strong> 来实现事务的隔离性。</p><blockquote><p>当多个事务同时更新数据库中相同的数据时，只允许 <strong>持有锁的事务</strong> 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></blockquote><p><strong>相应的原理</strong></p><ul><li>原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li><li>一致性：一般由代码层面来保证</li><li>隔离性：由MVCC来保证</li><li>持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul><li><p>脏读（Dirty Read）</p><p>  一个事务读取了另一个事务未提交的数据。</p></li><li><p>不可重复读（Non-repeatable Read）</p><p>  就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。</p></li><li><p>幻读（Phantom Read）</p><p>  幻读是指当事务 <strong>不是独立执行时</strong> 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 <strong>插入一行新数据</strong>。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p></li><li><p>丢失更新（Lost Update）</p><p>  两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 <strong>并发事务对同一资源的读取深度层次</strong>。</p><p>由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE）</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交(RU)</td><td>只能保证不读取物理上的损坏</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交(RC)</td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读(RR)</td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化(SR)</td><td>最高级别，事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>从数据库系统的角度，锁模式可分为以下6 种类型：</p><ul><li><p><strong>共享锁（S）</strong>：又叫 <strong>他读锁</strong>。</p><p>  可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。</p></li><li><p><strong>排它锁（X）</strong>：又叫 <strong>独占锁</strong>、<strong>写锁</strong>。</p><p>  对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。</p></li><li><p><strong>更新锁（U）</strong>：</p><p>  防止出现 <strong>死锁</strong> 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。</p><p>  资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。</p></li><li><p><strong>意向锁</strong>：</p><p>  表示 SQL Server 需要在 <strong>层次结构中的某些底层资源上</strong> 获取共享锁或排它锁。</p><p>  例如，放置在 <strong>表级</strong> 的 <strong>共享意向锁</strong> 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。</p><p>  意向锁可以提高性能，因为 SQL Server 仅在 <strong>表级</strong> 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。</p><p>  意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。</p></li><li><p><strong>架构锁</strong>：</p><p>  在执行 <strong>依赖于表架构的操作</strong> 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。</p></li><li><p><strong>大容量更新锁（BU）</strong>：</p><p>  向表中大容量复制数据并指定了 <code>TABLOCK</code> 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>在 <strong>读取未提交</strong> 隔离级别下，读取数据不需要加 <strong>共享锁</strong>，这样就不会跟被修改的数据上的 <strong>排他锁</strong> 冲突；</li><li>在 <strong>读取已提交</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在语句执行完以后释放共享锁；</li><li>在 <strong>可重复读</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</li><li><strong>可串行化</strong> 是限制性最强的隔离级别，因为该级别 <strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><ul><li>如果不同程序并发存取多个表，尽量约定 <strong>以相同的顺序访问表</strong>，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到 <strong>一次锁定所需要的所有资源</strong>，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用 <strong>升级锁定颗粒度</strong>，通过 <strong>表级锁</strong> 定来减少死锁产生的概率。</li></ul><h3 id="乐-悲观锁"><a href="#乐-悲观锁" class="headerlink" title="乐/悲观锁"></a>乐/悲观锁</h3><p>DBMS 中的 <strong>并发控制</strong> 的任务是确保在 <strong>多个事务同时存取数据库中同一数据</strong> 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 <strong>读多写少</strong> 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库（Database）&lt;/strong&gt; 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 &lt;strong&gt;数据库管理系统（DataBase- Management System，DBMS）&lt;/strong&gt; 创建和操纵的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DBMS&lt;/strong&gt; 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
  </entry>
  
</feed>
