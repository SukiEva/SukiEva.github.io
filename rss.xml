<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakurasou</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2021-11-12T11:12:40.932Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主流开源协议</title>
    <link href="http://blog.sukiu.top/Mixed/%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.sukiu.top/Mixed/%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-12T10:49:27.000Z</published>
    <updated>2021-11-12T11:12:40.932Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：</p><ul><li>宽松自由软件许可协议 <em>Permissive free software licence</em></li><li>著佐权许可证 <em>copyleft license</em></li></ul><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/19568896">主流开源协议之间有何异同？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p></blockquote><h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><ul><li><p>Permissive free software licence ：</p><p>一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。</p></li><li><p>Copyleft License ：</p><p>在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。</p></li></ul><p>两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。</p><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><h2 id="2、常见开源许可证"><a href="#2、常见开源许可证" class="headerlink" title="2、常见开源许可证"></a>2、常见开源许可证</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free_software_licenses.png" alt="常见许可证" style="zoom:50%;" /><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p><em>Berkeley Software Distribution license</em></p><p>BSD 许可证与 MIT 差不多。</p><p>事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。</p><p>可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。</p><p>Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。</p><p>Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。</p><p>由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/7149baf878e23293b9bd57df076b6e41_r.jpg" alt="简明对比"></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>更宽松的GPL协议。</p><p>与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。</p><p>调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宽松自由软件许可协议 &lt;em&gt;Permissive free software licence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;著佐权许可证 &lt;em&gt;copyleft license&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="License" scheme="http://blog.sukiu.top/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree 二叉搜索树</title>
    <link href="http://blog.sukiu.top/Data-structure/Binary%20Search%20Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/Binary%20Search%20Tree/</id>
    <published>2021-11-12T02:42:46.000Z</published>
    <updated>2021-11-12T03:21:01.515Z</updated>
    
    <content type="html"><![CDATA[<p>简称 BST，也称二叉排序树或二叉查找树。</p><p>特点：</p><ul><li>任一结点 &gt; 其左子树的所有结点，<br>并且&lt; 其右子树的所有结点；</li><li>结点的左、右子树，也是二叉排序树；</li><li>每个结点键值唯一（不能重复）</li></ul><p>重要性质：</p><ul><li><strong>中序遍历二叉排序树得到递增序列</strong></li></ul><p>所以判断 1 棵二叉树是否是二叉排序树？<br>只要中序遍历，得到递增序列才是。</p><span id="more"></span><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li>若当前树为空，则新结点为根</li><li>若当前树不空，<br>将待插入 x 与根比较；<ul><li>若 x 等于根，不用插入</li><li>若 x 大于根，则去右子树(找位置)；</li><li>若 x 小于根，则去左子树(找位置)；</li></ul></li></ul><p>可以总结为：</p><p>插入之前，先查找：</p><ul><li>若找到，不用插入</li><li>若找不到，则在到达的空位置处，放入 x；</li></ul><p>所以最新插入的结点，一定是叶子；</p><img src="https://img-blog.csdnimg.cn/20200512170217478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" width="50%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>从根结点开始，如果树为空，则返回 NULL</p></li><li><p>如果非空，从根结点开始，比较待检索的键值</p><ul><li><p>若相等，则成功；</p></li><li><p>若小于根，<br>则去根的左子树；</p></li><li><p>若大于根，<br>则去根的右子树，</p></li></ul></li></ul><figure class="highlight go"><figcaption><span>迭代</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>考虑三种情况：</p><ul><li>① 要删除叶子结点<br>直接删除，并将父结点指针置为 NULL</li></ul><img src="https://img-blog.csdnimg.cn/20200512170832794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="40%"><ul><li>② 删除只有 1 个孩子的结点<br>将父结点指针指向要删除结点的孩子结点</li></ul><img src="https://img-blog.csdnimg.cn/20200512170956215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><ul><li>③ 删除有左右子树的结点<br>用另一个结点替代删除的结点：<ul><li>右子树的最小元素 或者 左子树的最大元素</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200512171205732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">        root.Left = deleteNode(root.Left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">        root.Right = deleteNode(root.Right, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 1 : 以下两个 if 已经处理</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 左</span></span><br><span class="line">        <span class="keyword">return</span> root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 右</span></span><br><span class="line">        <span class="keyword">return</span> root.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 3 ： 使用右子树最小元素</span></span><br><span class="line">    minNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> minNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        minNode = minNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    root.Val = minNode.Val</span><br><span class="line">    root.Right = deleteNode(root.Right, minNode.Val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平均检索长度-ASL"><a href="#平均检索长度-ASL" class="headerlink" title="平均检索长度 ASL"></a>平均检索长度 ASL</h2><p>比较次数：不大于树的深度</p><p>最坏平均查找长度 ASL：(n+1)/2</p><p>最好 ASL：$log2(n)$ (参考二分查找)</p><p><strong>所有操作的复杂度都是 $O(logn)$</strong></p><img src="https://img-blog.csdnimg.cn/2020051217150614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" >]]></content>
    
    
    <summary type="html">&lt;p&gt;简称 BST，也称二叉排序树或二叉查找树。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任一结点 &amp;gt; 其左子树的所有结点，&lt;br&gt;并且&amp;lt; 其右子树的所有结点；&lt;/li&gt;
&lt;li&gt;结点的左、右子树，也是二叉排序树；&lt;/li&gt;
&lt;li&gt;每个结点键值唯一（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中序遍历二叉排序树得到递增序列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以判断 1 棵二叉树是否是二叉排序树？&lt;br&gt;只要中序遍历，得到递增序列才是。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——系统管理</title>
    <link href="http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-07T14:50:41.000Z</published>
    <updated>2021-11-07T15:05:41.590Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中常用的系统工作命令以及系统状态检测命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、常用系统工作命令"><a href="#1、常用系统工作命令" class="headerlink" title="1、常用系统工作命令"></a>1、常用系统工作命令</h2><h3 id="echo-：在终端输出字符串或变量提取后的值"><a href="#echo-：在终端输出字符串或变量提取后的值" class="headerlink" title="echo ：在终端输出字符串或变量提取后的值"></a>echo ：在终端输出字符串或变量提取后的值</h3><p>命令描述：echo命令用于在终端输出字符串或变量提取后的值。</p><p>命令格式：<code>echo [字符串 | $变量]</code></p><p>命令用法示例：</p><p><strong>显示普通字符串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p><strong>显示变量</strong><br>首先在shell环境中定义一个临时变量name，<br>使用echo命令将变量name的值显示到终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> name=<span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure><p><strong>显示结果定向至文件</strong><br>以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test text.&quot;</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。</p><p><strong>显示命令执行结果</strong><br>以下命令将会在终端显示当前的工作路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure><p>注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。<br>使用<code>$(command)</code>形式可以达到相同效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h3 id="date-：显示和设置系统的时间和日期"><a href="#date-：显示和设置系统的时间和日期" class="headerlink" title="date ：显示和设置系统的时间和日期"></a>date ：显示和设置系统的时间和日期</h3><p>命令描述：date命令用于显示和设置系统的时间和日期。</p><p>命令格式：<code>date [选项] [+格式]</code></p><p>其中，时间格式的部分控制字符解释如下：</p><table class=""><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.25da70089Mos0m">字符</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.25da70089Mos0m">%a</td><td>当地时间的星期名缩写（例如： 日，代表星期日）</td></tr><tr><td>%A</td><td>当地时间的星期名全称 （例如：星期日）</td></tr><tr><td>%b</td><td>当地时间的月名缩写 （例如：一，代表一月）</td></tr><tr><td>%B</td><td>当地时间的月名全称 （例如：一月）</td></tr><tr><td>%c</td><td>当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）</td></tr><tr><td>%C</td><td>世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）</td></tr><tr><td>%d</td><td>按月计的日期（例如：01）</td></tr><tr><td>%D</td><td>按月计的日期；等于%m/%d/%y</td></tr><tr><td>%F</td><td>完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td>%j</td><td>按年计的日期（001-366）</td></tr><tr><td>%p</td><td>按年计的日期（001-366）</td></tr><tr><td>%r</td><td>当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）</td></tr><tr><td>%R</td><td>24 小时时间的时和分，等价于 %H:%M</td></tr><tr><td>%s</td><td>自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</td></tr><tr><td>%T</td><td>时间，等于%H:%M:%S</td></tr><tr><td>%U</td><td>一年中的第几周，以周日为每星期第一天（00-53）</td></tr><tr><td>%x</td><td>当地时间下的日期描述 （例如：12/31/99）</td></tr><tr><td>%X</td><td>当地时间下的时间描述 （例如：23:13:48）</td></tr><tr><td>%w</td><td>一星期中的第几日（0-6），0 代表周一</td></tr><tr><td>%W</td><td>一年中的第几周，以周一为每星期第一天（00-53）</td></tr></tbody></table><p>命令用法示例：</p><p><strong>按照默认格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p><strong>按照指定格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>查看今天是当年中的第几天</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%j&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>将系统的当前时间设置为2020年02月20日20点20分20秒</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="string">&quot;20200220 20:20:20&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>校正系统时间，与网络时间同步</strong><br>​    a. 安装ntp校时工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure><p>  b. 用ntpdate从时间服务器更新时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><h3 id="wget-：在终端中下载文件"><a href="#wget-：在终端中下载文件" class="headerlink" title="wget ：在终端中下载文件"></a>wget ：在终端中下载文件</h3><p>命令描述：在终端中下载文件。</p><p>命令格式：<code>wget [参数] 下载地址</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i24.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大重试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><p>命令使用示例：</p><p><strong>下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png</span><br></pre></td></tr></table></figure><h3 id="ps-：查看系统中的进程状态"><a href="#ps-：查看系统中的进程状态" class="headerlink" title="ps ：查看系统中的进程状态"></a>ps ：查看系统中的进程状态</h3><p>命令描述：ps命令用于查看系统中的进程状态。</p><p>命令格式：<code>ps [参数]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i27.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i26.25da70089Mos0m">-u</td><td>以用户为主的格式来显示程序状况</td></tr><tr><td>-x</td><td>显示没有控制终端的进程，同时显示各个命令的具体路径</td></tr><tr><td>-e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示当前所有的进程</td></tr><tr><td>-t</td><td>指定终端机编号，并列出属于该终端机的程序的状况</td></tr></tbody></table><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure><h3 id="top-：动态地监视进程活动与系统负载等信息"><a href="#top-：动态地监视进程活动与系统负载等信息" class="headerlink" title="top ：动态地监视进程活动与系统负载等信息"></a>top ：动态地监视进程活动与系统负载等信息</h3><p>命令描述：top命令动态地监视进程活动与系统负载等信息。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/top.png" alt="top"><br>命令输出参数解释：</p><p>以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。</p><ul><li><p>统计信息区</p><ul><li>第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li><li>第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li><li>第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li><li>第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</li><li>第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。</li></ul></li><li><p>进程信息区</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i35.25da70089Mos0m">列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程ID</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>PR</td><td>进程优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb</td></tr><tr><td>SHR</td><td data-spm-anchor-id="a2c6h.13858378.0.i34.25da70089Mos0m">共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态<ul><li>D：不可中断的睡眠状态</li><li>R：正在运行</li><li>S：睡眠</li><li>T：停止</li><li>Z：僵尸进程</li></ul></td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>命令名</td></tr></tbody></table> 按 q 键退出监控页面。</li></ul><h3 id="pidof-：查询指定服务进程的PID值"><a href="#pidof-：查询指定服务进程的PID值" class="headerlink" title="pidof ：查询指定服务进程的PID值"></a>pidof ：查询指定服务进程的PID值</h3><p>命令描述：pidof命令用于查询指定服务进程的PID值。</p><p>命令格式：<code>pidof [服务名称]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>仅返回一个进程号</td></tr><tr><td>-c</td><td>只显示运行在root目录下的进程，这个选项只对root用户有效</td></tr><tr><td>-o</td><td>忽略指定进程号的进程</td></tr><tr><td>-x</td><td>显示由脚本开启的进程</td></tr></tbody></table><p>命令使用示例：</p><p><strong>查询出crond服务下的所有进程ID。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof crond</span><br></pre></td></tr></table></figure><h3 id="kill-：终止指定PID的服务进程"><a href="#kill-：终止指定PID的服务进程" class="headerlink" title="kill ：终止指定PID的服务进程"></a>kill ：终止指定PID的服务进程</h3><p>命令描述：kill命令用于终止指定PID的服务进程。</p><p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。</p><p>命令格式：<code>kill [参数] [进程PID]</code></p><p>命令使用示例：</p><p><strong>删除pid为1247的进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 1247</span><br></pre></td></tr></table></figure><h3 id="killall-：终止指定名称的服务对应的全部进程"><a href="#killall-：终止指定名称的服务对应的全部进程" class="headerlink" title="killall ：终止指定名称的服务对应的全部进程"></a>killall ：终止指定名称的服务对应的全部进程</h3><p>命令描述：killall命令用于终止指定名称的服务对应的全部进程。</p><p>命令格式：<code>killall [进程名称]</code></p><p>命令使用示例：</p><p><strong>删除crond服务下的所有进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall crond</span><br></pre></td></tr></table></figure><h3 id="reboot-：重启系统"><a href="#reboot-：重启系统" class="headerlink" title="reboot ：重启系统"></a>reboot ：重启系统</h3><p>命令描述：reboot命令用来重启系统。</p><p>命令格式：<code>reboot [-n] [-w] [-d] [-f] [-i]</code></p><p>命令参数说明：</p><ul><li>-n：保存数据后再重新启动系统。</li><li>-w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。</li><li>-d：重新启动时不把数据写入记录文件/var/tmp/wtmp。</li><li>-f：强制重新开机，不调用shutdown指令的功能。</li><li>-i：关闭网络设置之后再重新启动系统。</li></ul><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="poweroff-：关闭系统"><a href="#poweroff-：关闭系统" class="headerlink" title="poweroff ：关闭系统"></a>poweroff ：关闭系统</h3><p>命令描述：poweroff命令用来关闭系统。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><h2 id="2、系统状态检测命令"><a href="#2、系统状态检测命令" class="headerlink" title="2、系统状态检测命令"></a>2、系统状态检测命令</h2><h3 id="ifconfig-：获取网卡配置与网络状态等信息"><a href="#ifconfig-：获取网卡配置与网络状态等信息" class="headerlink" title="ifconfig ：获取网卡配置与网络状态等信息"></a>ifconfig ：获取网卡配置与网络状态等信息</h3><p>命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。</p><p>命令示例：</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/ifconfig.png" alt="ifconfig"><br>命令输出说明：</p><ul><li>第一部分的第一行显示网卡状态信息。<ul><li>eth0表示第一块网卡。</li><li>UP代表网卡开启状态。</li><li>RUNNING代表网卡的网线被接上。</li><li>MULTICAST表示支持组播。</li></ul></li><li>第二行显示网卡的网络信息。<ul><li>inet（IP地址）：172.16.132.195。</li><li>broadcast（广播地址）：172.16.143.255。</li><li>netmask（掩码地址）：255.255.240.0。</li><li>RX表示接收数据包的情况，TX表示发送数据包的情况。</li><li>lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。</li></ul></li></ul><h3 id="uname-：查看系统内核与系统版本等信息"><a href="#uname-：查看系统内核与系统版本等信息" class="headerlink" title="uname ：查看系统内核与系统版本等信息"></a>uname ：查看系统内核与系统版本等信息</h3><p>命令描述：uname命令用于查看系统内核与系统版本等信息。</p><p>命令语法：<code>uname [-amnrsv][--help][--version]</code></p><p>命令使用示例：</p><p><strong>显示系统信息。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>显示当前系统的硬件架构。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -i</span><br></pre></td></tr></table></figure><p><strong>显示操作系统发行编号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><strong>显示操作系统名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -s</span><br></pre></td></tr></table></figure><p><strong>显示主机名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -n</span><br></pre></td></tr></table></figure><h3 id="uptime-：查看系统的负载信息"><a href="#uptime-：查看系统的负载信息" class="headerlink" title="uptime ：查看系统的负载信息"></a>uptime ：查看系统的负载信息</h3><p>命令描述：uptime 用于查看系统的负载信息。</p><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/uptime.png" alt="uptime"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i55.25da70089Mos0m">负载信息</th><th data-spm-anchor-id="a2c6h.13858378.0.i54.25da70089Mos0m">命令输出值</th></tr></thead><tbody><tr><td>当前服务器时间</td><td>14:20:27</td></tr><tr><td>当前服务器运行时长</td><td>2 min</td></tr><tr><td>当前用户数</td><td>2 users</td></tr><tr><td>当前负载情况</td><td><code>load average: 0.03, 0.04, 0.02</code>（分别取1min，5min，15min的均值）</td></tr></tbody></table><h3 id="free-：显示当前系统中内存的使用量信息"><a href="#free-：显示当前系统中内存的使用量信息" class="headerlink" title="free ：显示当前系统中内存的使用量信息"></a>free ：显示当前系统中内存的使用量信息</h3><p>命令描述：free用于显示当前系统中内存的使用量信息。</p><p>命令语法：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i59.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以Byte为单位显示内存使用情况</td></tr><tr><td>-k</td><td>以KB为单位显示内存使用情况</td></tr><tr><td>-m</td><td>以MB为单位显示内存使用情况</td></tr><tr><td>-h</td><td>以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</td></tr></tbody></table><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free.png" alt="free"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i64.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i63.25da70089Mos0m">total</td><td>物理内存总数</td></tr><tr><td>used</td><td>已经使用的内存数</td></tr><tr><td>free</td><td>空间的内存数</td></tr><tr><td>share</td><td>多个进程共享的内存总额</td></tr><tr><td>buff/cache</td><td>应用使用内存数</td></tr><tr><td>available</td><td>可用的内存数</td></tr><tr><td>Swap</td><td>虚拟内存（阿里云ECS服务器默认不开启虚拟内存）</td></tr></tbody></table><h3 id="who-：显示关于当前在本地系统上的所有用户的信息"><a href="#who-：显示关于当前在本地系统上的所有用户的信息" class="headerlink" title="who ：显示关于当前在本地系统上的所有用户的信息"></a>who ：显示关于当前在本地系统上的所有用户的信息</h3><p>命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。</p><p>命令使用示例：</p><p><strong>显示当前登录系统的用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure><p><strong>显示用户登录来源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -l -H</span><br></pre></td></tr></table></figure><p><strong>只显示当前用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -m -H</span><br></pre></td></tr></table></figure><p><strong>精简模式显示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -q</span><br></pre></td></tr></table></figure><h3 id="last-：显示用户最近登录信息"><a href="#last-：显示用户最近登录信息" class="headerlink" title="last ：显示用户最近登录信息"></a>last ：显示用户最近登录信息</h3><p>命令描述： last 命令用于显示用户最近登录信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><h3 id="history-：显示历史执行过的命令"><a href="#history-：显示历史执行过的命令" class="headerlink" title="history ：显示历史执行过的命令"></a>history ：显示历史执行过的命令</h3><p>命令描述：history命令用于显示历史执行过的命令。</p><p>bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。</p><p>命令使用示例：</p><p><strong>显示最新10条执行过的命令。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> 10</span><br></pre></td></tr></table></figure><p><strong>清除历史记录。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux中常用的系统工作命令以及系统状态检测命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文本处理</title>
    <link href="http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    <id>http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</id>
    <published>2021-11-07T14:38:28.000Z</published>
    <updated>2021-11-07T14:49:02.390Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文本编辑工具Vim"><a href="#1、文本编辑工具Vim" class="headerlink" title="1、文本编辑工具Vim"></a>1、文本编辑工具Vim</h2><p>vim的三种操作模式：</p><ul><li>命令模式（Command mode）</li><li>输入模式（Insert mode）</li><li>底线命令模式（Last line mode）。</li></ul><p>三种模式切换快捷键：</p><table><thead><tr><th>模式</th><th>快捷键</th></tr></thead><tbody><tr><td>命令模式</td><td>ESC</td></tr><tr><td>输入模式</td><td>i或a</td></tr><tr><td>底线命令模式</td><td><strong>:</strong></td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。</p><p>使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p><p>以下是在命令模式中常用的快捷操作：</p><table class="" style="width: 100%;" data-spm-anchor-id="a2c6h.13858378.0.i12.31941d111Dv71Z"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i11.31941d111Dv71Z">操作</th><th>快捷键</th></tr></thead><tbody><tr><td>光标左移</td><td>h</td></tr><tr><td>光标右移</td><td>l（小写L）</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i13.31941d111Dv71Z">光标上移</td><td>k</td></tr><tr><td>光标下移</td><td>j</td></tr><tr><td>光标移动到下一个单词</td><td>w</td></tr><tr><td>光标移动到上一个单词</td><td>b</td></tr><tr><td>移动游标到第n行</td><td>nG</td></tr><tr><td>移动游标到第一行</td><td>gg</td></tr><tr><td>移动游标到最后一行</td><td>G</td></tr><tr><td>快速回到上一次光标所在位置</td><td>Ctrl+o</td></tr><tr><td>删除当前字符</td><td>x</td></tr><tr><td>删除前一个字符</td><td>X</td></tr><tr><td>删除整行</td><td>dd</td></tr><tr><td>删除一个单词</td><td>dw或daw</td></tr><tr><td>删除至行尾</td><td>d$或D</td></tr><tr><td>删除至行首</td><td>d^</td></tr><tr><td>删除到文档末尾</td><td>dG</td></tr><tr><td>删除至文档首部</td><td>d1G</td></tr><tr><td>删除n行</td><td>ndd</td></tr><tr><td>删除n个连续字符</td><td>nx</td></tr><tr><td>将光标所在位置字母变成大写或小写</td><td>~</td></tr><tr><td>复制游标所在的整行</td><td>yy（3yy表示复制3行）</td></tr><tr><td>粘贴至光标后（下）</td><td>p</td></tr><tr><td>粘贴至光标前（上）</td><td>P</td></tr><tr><td>剪切</td><td>dd</td></tr><tr><td>交换上下行</td><td>ddp</td></tr><tr><td>替换整行，即删除游标所在行并进入插入模式</td><td>cc</td></tr><tr><td>撤销一次或n次操作</td><td>u{n}</td></tr><tr><td>撤销当前行的所有修改</td><td>U</td></tr><tr><td>恢复撤销操作</td><td>Ctrl+r</td></tr><tr><td>整行将向右缩进</td><td>&gt;&gt;</td></tr><tr><td>整行将向左退回</td><td>&lt;&lt;</td></tr><tr><td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td><td>ZZ</td></tr></tbody></table><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p><p>以下是底线命令模式中常用的快捷操作：</p><table class="" style="width: 100%;"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.31941d111Dv71Z">操作</th><th>命令</th></tr></thead><tbody><tr><td>保存</td><td>:w</td></tr><tr><td>退出</td><td>:q</td></tr><tr><td>保存并退出</td><td>:wq（<code>:wq!</code>表示强制保存退出）</td></tr><tr><td>将文件另存为其他文件名</td><td>:w new_filename</td></tr><tr><td>显示行号</td><td>:set nu</td></tr><tr><td>取消行号</td><td>:set nonu</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.31941d111Dv71Z">使本行内容居中</td><td>:ce</td></tr><tr><td>使本行文本靠右</td><td>:ri</td></tr><tr><td>使本行内容靠左</td><td>:le</td></tr><tr><td>向光标之下寻找一个名称为word的字符串</td><td>:/word</td></tr><tr><td>向光标之上寻找一个字符串名称为word的字符串</td><td>:?word</td></tr><tr><td>重复前一个搜寻的动作</td><td>:n</td></tr><tr><td>从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td><td><code>:1,$s/word1/word2/g</code> 或 <code><span>&nbsp;</span>:%s/word1/word2/g</code></td></tr></tbody></table><h2 id="2、文本文件查看命令"><a href="#2、文本文件查看命令" class="headerlink" title="2、文本文件查看命令"></a>2、文本文件查看命令</h2><h3 id="cat-：查看内容较少的纯文本文件"><a href="#cat-：查看内容较少的纯文本文件" class="headerlink" title="cat ：查看内容较少的纯文本文件"></a>cat ：查看内容较少的纯文本文件</h3><p>命令描述：cat命令用于查看内容较少的纯文本文件。</p><p>命令格式：<code>cat [选项] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i26.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n或--number</td><td>显示行号</td></tr><tr><td>-b或--number-nonblank</td><td>显示行号，但是不对空白行进行编号</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i25.31941d111Dv71Z">-s或--squeeze-blank</td><td>当遇到有连续两行以上的空白行，只显示一行的空白行</td></tr></tbody></table><h3 id="more-：从前向后分页显示文件内容"><a href="#more-：从前向后分页显示文件内容" class="headerlink" title="more ：从前向后分页显示文件内容"></a>more ：从前向后分页显示文件内容</h3><p>命令描述：more命令从前向后分页显示文件内容。</p><p>常用操作命令：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i31.31941d111Dv71Z">操作</th><th>作用</th></tr></thead><tbody><tr><td>Enter</td><td>向下n行，n需要定义，默认为1行</td></tr><tr><td>Ctrl+F或空格键（Space）</td><td>向下滚动一页</td></tr><tr><td>Ctrl+B</td><td>向上滚动一页</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>!命令</td><td>调用Shell执行命令</td></tr><tr><td>q</td><td>退出more</td></tr></tbody></table><h3 id="less-：对文件或其它输出进行分页显示"><a href="#less-：对文件或其它输出进行分页显示" class="headerlink" title="less ：对文件或其它输出进行分页显示"></a>less ：对文件或其它输出进行分页显示</h3><p>命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。</p><p>命令格式：<code>less [参数] 文件</code> </p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i33.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e</td><td>当文件显示结束后，自动离开</td></tr><tr><td>-m</td><td data-spm-anchor-id="a2c6h.13858378.0.i32.31941d111Dv71Z">显示类似more命令的百分比</td></tr><tr><td>-N</td><td>显示每行的行号</td></tr><tr><td>-s</td><td>显示连续空行为一行</td></tr></tbody></table><p>命令常用操作：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i34.31941d111Dv71Z">/字符串</td><td>向下搜索字符串</td></tr><tr><td>?字符串</td><td>向上搜索字符串</td></tr><tr><td>n</td><td>重复前一个搜索</td></tr><tr><td>N</td><td>反向重复前一个搜索</td></tr><tr><td>b或<code>pageup</code>键</td><td>向上翻一页</td></tr><tr><td>空格键或<code>pagedown</code>键</td><td>向下翻一页</td></tr><tr><td>u</td><td>向前翻半页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>y</td><td>向前滚动一行</td></tr><tr><td>回车键</td><td>向后滚动一行</td></tr><tr><td>q</td><td>退出less命令</td></tr></tbody></table><p>命令使用示例：</p><p>查看命令历史使用记录并通过less分页显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure><h3 id="head-：查看文件开头指定行数的内容"><a href="#head-：查看文件开头指定行数的内容" class="headerlink" title="head ：查看文件开头指定行数的内容"></a>head ：查看文件开头指定行数的内容</h3><p>命令描述：head命令用于查看文件开头指定行数的内容。</p><p>命令格式：<code>head [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n [行数]</td><td>显示开头指定行的文件内容，默认为10</td></tr><tr><td>-c [字符数]</td><td>显示开头指定个数的字符数</td></tr><tr><td>-q</td><td>不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名</td></tr></tbody></table><p>命令使用示例：</p><p>查看/etc/passwd文件的前5行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -5 /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="tail-：查看文档的后N行或持续刷新内容"><a href="#tail-：查看文档的后N行或持续刷新内容" class="headerlink" title="tail ：查看文档的后N行或持续刷新内容"></a>tail ：查看文档的后N行或持续刷新内容</h3><p>命令描述：tail命令用于查看文档的后N行或持续刷新内容。</p><p>命令格式：<code>tail [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i41.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>显示文件最新追加的内容</td></tr><tr><td>-q</td><td>当有多个文件参数时，不输出各个文件名</td></tr><tr><td>-v</td><td>当有多个文件参数时，总是输出各个文件名</td></tr><tr><td>-c [字节数]</td><td>显示文件的尾部n个字节内容</td></tr><tr><td>-n [行数]</td><td>显示文件的尾部n行内容</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f -n 10 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="stat-：显示文件的详细信息"><a href="#stat-：显示文件的详细信息" class="headerlink" title="stat ：显示文件的详细信息"></a>stat ：显示文件的详细信息</h3><p>命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。</p><p>命令使用示例：</p><p>查看/etc/passwd文件的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="wc-：统计指定文本的行数、字数、字节数"><a href="#wc-：统计指定文本的行数、字数、字节数" class="headerlink" title="wc ：统计指定文本的行数、字数、字节数"></a>wc ：统计指定文本的行数、字数、字节数</h3><p>命令描述：wc命令用于统计指定文本的行数、字数、字节数。</p><p>命令格式：<code>wc [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i46.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><p>命令使用示例：</p><p>统计/etc/passwd文件的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="file-：辨识文件类型"><a href="#file-：辨识文件类型" class="headerlink" title="file ：辨识文件类型"></a>file ：辨识文件类型</h3><p>命令描述： file命令用于辨识文件类型。</p><p>命令格式：<code>file [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i48.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i47.31941d111Dv71Z">-b</td><td>列出辨识结果时，不显示文件名称</td></tr><tr><td>-c</td><td>详细显示指令执行过程，便于排错或分析程序执行的情形</td></tr><tr><td>-f [文件]</td><td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</td></tr><tr><td>-L</td><td>直接显示符号连接所指向的文件类别</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages文件的文件类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="diff-：比较文件的差异"><a href="#diff-：比较文件的差异" class="headerlink" title="diff ：比较文件的差异"></a>diff ：比较文件的差异</h3><p>命令描述：diff命令用于比较文件的差异。</p><p>命令格式：<code>diff [文件] [文件]</code></p><h2 id="3、文本处理命令"><a href="#3、文本处理命令" class="headerlink" title="3、文本处理命令"></a>3、文本处理命令</h2><h3 id="grep-：查找文件里符合条件的字符串"><a href="#grep-：查找文件里符合条件的字符串" class="headerlink" title="grep ：查找文件里符合条件的字符串"></a>grep ：查找文件里符合条件的字符串</h3><p>命令描述：grep命令用于查找文件里符合条件的字符串。</p><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>在Shell脚本中，grep通过返回一个状态值来表示搜索的状态：</p><ul><li>0：匹配成功。</li><li>1：匹配失败。</li><li>2：搜索的文件不存在。</li></ul><p>命令格式：<code>grep [参数] [正则表达式] [文件]</code></p><p>命令常用参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i54.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c或--count</td><td>计算符合样式的列数</td></tr><tr><td>-d recurse或-r</td><td>指定要查找的是目录而非文件</td></tr><tr><td>-e [范本样式]</td><td>指定字符串做为查找文件内容的样式</td></tr><tr><td>-E 或 --extended-regexp</td><td>将样式为延伸的正则表达式来使用</td></tr><tr><td>-F 或 --fixed-regexp</td><td>将样式视为固定字符串的列表</td></tr><tr><td>-G 或 --basic-regexp</td><td>将样式视为普通的表示法来使用</td></tr><tr><td>-i 或 --ignore-case</td><td>忽略字符大小写的差别</td></tr><tr><td>-n 或 --line-number</td><td>在显示符合样式的那一行之前，标示出该行的列数编号</td></tr><tr><td>-v 或 --revert-match</td><td>显示不包含匹配文本的所有行</td></tr></tbody></table><p>命令使用示例：</p><p>查看sshd服务配置文件中监听端口配置所在行编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n Port /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure><p>查询字符串在文本中出现的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c localhost /etc/hosts</span><br></pre></td></tr></table></figure><p>反向查找，不显示符合条件的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br><span class="line">ps -ef | grep -v grep | grep sshd</span><br></pre></td></tr></table></figure><p>以递归的方式查找目录下含有关键字的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r *.sh /etc</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;ntp[0-9].aliyun.com&#x27;</span> /etc/ntp.conf</span><br></pre></td></tr></table></figure><h3 id="sed-：文本处理"><a href="#sed-：文本处理" class="headerlink" title="sed ：文本处理"></a>sed ：文本处理</h3><p>命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。</p><ol><li>处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。</li><li>接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</li><li>接着处理下一行，这样不断重复，直到文件末尾。</li></ol><p>注意：</p><p>sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。<br>如果要改变源文件，需要使用-i选项。<br>命令格式：<code>sed [参数] [动作] [文件]</code> </p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i63.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e [script]</td><td>执行多个script</td></tr><tr><td>-f [script文件]</td><td>执行指定script文件</td></tr><tr><td>-n</td><td>仅显示script处理后的结果</td></tr><tr><td>-i</td><td>输出到原文件，静默执行（修改原文件）</td></tr></tbody></table><p>动作说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i65.31941d111Dv71Z">动作</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在行后面增加内容</td></tr><tr><td>c</td><td>替换行</td></tr><tr><td>d</td><td>删除行</td></tr><tr><td>i</td><td>在行前面插入</td></tr><tr><td>p</td><td>打印相关的行</td></tr><tr><td>s</td><td>替换内容</td></tr></tbody></table><p>命令使用示例：</p><p>删除第3行到最后一行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在最后一行新增行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;$a admin:x:1000:1000:admin:/home/admin:/bin/bash&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>替换内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/SELINUX=disabled/SELINUX=enforcing/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>替换行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;1c abcdefg&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="awk-：文本处理"><a href="#awk-：文本处理" class="headerlink" title="awk ：文本处理"></a>awk ：文本处理</h3><p>命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><p>命令格式：<code>awk [参数] [脚本] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i72.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-F fs</td><td>指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i71.31941d111Dv71Z">-f file</td><td>读取awk脚本</td></tr><tr><td>-v val=val</td><td>在执行处理过程之前，设置一个变量var，并给其设置初始值为val</td></tr></tbody></table><p>内置变量：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i74.31941d111Dv71Z">变量</th><th>用途</th></tr></thead><tbody><tr><td>FS</td><td>字段分隔符</td></tr><tr><td>$n</td><td>指定分隔的第n个字段，如$1、$3分别表示第1、第三列</td></tr><tr><td>$0</td><td>当前读入的整行文本内容</td></tr><tr><td>NF</td><td>记录当前处理行的字段个数（列数）</td></tr><tr><td>NR</td><td>记录当前已读入的行数</td></tr><tr><td>FNR</td><td>当前行在源文件中的行号</td></tr></tbody></table><p>awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。</p><p>和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。</p><p>命令使用示例：</p><p>查看本机IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 |awk <span class="string">&#x27;/inet/&#123;print $2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看本机剩余磁盘容量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h |awk <span class="string">&#x27;/\/$/&#123;print $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>统计系统用户个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$3&lt;1000&#123;x++&#125; END&#123;print x&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$7!~/nologin$/&#123;print $1,$7&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出/etc/passwd文件中前三行记录的用户名和用户uid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -3 /etc/passwd | awk  <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;;print &quot;name\tuid&quot;&#125;&#123;print $1,&quot;\t&quot;$3&#125;END&#123;print &quot;sum lines &quot;NR&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看tcp连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>关闭指定服务的所有的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | awk &#123;<span class="string">&#x27;print $2&#x27;</span>&#125; | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h3 id="cut-：切割字符串"><a href="#cut-：切割字符串" class="headerlink" title="cut ：切割字符串"></a>cut ：切割字符串</h3><p>命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。</p><p>命令格式：<code>cut [参数] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i81.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以字节为单位进行分割</td></tr><tr><td>-c</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><h3 id="tr-：对来自标准输入的字符进行替换、压缩和删除"><a href="#tr-：对来自标准输入的字符进行替换、压缩和删除" class="headerlink" title="tr ：对来自标准输入的字符进行替换、压缩和删除"></a>tr ：对来自标准输入的字符进行替换、压缩和删除</h3><p>命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。</p><p>命令格式：<code>tr [参数] [文本]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i84.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>反选指定字符</td></tr><tr><td>-d</td><td>删除指定字符</td></tr><tr><td>-s</td><td>将重复的字符缩减成一个字符</td></tr><tr><td>-t [第一字符集] [第二字符集]</td><td>删除第一字符集较第二字符集多出的字符，使两个字符集长度相等</td></tr></tbody></table><p>命令使用示例：</p><p>将输入字符由大写转换为小写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;HELLO WORLD&quot;</span> | tr <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p>删除字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello 123 world 456&quot;</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p>压缩字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;thissss is      a text linnnnnnne.&quot;</span> | tr -s <span class="string">&#x27; sn&#x27;</span></span><br></pre></td></tr></table></figure><p>产生随机密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文件与权限</title>
    <link href="http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>http://blog.sukiu.top/Linux/Linux%E6%8C%87%E4%BB%A4%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/</id>
    <published>2021-11-07T08:47:19.000Z</published>
    <updated>2021-11-07T14:37:58.162Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中常用的文件目录管理和文件权限管理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文件目录管理命令"><a href="#1、文件目录管理命令" class="headerlink" title="1、文件目录管理命令"></a>1、文件目录管理命令</h2><h3 id="tree-：以树状图列出目录的内容"><a href="#tree-：以树状图列出目录的内容" class="headerlink" title="tree ：以树状图列出目录的内容"></a>tree ：以树状图列出目录的内容</h3><p>命令描述：tree命令用于以树状图列出目录的内容。</p><p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /usr/share/wallpapers/</span><br></pre></td></tr></table></figure><h3 id="ls-：显示指定工作目录下的内容"><a href="#ls-：显示指定工作目录下的内容" class="headerlink" title="ls ：显示指定工作目录下的内容"></a>ls ：显示指定工作目录下的内容</h3><p>注意是 L 的小写，不是大写 I</p><p>命令描述： ls命令用于显示指定工作目录下的内容。</p><p>命令格式：ls [参数] [目录名]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件及目录（包括隐藏文件）</td></tr><tr><td>-l</td><td>将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l）</td></tr><tr><td>-r</td><td>将文件反序列出（默认按英文字母正序）</td></tr><tr><td>-t</td><td>将文件按创建时间正序列出</td></tr><tr><td>-R</td><td>递归遍历目录下文件</td></tr></tbody></table><h3 id="pwd-：获取当前工作目录的绝对路径"><a href="#pwd-：获取当前工作目录的绝对路径" class="headerlink" title="pwd ：获取当前工作目录的绝对路径"></a>pwd ：获取当前工作目录的绝对路径</h3><p>命令描述：获取当前工作目录的绝对路径。</p><p>命令使用：<code>pwd</code></p><h3 id="cd-：切换工作目录"><a href="#cd-：切换工作目录" class="headerlink" title="cd ：切换工作目录"></a>cd ：切换工作目录</h3><p>命令描述：cd命令用于切换工作目录。</p><p>在路径表示中：</p><ul><li>一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。</li><li>两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。</li></ul><p>cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。</p><h3 id="touch-：修改文件或者目录的时间属性"><a href="#touch-：修改文件或者目录的时间属性" class="headerlink" title="touch ：修改文件或者目录的时间属性"></a>touch ：修改文件或者目录的时间属性</h3><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>命令格式：touch [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>如果指定文件不存在，不会建立新文件</td></tr><tr><td>-r</td><td>使用参考文件的时间记录</td></tr><tr><td>-t</td><td>设置文件的时间记录</td></tr></tbody></table><h3 id="mkdir-：新建子目录"><a href="#mkdir-：新建子目录" class="headerlink" title="mkdir ：新建子目录"></a>mkdir ：新建子目录</h3><p>命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p a/b/c</span><br></pre></td></tr></table></figure><h3 id="rm-：删除一个文件或者目录"><a href="#rm-：删除一个文件或者目录" class="headerlink" title="rm ：删除一个文件或者目录"></a>rm ：删除一个文件或者目录</h3><p>命令描述：rm命令用于删除一个文件或者目录。</p><p>命令格式：rm [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>删除前逐一询问确认</td></tr><tr><td>-f</td><td>无需确认，直接删除</td></tr><tr><td>-r</td><td>删除目录下所有文件</td></tr></tbody></table><h3 id="cp-：复制文件或目录"><a href="#cp-：复制文件或目录" class="headerlink" title="cp ：复制文件或目录"></a>cp ：复制文件或目录</h3><p>命令描述： cp命令主要用于复制文件或目录。</p><p>命令格式：cp [参数] [源文件] [目标文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>复制时保留链接</td></tr><tr><td>-f</td><td>覆盖已经存在的目标文件而不给出提示</td></tr><tr><td>-i</td><td>覆盖前询问</td></tr><tr><td>-p</td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td>-r</td><td>复制目录及目录内的所有项目</td></tr></tbody></table><h3 id="mv-：为文件或目录改名-将文件或目录移入其它位置"><a href="#mv-：为文件或目录改名-将文件或目录移入其它位置" class="headerlink" title="mv ：为文件或目录改名 / 将文件或目录移入其它位置"></a>mv ：为文件或目录改名 / 将文件或目录移入其它位置</h3><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>命令格式：mv [参数] [源文件] [目标文件]</p><p>参数说明：</p><p>参数    说明<br>-i    若指定目录已有同名文件，则先询问是否覆盖旧文件<br>-f    如果目标文件已经存在，不会询问而直接覆盖</p><h3 id="rename-：批量改变文件名"><a href="#rename-：批量改变文件名" class="headerlink" title="rename ：批量改变文件名"></a>rename ：批量改变文件名</h3><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p><p>命令格式：rename [原值] [替换值]</p><h2 id="2、文件权限管理"><a href="#2、文件权限管理" class="headerlink" title="2、文件权限管理"></a>2、文件权限管理</h2><p>ls命令可以查看Linux系统上的文件、目录和设备的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /boot/</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuYWxpY2RuLmNvbS90ZnMvVEIxMmdYY0hORDFnSzBqU1pGS1hYY0pyVlhhLTg2OS00MjAucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"><br>上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p><ul><li>第1位表示存档类型，d表示目录，-表示一般文件。</li><li>第2~4位表示当前用户的权限（属主权限）。</li><li>第5~7位表示同用户组的用户权限（属组权限）。</li><li>第8~10位表示不同用户组的用户权限（其他用户权限）。</li><li>第11位是一个半角句号.，表示SELinux安全标签。</li></ul><p>用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。</p><p>例如efi目录的root用户权限为drwxr-xr-x.。</p><ul><li>该目录对root用户具有读写和执行所有权限。</li><li>该目录对root组其他用户有读和执行权限。</li><li>该目录对其他用户有读和执行权限。</li></ul><p>所以该权限表示对应八进制权限表示为：</p><ul><li>属主权限：4+2+1=7。</li><li>属组权限：4+1=5。</li><li>其他用户权限：4+1=5。</li></ul><p>即755。</p><h3 id="chmod-：修改文件权限"><a href="#chmod-：修改文件权限" class="headerlink" title="chmod ：修改文件权限"></a>chmod ：修改文件权限</h3><p>chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。</p><p>将hello.sh文件增加属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件撤销属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件权限修改为八进制表示的744权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 hello.sh</span><br></pre></td></tr></table></figure><p><strong>u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。</strong></p><h3 id="chown-：修改文件的属主和属组"><a href="#chown-：修改文件的属主和属组" class="headerlink" title="chown ：修改文件的属主和属组"></a>chown ：修改文件的属主和属组</h3><p>chown命令修改文件的属主和属组</p><ul><li>-R参数以递归方式对子目录和文件进行修改</li><li> ls -l命令显示的第三列和第四列就是文件的属主和属组信息。</li></ul><p>修改test.txt文件的属主用户为test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="built_in">test</span> test.txt</span><br></pre></td></tr></table></figure><p>修改test.txt文件的属主和属组为admin。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown admin:admin test.txt</span><br></pre></td></tr></table></figure><h3 id="chgrp-：修改文件的属组"><a href="#chgrp-：修改文件的属组" class="headerlink" title="chgrp ：修改文件的属组"></a>chgrp ：修改文件的属组</h3><p>chgrp命令用于修改文件的属组。</p><p>命令使用示例：</p><p>将test.txt文件的属组改为root。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp root test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux系统中常用的文件目录管理和文件权限管理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://blog.sukiu.top/Algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <id>http://blog.sukiu.top/Algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</id>
    <published>2021-11-03T00:47:26.000Z</published>
    <updated>2021-11-06T13:07:37.130Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树遍历主要包括：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><span id="more"></span><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、递归遍历"><a href="#1、递归遍历" class="headerlink" title="1、递归遍历"></a>1、递归遍历</h2><p><strong>递归三要素：</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>即 根-左-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> preOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    preOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        preOrder(root.Left)</span><br><span class="line">        preOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>即 左-根-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.Left)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        inOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>即 左-右-根</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    postorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.Left)</span><br><span class="line">        postorder(root.Right)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、迭代遍历"><a href="#2、迭代遍历" class="headerlink" title="2、迭代遍历"></a>2、迭代遍历</h2><p><strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 通过这种标记法实现二叉树的统一迭代遍历。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif" alt="中序遍历"></p><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123; </span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; </span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、层序遍历"><a href="#3、层序遍历" class="headerlink" title="3、层序遍历"></a>3、层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := list.New()</span><br><span class="line">    queue.PushBack(root)</span><br><span class="line">    t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        l := queue.Len()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">            node := queue.Remove(queue.Front()).(*TreeNode)</span><br><span class="line">            t = <span class="built_in">append</span>(t, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        t = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树遍历主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先遍历&lt;ul&gt;
&lt;li&gt;前序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;中序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;后序遍历（递归法，迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广度优先遍历&lt;ul&gt;
&lt;li&gt;层次遍历（迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>常见容器底层</title>
    <link href="http://blog.sukiu.top/Data-structure/%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82/"/>
    <id>http://blog.sukiu.top/Data-structure/%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82/</id>
    <published>2021-11-02T01:10:23.000Z</published>
    <updated>2021-11-02T01:43:31.280Z</updated>
    
    <content type="html"><![CDATA[<p>各种语言下，常见容器底层整理。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/834cc223bb57">C++ STL容器底层数据结构总结 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/359878588">C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1、C"><a href="#1、C" class="headerlink" title="1、C++"></a>1、C++</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>其底层数据结构是<strong>数组</strong>，由于能动态扩容，所以也称<strong>动态数组</strong></p><p><strong>特点：</strong></p><ul><li><p>随机访问：$O(1)$</p></li><li><p>随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删</p></li><li><p>扩容规则：</p><ul><li>新建时初始化一片空间</li><li>插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据</li><li>释放原来空间</li></ul></li><li><p>在进行迭代器相关的修改操作时（包括扩容），<strong>所有迭代器和指针引用都会失效</strong></p></li></ul><h3 id="map-amp-multimap-amp-set-amp-multiset"><a href="#map-amp-multimap-amp-set-amp-multiset" class="headerlink" title="map &amp; multimap &amp; set &amp; multiset"></a>map &amp; multimap &amp; set &amp; multiset</h3><p>map提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。</p><p>与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。</p><p>底层数据结构均为<strong>红黑树</strong>，可以参考[教你透彻了解红黑树](<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com)</a>)。</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(logn)$</li></ul><h3 id="unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset"><a href="#unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset" class="headerlink" title="unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset"></a>unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset</h3><p>顾名思义，以上容器是无序的，所以底层实现为<strong>哈希表</strong>，因此其查找时间复杂度理论上达到了<strong>O(n)</strong></p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题</li></ul><h2 id="2、Go"><a href="#2、Go" class="headerlink" title="2、Go"></a>2、Go</h2><p>Go 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>底层数据结构是哈希表</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;各种语言下，常见容器底层整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Container" scheme="http://blog.sukiu.top/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>Priority Queue Go 优先队列</title>
    <link href="http://blog.sukiu.top/Data-structure/Priority%20Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Priority%20Queue/</id>
    <published>2021-11-01T14:13:03.000Z</published>
    <updated>2021-11-12T02:43:54.610Z</updated>
    
    <content type="html"><![CDATA[<p><em>论如何在 Go 语言中使用优先队列。</em></p><span id="more"></span><blockquote><p>参考：</p><p><a href="http://cngolib.com/container-heap.html">Go标准库中文文档 (cngolib.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Go 提供了 <a href="https://golang.org/pkg/container/heap/">container/heap</a> 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 <code>index = 0</code> 的值是最小的，即最小堆。</p><p>堆也是实现优先队列 Priority Queue 的常用方式。</p><p>堆中元素的类型需要实现 <code>heap.Interface</code> 这个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <a href="https://golang.org/pkg/sort/#Interface">sort.Interface</a> 包括 <code>Len()</code>, <code>Less</code>, <code>Swap</code> 方法。</p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap [][<span class="number">2</span>]<span class="keyword">int</span> <span class="comment">// 0 key 1 value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i][<span class="number">1</span>] &lt; h[j][<span class="number">1</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.([<span class="number">2</span>]<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 347. 前 K 个高频元素</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/top-k-frequent-elements/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        m[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">        heap.Push(h, [<span class="number">2</span>]<span class="keyword">int</span>&#123;key, value&#125;)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        k--</span><br><span class="line">        ans[k] = heap.Pop(h).([<span class="number">2</span>]<span class="keyword">int</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;论如何在 Go 语言中使用优先队列。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Monotone Queue 单调队列</title>
    <link href="http://blog.sukiu.top/Data-structure/Monotone%20Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Monotone%20Queue/</id>
    <published>2021-11-01T13:19:06.000Z</published>
    <updated>2021-11-12T02:43:44.014Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>“如果一个选手比你小还比你强，你就可以退役了。”</strong>——单调队列的原理</em></p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素<strong>可能</strong>成为某个区间最值时才保留它。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="单调队列如何维护队列里的元素"></p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><p>以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><blockquote><p>保证队列里单调递减或递增的原则，所以叫做单调队列。 </p></blockquote><p>以下不是固定写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MonotoneQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MonotoneQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MonotoneQueue&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Front</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.queue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Back</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.queue[<span class="built_in">len</span>(this.queue)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.queue) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> !this.Empty() &amp;&amp; x &gt; this.Back() &#123;</span><br><span class="line">        this.queue = this.queue[:<span class="built_in">len</span>(this.queue)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue = <span class="built_in">append</span>(this.queue, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Pop</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !this.Empty() &amp;&amp; this.Front() == x &#123;</span><br><span class="line">        this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;“如果一个选手比你小还比你强，你就可以退役了。”&lt;/strong&gt;——单调队列的原理&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://blog.sukiu.top/Data-structure/Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Queue/</id>
    <published>2021-10-28T07:00:39.000Z</published>
    <updated>2021-11-08T14:57:08.145Z</updated>
    
    <content type="html"><![CDATA[<p>与栈类似，队列是一种<strong>先进先出</strong>的容器适配器。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/queue-stack/k6zxm/">队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p></blockquote><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png" alt="先入先出的数据结构" style="zoom:50%;" /><p>在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。</p><p>如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/%E5%87%BA%E5%85%A5%E9%98%9F.gif" alt="入队与出队" style="zoom:50%;" /><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><p>为了实现队列，我们可以使用动态数组和指向队列头部的索引。</p><p><strong>简单的参考实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// store elements</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">        <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyQueue</span>() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。</p><p>所以应该规定数组的长度，一组一组队列的进行使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与栈类似，队列是一种&lt;strong&gt;先进先出&lt;/strong&gt;的容器适配器。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://blog.sukiu.top/Data-structure/Stack/"/>
    <id>http://blog.sukiu.top/Data-structure/Stack/</id>
    <published>2021-10-28T06:32:13.000Z</published>
    <updated>2021-11-08T14:57:24.714Z</updated>
    
    <content type="html"><![CDATA[<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。</p><p>STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/queue-stack/gxtls/">队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。</p><p>与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。</p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png" alt="后入先出的数据结构" style="zoom: 50%;" /><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/%E5%87%BA%E5%85%A5%E6%A0%88.gif" alt="入栈与出栈" style="zoom:50%;" /><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p><img src="https://img-blog.csdnimg.cn/20210104235459376.png" alt="栈与队列理论3" style="zoom:50%;" /><p><strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="keyword">int</span>, std::list&lt;<span class="keyword">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><p><strong>动态数组实现参考：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;               <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** Insert an element into the stack. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Get the top item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStack s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (s.<span class="built_in">pop</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。&lt;/p&gt;
&lt;p&gt;STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Stack" scheme="http://blog.sukiu.top/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://blog.sukiu.top/Algorithm/KMP/"/>
    <id>http://blog.sukiu.top/Algorithm/KMP/</id>
    <published>2021-10-19T11:56:00.000Z</published>
    <updated>2021-11-08T14:55:30.461Z</updated>
    
    <content type="html"><![CDATA[<p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>借用了<a href="https://www.cnblogs.com/dusf/p/kmp.html">这篇博客</a>的一些插图和理解</p><p>next数组就是一个前缀表（prefix table）：<strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>假设 匹配串 S， 模式串 T</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4MzkxMi00OTM2NWI3ZTY3Y2Q0ODc3YjJmNTAxMDc0ZGFlNjhkMi5wbmc?x-oss-process=image/format,png" alt="初始状态"></p><ul><li><strong>最长公共前后缀</strong> ：<br>ABCAB 公共前后缀 是 AB<br>ABABA 公共前后缀 是 ABA<br>ABCABC 公共前后缀 是 ABC</li></ul><p>如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4MzkyOS1hOWNjZmIwODgzM2U0Y2YxYTQyYzMwZjA1NjA4ZjhmNS5wbmc?x-oss-process=image/format,png" alt="不匹配"></p><p>又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2</p><p>将 j 移到 2 （i=5，j=2）</p><table><tr><th><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDAzMC04MmU0YjcxYjg1YTQ0MGM1YTYzNmQ1NzUwMzkzMTQxNS5wbmc?x-oss-process=image/format,png"></th><th><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDAzNy1jYzNjMzQyMDA4MDk0MTRlOTQyMWMzMTZjZWJhMmNkYS5wbmc?x-oss-process=image/format,png"></tr></table><p>所以，重点要求 next 数组：</p><p><strong>next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值</strong><br>（最长公共前后缀的长度）</p><p>考虑四种情况：</p><ul><li>① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDI1OC1lZmQyZTk1ZDM2NDQ0MjdlYmMwMzA0ZWQzZDdhZGVmYi5wbmc?x-oss-process=image/format,png" alt="j=0"></p><ul><li>② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDMxMC0yOWY5ZjhkYmI2MDM0MTUxYTM4M2U3Y2NmNmY1NTgzZS5wbmc?x-oss-process=image/format,png" alt="j=1"></li><li>③ X [ k ] = X [ j ]<br>匹配到这个位置说明失配位置前 公共前后缀相等，即<br>X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度）<br>那么，X [ 0…k ] = X [ j-k…j ]<br>所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDMyNy04YTNjZGZhYjAzMDk0YmZhOWU1Y2FjZTI2Nzk2Y2FlNS5wbmc?x-oss-process=image/format,png" alt="匹配"></li><li>④ X [ k ] != X [ j ]<br>next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀)<br>此时，<strong>将前缀移到后缀位置</strong>，即指针前移到最长公共前后缀的长度位置，可以得出：<br>k = next [ k ]<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzEyMjM1OC1mZDdlNTJkZDM4MmM0MjY4YThmZjUyYjg1YmZmNDY1ZC5wbmc?x-oss-process=image/format,png" alt="不匹配"></li></ul><p>不过，这样求得的 next 数组还有缺陷：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDcxMi1mMGQ2OTk4OTM4NzY0YjMwOWY2MTkyMzQ1MmEyYjIwZi5wbmc?x-oss-process=image/format,png" alt="缺陷"></p><p>按照前述，j 移到 最长公共前后缀长度 1 的位置：</p><p>这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 <strong>X[ j ] = X[ next[ j ] ] 的情况没有意义</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDcyNi03OTBmYzFiMmM0OGM0MTFiODAxMWVhYjlkZTY5MmY2ZC5wbmc?x-oss-process=image/format,png" alt="重复"></p><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md">代码随想录动图示例：</a></p><img src="https://camo.githubusercontent.com/49f9392ca7baccbfbaec6823dbad095a6a582a7d1a101b4f37e2fa3eb5003061/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f4b4d50254537254232254245254538254145254232332e676966"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(next []<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    next[<span class="number">0</span>] = j</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">for</span> j !=<span class="number">-1</span> &amp;&amp; s[i] != s[j] &#123; <span class="comment">// 前后缀不同，向前回退</span></span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(s) || j &gt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j] &#123; <span class="comment">// 优化去重</span></span><br><span class="line">            next[i] = next[j]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(needle))</span><br><span class="line">    getNext(next, needle)</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(haystack) &amp;&amp; j &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">for</span> j !=<span class="number">-1</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nx[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnx</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    j=nx[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">-1</span>!=j &amp;&amp; x[i]!=x[j]) j=nx[j];</span><br><span class="line">        <span class="keyword">if</span> (x[++i]==x[++j]) nx[i]=nx[j];</span><br><span class="line">        <span class="keyword">else</span> nx[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123; <span class="comment">//s为匹配串，t为模式串</span></span><br><span class="line">    <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getnx</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">-1</span>!=j &amp;&amp; s[i]!=t[j]) j=nx[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j==m)</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p>即<strong>最小的循环节</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(next []<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// 计算后缀，不需要去重</span></span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    next[<span class="number">0</span>] = j</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != s[j] &#123; <span class="comment">// 前后缀不同，向前回退</span></span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>) <span class="comment">// 多+1 计算末位最长前后缀</span></span><br><span class="line">    getNext(next, s)</span><br><span class="line">    l := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> next[l] != <span class="number">0</span> &amp;&amp; l%(l-next[l]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;KMP主要应用在字符串匹配上。&lt;/p&gt;
&lt;p&gt;KMP的主要思想是&lt;strong&gt;当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="String" scheme="http://blog.sukiu.top/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Language——Kotlin</title>
    <link href="http://blog.sukiu.top/Language/Language%E2%80%94Kotlin/"/>
    <id>http://blog.sukiu.top/Language/Language%E2%80%94Kotlin/</id>
    <published>2021-10-01T11:45:40.000Z</published>
    <updated>2021-10-02T09:51:19.013Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 </p><p>Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p><del>用了Kotlin就不想回到Java，本文主要记录一些高级用法</del></p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/kotlin/coroutines?hl=zh-cn">Android 上的 Kotlin 协程  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><p>更多细节可查看：<a href="https://www.kotlincn.net/docs/reference/basic-syntax.html">基本语法 - Kotlin 语言中文站 (kotlincn.net)</a></p><h2 id="1、基本知识"><a href="#1、基本知识" class="headerlink" title="1、基本知识"></a>1、基本知识</h2><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><ul><li>左闭右闭：<code>0..10</code></li><li>左闭右开：<code>0 unitil 10 (step 2)</code></li><li>降序（左闭右闭）：<code>10 downto 1</code></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Examle</span></span>(...)&#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h4><p>不常用，一般直接指定默认值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Examle</span></span>(...)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...) : <span class="keyword">this</span>(...)&#123;&#125;</span><br><span class="line">    sonstructor() : <span class="keyword">this</span> (...)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul><li><code>public</code>：（默认）对所有类可见</li><li><code>private</code>：对当前类内部可见</li><li><code>protected</code>：对当前类和子类可见</li><li><code>internal</code>：对同一模块的类可见</li></ul><h4 id="数据类和单例类"><a href="#数据类和单例类" class="headerlink" title="数据类和单例类"></a>数据类和单例类</h4><ul><li>数据类：<code>data class</code>，等同于 Java 中一长串的 bean</li><li>单例类：<code>object</code>，等同于 Java 中的单例模式（全局至多只有一个实例）</li></ul><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>简而言之，就是可以作为参数传递的代码。</p><p>太常用也太多了，写写就会了</p><h2 id="2、标准函数"><a href="#2、标准函数" class="headerlink" title="2、标准函数"></a>2、标准函数</h2><p>只介绍最常用的3个</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>一个非扩展函数：<strong>上下文对象</strong>作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（<code>this</code>）使用。 <strong>返回值</strong>是 lambda 表达式结果。</p><p>接收2个参数：</p><ul><li>任意类型的对象</li><li>Lambda表达式</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(obj)&#123;</span><br><span class="line">    <span class="comment">// obj 上下文</span></span><br><span class="line">    <span class="string">&quot;value&quot;</span> <span class="comment">// with 返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbers = mutableListOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)</span><br><span class="line">with(numbers) &#123;</span><br><span class="line">    println(<span class="string">&quot;&#x27;with&#x27; is called with argument <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;It contains <span class="variable">$size</span> elements&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><strong>上下文对象</strong> 作为接收者（<code>this</code>）来访问。 <strong>返回值</strong> 是 lambda 表达式结果。</p><p><code>run</code> 和 <code>with</code> 做同样的事情，但是调用方式和 <code>let</code> 一样——作为上下文对象的扩展函数.</p><p>当 lambda 表达式同时包含对象初始化和返回值的计算时，<code>run</code> 很有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = service.run &#123;</span><br><span class="line">    port = <span class="number">8080</span></span><br><span class="line">    query(prepareRequest() + <span class="string">&quot; to port <span class="variable">$port</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的代码如果用 let() 函数来写:</span></span><br><span class="line"><span class="keyword">val</span> letResult = service.let &#123;</span><br><span class="line">    it.port = <span class="number">8080</span></span><br><span class="line">    it.query(it.prepareRequest() + <span class="string">&quot; to port <span class="subst">$&#123;it.port&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><strong>上下文对象</strong> 作为接收者（<code>this</code>）来访问。 <strong>返回值</strong> 是上下文对象本身。</p><p>对于不返回值且主要在接收者（<code>this</code>）对象的成员上运行的代码块使用 <code>apply</code>。<code>apply</code> 的常见情况是对象配置。这样的调用可以理解为“将以下赋值操作应用于对象”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">&quot;Adam&quot;</span>).apply &#123;</span><br><span class="line">    age = <span class="number">32</span></span><br><span class="line">    city = <span class="string">&quot;London&quot;</span>        </span><br><span class="line">&#125;</span><br><span class="line">println(adam)</span><br></pre></td></tr></table></figure><h3 id="函数选择"><a href="#函数选择" class="headerlink" title="函数选择"></a>函数选择</h3><p>为了选择合适的作用域函数，它们之间的主要区别表。</p><table><thead><tr><th align="left">函数</th><th align="left">对象引用</th><th align="left">返回值</th><th align="left">是否是扩展函数</th></tr></thead><tbody><tr><td align="left"><code>let</code></td><td align="left"><code>it</code></td><td align="left">Lambda 表达式结果</td><td align="left">是</td></tr><tr><td align="left"><code>run</code></td><td align="left"><code>this</code></td><td align="left">Lambda 表达式结果</td><td align="left">是</td></tr><tr><td align="left"><code>run</code></td><td align="left">-</td><td align="left">Lambda 表达式结果</td><td align="left">不是：调用无需上下文对象</td></tr><tr><td align="left"><code>with</code></td><td align="left"><code>this</code></td><td align="left">Lambda 表达式结果</td><td align="left">不是：把上下文对象当做参数</td></tr><tr><td align="left"><code>apply</code></td><td align="left"><code>this</code></td><td align="left">上下文对象</td><td align="left">是</td></tr><tr><td align="left"><code>also</code></td><td align="left"><code>it</code></td><td align="left">上下文对象</td><td align="left">是</td></tr></tbody></table><h2 id="3、拓展函数和运算符重载"><a href="#3、拓展函数和运算符重载" class="headerlink" title="3、拓展函数和运算符重载"></a>3、拓展函数和运算符重载</h2><h3 id="拓展函数"><a href="#拓展函数" class="headerlink" title="拓展函数"></a>拓展函数</h3><p>基本格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(pararm: <span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Toast.makeToast(MyApp.context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money:<span class="type">Money</span>)</span></span>:Money&#123;</span><br><span class="line">        <span class="keyword">return</span> Money(value+money.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、高阶函数和内联函数"><a href="#4、高阶函数和内联函数" class="headerlink" title="4、高阶函数和内联函数"></a>4、高阶函数和内联函数</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>如果一个函数接收另一个函数作为参数，或者韩非子的类型是另一个函数，则称之为高阶函数。</p><p>基本规则：<code>() -&gt; Unit</code></p><p>例子如下，相当于能嵌套函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CardItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onClick: () -&gt; <span class="type">Unit</span> = &#123;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> </span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>高阶函数实现的 Lambda 表达式在底层被转换为匿名类，每次调用都会创建一个新的匿名类实例，造成额外开销</p><p>函数前添加<code>inline</code>可消除开销：<code>inline fun example()&#123;&#125;</code></p><h2 id="5、泛型和委托"><a href="#5、泛型和委托" class="headerlink" title="5、泛型和委托"></a>5、泛型和委托</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>一般编程模式下，需要给任何一个变量指定具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样的代码会有更好的拓展性。</p><p><strong>泛型类：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myClass = MyClass&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 指定 Int 泛型</span></span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>) <span class="comment">// 得到 Int 返回值</span></span><br></pre></td></tr></table></figure><p><strong>泛型方法：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">(param: <span class="type">T</span>)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myClass = MyClass()</span><br><span class="line"><span class="keyword">val</span> result = myClass.method&lt;<span class="built_in">Int</span>&gt;(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin 可以自动识别</span></span><br><span class="line"><span class="keyword">val</span> result = myClass.method(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p><strong>范围：</strong></p><p>可通过 <code>&lt;T : Number&gt;</code>的形式指定范围，此时只允许数字类型，字符串会报错</p><p>默认类型可空，即<code>Any?</code>，不想为空可改为<code>Any</code></p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托是一种设计模式，操作对象自己不会去处理某段逻辑，而是把工作委托给另外一个辅助对象处理。</p><p><strong>类委托：</strong></p><p>借助委托可以轻松自己实现类，以下通过<code>Hashset</code>自定义一个类：<code>by</code>是实现委托的关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; <span class="keyword">by</span> helperSet&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">helloworld</span><span class="params">()</span></span> = println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> isEmpty = <span class="literal">false</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性委托：</strong></p><p>将一个属性（字段）的具体实现委托给另一个类去完成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 p 时，自动调用 Delegate类的 getValue 方法，赋值时调用 setValue 方法</span></span><br><span class="line"><span class="comment">// 以下是标准的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> propValue: Any? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数1: 指定该类的委托在什么类可以使用</span></span><br><span class="line">    <span class="comment">// 参数2: Kotlin属性操作类，可用于获取各种属性相关的值</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">Kproperty</span>&lt;*&gt;)</span></span>: Any?&#123;</span><br><span class="line">        <span class="keyword">return</span> propValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(myClass: <span class="type">MyClass</span>, prop: <span class="type">Kproperty</span>&lt;*&gt;, value: <span class="type">Any</span>?)</span></span>: Any?&#123;</span><br><span class="line">        propValue = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型实化"><a href="#泛型实化" class="headerlink" title="泛型实化"></a>泛型实化</h3><p>指定泛型的实际类型</p><p><code>inline fun &lt;reified T&gt; start(block: Intent.() -&gt; Unit = &#123;&#125;)&#123;&#125;</code></p><p>此时就可以得到<code>T::class.java</code>类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><h3 id="泛型协变和逆变"><a href="#泛型协变和逆变" class="headerlink" title="泛型协变和逆变"></a>泛型协变和逆变</h3><blockquote><p>Todo</p></blockquote><h2 id="6、协程"><a href="#6、协程" class="headerlink" title="6、协程"></a>6、协程</h2><p>可以理解为轻量级的线程，可以在单线程中模拟多线程效果，与线程不同点在于：</p><ul><li>线程依靠操作系统调度实现不同线程切换</li><li>协程在编程语言层面实现不同协程切换，大大提高并发编程的运行效率</li></ul><p>特点：协程是我们在 Android 上进行异步编程的推荐解决方案。值得关注的特点包括：</p><ul><li><strong>轻量</strong>：可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</li><li><strong>内存泄漏更少</strong>：使用结构化并发机制在一个作用域内执行多项操作。</li><li><strong>内置取消支持</strong>：取消操作会自动在运行中的整个协程层次结构内传播。</li><li><strong>Jetpack 集成</strong>：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。</li></ul><h3 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h3><p><strong>Tips：</strong></p><ul><li><code>delay()</code>：让当前协程延迟指定时间再运行，会阻塞挂起函数，只会挂起当前协程，不会影响其他协程执行</li><li><code>suspend</code>：将任意函数声明为挂起函数，挂起函数间可以互相调用</li></ul><p><strong>作用域</strong></p><ul><li><code>GlobalScope.launch&#123;&#125;</code>：顶层协程（不建议用）</li><li><code>runBlocking&#123;&#125;</code>：作用域内所有代码和子协程没有全部执行完之前一直阻塞当前线程（测试用，生产可能有性能问题）</li><li><code>launch</code>：在作用域内创建多个协程</li><li><code>coroutineScope&#123;&#125;</code>：继承外部协程作用域并创建一个子协程，配合<code>suspend</code>使用，和<code>runBlocking</code>类似，用于生产环境</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printDot</span><span class="params">()</span></span> = coroutineScope&#123;</span><br><span class="line">    launch&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用写法</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">scope.launch&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel() <span class="comment">// 取消作用域内所有协程</span></span><br></pre></td></tr></table></figure><h3 id="获取执行结果"><a href="#获取执行结果" class="headerlink" title="获取执行结果"></a>获取执行结果</h3><p>调用<code>async</code>后，代码立即执行，如果调用<code>await()</code>时还没执行完，则会阻塞当前协程，直到获得<code>async</code>执行结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runBlocking&#123;</span><br><span class="line">    <span class="keyword">val</span> result = async&#123;</span><br><span class="line">        <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>withContext</code>是一个挂起函数，可以理解为<code>async</code>的一种简化版写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runBlocking&#123;</span><br><span class="line">    <span class="keyword">val</span> result = withContext(Dispatchers.Default)&#123;</span><br><span class="line">        <span class="number">5</span>+<span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程参数"><a href="#线程参数" class="headerlink" title="线程参数"></a>线程参数</h3><p>除了<code>coroutineScope</code>，其他函数都可以指定线程参数，<code>withContext</code>必须，其他可选</p><ul><li><code>Dispatchers.Default</code>：默认低并发线程策略</li><li><code>Dispatchers.IO</code>：较高并发的线程策略</li><li><code>Dispatchers.Main</code>：不会开启子线程，在 Android 主线程执行（只在安卓中使用）</li></ul><blockquote><p>Android 中要求网络请求必须在线程执行，定义协程也不行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为Android 世界的Swift，由JetBrains 设计开发并开源。 &lt;/p&gt;
&lt;p&gt;Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;用了Kotlin就不想回到Java，本文主要记录一些高级用法&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Kotlin" scheme="http://blog.sukiu.top/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack——Lifecycle</title>
    <link href="http://blog.sukiu.top/Android/Jetpack%E2%80%94Lifecycle/"/>
    <id>http://blog.sukiu.top/Android/Jetpack%E2%80%94Lifecycle/</id>
    <published>2021-10-01T11:37:46.000Z</published>
    <updated>2021-11-12T11:20:08.087Z</updated>
    
    <content type="html"><![CDATA[<p><code>Lifecycle</code>组件可以让任何一个类都能轻松感知到<code>Activity</code>的生命周期，同时不需要再<code>Activity</code>中编写太多额外的逻辑。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">Lifecycle  | Android 开发者  | Android Developers</a></p><p><a href="https://qingmei2.blog.csdn.net/article/details/79029657">Android官方架构组件:Lifecycle详解&amp;原理分析_却把清梅嗅的博客-CSDN博客_lifecycle原理</a></p></blockquote><h2 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h2><p>生命周期和状态事件如图所示：</p><center><img src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.svg?hl=zh-cn" alt="构成Android Activity生命周期的状态和事件" width="65%" /></center>## 2、Lifecycles 的最佳实践<p>一般在 <code>ViewModel</code>中观察和控制界面。 </p><ul><li><p>保持 UI 控制器（Activity 和 Fragment）尽可能的精简。它们不应该试图去获取它们所需的数据；相反，要用 ViewModel来获取，并且观察 LiveData将数据变化反映到视图中。</p></li><li><p>尝试编写数据驱动（data-driven）的 UI，即 UI 控制器的责任是在数据改变时更新视图或者将用户的操作通知给 ViewModel。</p></li><li><p>将数据逻辑放到 ViewModel 类中。ViewModel 应该作为 UI 控制器和应用程序其它部分的连接服务。注意：不是由 ViewModel 负责获取数据（例如：从网络获取）。相反，ViewModel 调用相应的组件获取数据，然后将数据获取结果提供给 UI 控制器。</p></li><li><p>使用Data Binding来保持视图和 UI 控制器之间的接口干净。这样可以让视图更具声明性，并且尽可能减少在 Activity 和 Fragment 中编写更新代码。如果你喜欢在 Java 中执行该操作，请使用像Butter Knife 这样的库来避免使用样板代码并进行更好的抽象化。</p></li><li><p>如果 UI 很复杂，可以考虑创建一个 Presenter 类来处理 UI 的修改。虽然通常这样做不是必要的，但可能会让 UI 更容易测试。</p></li><li><p>不要在 ViewModel 中引用View或者 Activity的 context。因为如果ViewModel存活的比 Activity 时间长（在配置更改的情况下），Activity 将会被泄漏并且无法被正确的回收。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Lifecycle&lt;/code&gt;组件可以让任何一个类都能轻松感知到&lt;code&gt;Activity&lt;/code&gt;的生命周期，同时不需要再&lt;code&gt;Activity&lt;/code&gt;中编写太多额外的逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Jetpack" scheme="http://blog.sukiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件——Service</title>
    <link href="http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Service/"/>
    <id>http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Service/</id>
    <published>2021-10-01T00:18:24.000Z</published>
    <updated>2021-10-01T02:18:52.156Z</updated>
    
    <content type="html"><![CDATA[<p><code>Service</code> 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。</p><p>简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/guide/components/services">服务概览  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><h2 id="1、多线程"><a href="#1、多线程" class="headerlink" title="1、多线程"></a>1、多线程</h2><p>一般耗时的服务都需要放在子线程中运行，否则会造成主线程阻塞，从而影响用户使用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><p>继承<code>Thread</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="type">Thread</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始运行</span></span><br><span class="line">MyThread().start() </span><br></pre></td></tr></table></figure></li><li><p>上面的方法耦合性过高，一般使用<code>Runnable</code>接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="type">Runnable&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始运行</span></span><br><span class="line"><span class="keyword">val</span> myThread = MyThread()</span><br><span class="line">Thread(myThread).start()</span><br></pre></td></tr></table></figure></li><li><p>更为常见的方法是使用<code>Lambda</code>表达式，不需要专门定义一个类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Kotlin中可以写为： 不需要调用 start()</span></span><br><span class="line">thread&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子线程更新UI"><a href="#子线程更新UI" class="headerlink" title="子线程更新UI"></a>子线程更新UI</h3><p>Android 的 UI 是线程不安全的，直接在子线程中进行 UI 操作会出现异常。不过，Android 提供了异步消息处理机制<code>Handler</code>。</p><p>主要包含以下部分：</p><ul><li><code>Message</code>：线程间传递的消息，可以在内部携带少量消息</li><li><code>Handler</code>：处理者，用于发送和处理消息</li><li><code>MessageQueue</code>：消息队列，用于存放通过<code>Handler</code>发送的消息，<strong>每个线程只有一个</strong></li><li><code>Looper</code>：每个线程中<code>MessageQueue</code>的管家，调用<code>Looper</code>的<code>loop()</code>后开始循环取出<code>MessageQueue</code>中的消息，并传递到<code>Handler</code>的<code>handleMessage()</code>中，<strong>每个线程只有一个</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> updateText = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> handler = <span class="keyword">object</span> : Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="keyword">when</span> (msg.what) &#123;</span><br><span class="line">                updateText -&gt; <span class="comment">//...</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">thread&#123;</span><br><span class="line">    <span class="keyword">val</span> msg = Message()</span><br><span class="line">    msg.what = updateText</span><br><span class="line">    handler.sendMessage(msg) <span class="comment">// 发送消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AsyncTask 在 API30 被Google废弃，转而推荐使用 <a href="https://developer.android.com/topic/libraries/architecture/coroutines">将 Kotlin 协程与生命周期感知型组件一起使用  | Android 开发者  | Android Developers</a></p></blockquote><h2 id="2、Service生命周期"><a href="#2、Service生命周期" class="headerlink" title="2、Service生命周期"></a>2、Service生命周期</h2><p>最常使用的回调方法是：<code>onBind()</code>、<code>onCreate</code>、<code>onStartCommand</code>、<code>onDestroy</code></p><ul><li><p><code>onCreate</code>：在 Service 创建（仅第一次）的时候调用</p></li><li><p><code>onStartCommand</code>：在 Service 启动（每次）的时候调用</p></li><li><p><code>onDestroy</code>：在 Service 销毁时调用</p></li></ul><p>每个 Service 只会存在一个实例</p><h2 id="3、Service基本用法"><a href="#3、Service基本用法" class="headerlink" title="3、Service基本用法"></a>3、Service基本用法</h2><h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">startService(intent) <span class="comment">// 启动</span></span><br><span class="line">stopService(intent) <span class="comment">// 停止</span></span><br></pre></td></tr></table></figure><h3 id="与Activity通信"><a href="#与Activity通信" class="headerlink" title="与Activity通信"></a>与Activity通信</h3><p>在活动中控制服务的具体执行，而不是启动后就无法控制。</p><p>通过<code>Bind</code>实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> : <span class="type">Binder</span></span>() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownload</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在活动中创建：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> downloadBinder = MyService.DownloadBinder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span>:ServiceConnection&#123; <span class="comment">// 匿名类</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123; <span class="comment">// 绑定时调用</span></span><br><span class="line">        downloadBinder = p1 <span class="keyword">as</span> MyService.DownloadBinder</span><br><span class="line">        downloadBinder.startDownload() <span class="comment">// 可自由选择 Service 中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(p0: <span class="type">ComponentName</span>?)</span></span> &#123; <span class="comment">// 进程崩溃或被杀掉时调用，不常用</span></span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">bindService(intent, connection, Context.BIND_AUTO_CREATE) <span class="comment">// 绑定Service</span></span><br><span class="line"><span class="comment">// BIND_AUTO_CREATE: 自动创建Service，调用 onCreate，忽略 onStartCommamd</span></span><br><span class="line">unbindService(connection) <span class="comment">// 解绑Service</span></span><br></pre></td></tr></table></figure><blockquote><p>任何 Service 可以和任意 Activity 绑定，且绑定后获得相同实例</p></blockquote><h2 id="4、前台服务"><a href="#4、前台服务" class="headerlink" title="4、前台服务"></a>4、前台服务</h2><p>前台服务是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。</p><p>前台服务必须为状态栏提供通知，将其放在运行中的标题下方。这意味着除非将服务停止或从前台移除，否则不能清除该通知。</p><p>从 Android 9.0 开始需要申请权限 <code>android.permission.FOREGROUND_SERVICE</code></p><p>在<code>onCreate</code>中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pendingIntent: PendingIntent =</span><br><span class="line">        Intent(<span class="keyword">this</span>, ExampleActivity::<span class="keyword">class</span>.java).let &#123; notificationIntent -&gt;</span><br><span class="line">            PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> notification: Notification = Notification.Builder(<span class="keyword">this</span>, CHANNEL_DEFAULT_IMPORTANCE)</span><br><span class="line">        .setContentTitle(getText(R.string.notification_title))</span><br><span class="line">        .setContentText(getText(R.string.notification_message))</span><br><span class="line">        .setSmallIcon(R.drawable.icon)</span><br><span class="line">        .setContentIntent(pendingIntent)</span><br><span class="line">        .setTicker(getText(R.string.ticker_text))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification)</span><br></pre></td></tr></table></figure><h2 id="5、IntentService"><a href="#5、IntentService" class="headerlink" title="5、IntentService"></a>5、IntentService</h2><p>用来执行耗时操作的 <code>Service</code> 的子类。</p><p>实现 <code>onHandleIntent()</code>，该方法会接收每个启动请求的 Intent，以便您执行后台工作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A constructor is required, and must call the super [android.app.IntentService.IntentService]</span></span><br><span class="line"><span class="comment"> * constructor with a name for the worker thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> : <span class="type">IntentService</span></span>(<span class="string">&quot;HelloIntentService&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The IntentService calls this method from the default worker thread with</span></span><br><span class="line"><span class="comment">     * the intent that started the service. When this method returns, IntentService</span></span><br><span class="line"><span class="comment">     * stops the service, as appropriate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">        <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            <span class="comment">// Restore interrupt status.</span></span><br><span class="line">            Thread.currentThread().interrupt()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写其他回调方法，（如 <code>onCreate()</code>、<code>onStartCommand()</code> 或 <code>onDestroy()</code>），请确保调用超类实现</p><p>例如，<code>onStartCommand()</code> 必须返回默认实现，即如何将 Intent 传递给 <code>onHandleIntent()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;service starting&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent(<span class="keyword">this</span>, HelloService::<span class="keyword">class</span>.java).also &#123; intent -&gt;</span><br><span class="line">    startService(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展服务类"><a href="#扩展服务类" class="headerlink" title="扩展服务类"></a>扩展服务类</h3><p>借助 <code>IntentService</code>，您可以非常轻松地实现启动服务。但是，若要求服务执行多线程（而非通过工作队列处理启动请求），则可通过扩展 <code>Service</code> 类来处理每个 Intent。</p><p>为进行比较，以下示例代码展示了 <code>Service</code> 类的实现，该类执行的工作与上述使用 <code>IntentService</code> 的示例完全相同。换言之，对于每个启动请求，其均使用工作线程来执行作业，且每次仅处理一个请求。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> serviceLooper: Looper? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> serviceHandler: ServiceHandler? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handler that receives messages from the thread</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span></span>(looper: Looper) : Handler(looper) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// Normally we would do some work here, like download a file.</span></span><br><span class="line">            <span class="comment">// For our sample, we just sleep for 5 seconds.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                <span class="comment">// Restore interrupt status.</span></span><br><span class="line">                Thread.currentThread().interrupt()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Stop the service using the startId, so that we don&#x27;t stop</span></span><br><span class="line">            <span class="comment">// the service in the middle of handling another job</span></span><br><span class="line">            stopSelf(msg.arg1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Start up the thread running the service.  Note that we create a</span></span><br><span class="line">        <span class="comment">// separate thread because the service normally runs in the process&#x27;s</span></span><br><span class="line">        <span class="comment">// main thread, which we don&#x27;t want to block.  We also make it</span></span><br><span class="line">        <span class="comment">// background priority so CPU-intensive work will not disrupt our UI.</span></span><br><span class="line">        HandlerThread(<span class="string">&quot;ServiceStartArguments&quot;</span>, Process.THREAD_PRIORITY_BACKGROUND).apply &#123;</span><br><span class="line">            start()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the HandlerThread&#x27;s Looper and use it for our Handler</span></span><br><span class="line">            serviceLooper = looper</span><br><span class="line">            serviceHandler = ServiceHandler(looper)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;service starting&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For each start request, send a message to start a job and deliver the</span></span><br><span class="line">        <span class="comment">// start ID so we know which request we&#x27;re stopping when we finish the job</span></span><br><span class="line">        serviceHandler?.obtainMessage()?.also &#123; msg -&gt;</span><br><span class="line">            msg.arg1 = startId</span><br><span class="line">            serviceHandler?.sendMessage(msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we get killed, after returning from here, restart</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t provide binding, so return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;service done&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Service&lt;/code&gt; 是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。&lt;/p&gt;
&lt;p&gt;简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Component" scheme="http://blog.sukiu.top/tags/Component/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack——ViewModel</title>
    <link href="http://blog.sukiu.top/Android/Jetpack%E2%80%94ViewModel/"/>
    <id>http://blog.sukiu.top/Android/Jetpack%E2%80%94ViewModel/</id>
    <published>2021-09-30T00:58:49.000Z</published>
    <updated>2021-11-07T15:09:59.174Z</updated>
    
    <content type="html"><![CDATA[<p><code>ViewModel</code> 类旨在以注重生命周期的方式存储和管理界面相关的数据。<code>ViewModel</code>类让数据可在发生屏幕旋转等配置更改后继续留存。</p><p>ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel 概览  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><h2 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h2><p><code>ViewModel</code>的一个重要作用是帮助<code>Activity</code>分担部分工作，专门用来存放与界面相关的数据，减轻<code>Activity</code>负担。</p><p>另外，如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。而<code>ViewModel</code>的生命周期和<code>Activity</code>不同，只有<code>Activity</code>退出时才会跟着一起销毁。</p><p><code>ViewModel</code>对象存在的时间范围是获取 <code>ViewModel</code> 时传递给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider"><code>ViewModelProvider</code></a> 的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle"><code>Lifecycle</code></a>。<code>ViewModel</code>将一直留在内存中，直到限定其存在时间范围的 <code>Lifecycle</code> 永久消失：</p><ul><li>对于 activity，是在 activity 完成时；</li><li>对于 fragment，是在 fragment 分离时。</li></ul><blockquote><p>通常在系统首次调用 Activity 对象的 <code>onCreate()</code> 方法时请求 <code>ViewModel</code></p></blockquote><center><img src="https://developer.android.com/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="ViewModel 的生命周期" style="zoom:80%;" /></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt; 类旨在以注重生命周期的方式存储和管理界面相关的数据。&lt;code&gt;ViewModel&lt;/code&gt;类让数据可在发生屏幕旋转等配置更改后继续留存。&lt;/p&gt;
&lt;p&gt;ViewModel 具有生命周期意识，会自动存储和管理 UI 相关的数据，即使设备配置发生变化后数据还会存在，我们就不需要在 onSaveInstanceState 保存数据，在 onCreate 中恢复数据了，使用 ViewModel 这部分工作就不需要我们做了，很好地将视图与逻辑分离开来。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Jetpack" scheme="http://blog.sukiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack——Compose</title>
    <link href="http://blog.sukiu.top/Android/Jetpack%E2%80%94Compose/"/>
    <id>http://blog.sukiu.top/Android/Jetpack%E2%80%94Compose/</id>
    <published>2021-09-29T13:30:56.000Z</published>
    <updated>2021-10-02T10:37:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>使用 JetpackCompose 的一些笔记。</p><span id="more"></span><p><strong>关键术语</strong> - <strong>组合</strong>：Jetpack Compose 在执行可组合项时构建的界面描述。</p><p><strong>初始组合</strong>：通过首次运行可组合项创建组合。</p><p><strong>重组</strong>：在数据发生变化时重新运行可组合项以更新组合。</p><p><code> &#39;Surface&#39; A surface container using the &#39;background&#39; color from the theme</code></p><p><code>&#39;Divider&#39; is a provided composable function that creates a horizontal divider.</code></p><h3 id="可组合项中的状态"><a href="#可组合项中的状态" class="headerlink" title="可组合项中的状态"></a>可组合项中的状态</h3><p>可组合函数可以使用 <code>remember</code> 可组合项记住单个对象。</p><p>系统会在初始组合期间将由 <code>remember</code> 计算的值存储在组合中，并在重组期间返回存储的值。</p><ul><li><p><code>remember</code> 既可用于存储可变对象，又可用于存储不可变对象。</p></li><li><p><code>mutableStateOf</code>会创建可观察的 <code>MutableState</code> 会创建可观察的 <code>MutableState</code>，后者是与 Compose 运行时集成的可观察类型。</p></li></ul><p>在可组合项中声明 <code>MutableState</code> 对象的方法有三种（等价）：</p><ul><li><code>val mutableState = remember &#123; mutableStateOf(default) &#125;</code></li><li><code>var value by remember &#123; mutableStateOf(default) &#125;</code></li><li><code>val (value, setValue) = remember &#123; mutableStateOf(default) &#125;</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Counter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> count = remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    Button(onClick = &#123; count.value++ &#125;) &#123;</span><br><span class="line">        Text(<span class="string">&quot;I&#x27;ve been clicked <span class="subst">$&#123;count.value&#125;</span> times&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><center><img src="https://developer.android.com/codelabs/jetpack-compose-theming/img/bb8ab0b2d8f9bca8.png?hl=zh-cn" alt="Material Design Color"  /></center><ul><li><code>primary</code>：main brand color</li><li><code>secondary</code>：provide accents</li></ul><h3 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h3><center><img src="https://developer.android.com/codelabs/jetpack-compose-theming/img/767fd40cb6938dc4.png?hl=zh-cn" alt="Typographies" style="zoom: 50%;" /></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 JetpackCompose 的一些笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Jetpack" scheme="http://blog.sukiu.top/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件——ContentProvider</title>
    <link href="http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94ContentProvider/"/>
    <id>http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94ContentProvider/</id>
    <published>2021-09-28T14:05:18.000Z</published>
    <updated>2021-10-01T02:18:27.614Z</updated>
    
    <content type="html"><![CDATA[<p>内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/guide/topics/providers/content-providers?hl=zh-cn">内容提供程序  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><blockquote><p>todo</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容提供程序主要目的是不同应用程序间的数据共享。它提供了一套完整的机制，允许一个程序访问另一个程序的数据，同时保证被访问数据的安全性。目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Component" scheme="http://blog.sukiu.top/tags/Component/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件——BroadcastReceiver</title>
    <link href="http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94BroadcastReceiver/"/>
    <id>http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94BroadcastReceiver/</id>
    <published>2021-09-28T11:37:11.000Z</published>
    <updated>2021-09-28T12:16:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">发布-订阅</a>设计模式相似。这些广播会在所关注的事件发生时发送。</p><p>一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/guide/components/broadcasts?hl=zh-cn">广播概览  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><h2 id="1、广播类型"><a href="#1、广播类型" class="headerlink" title="1、广播类型"></a>1、广播类型</h2><ul><li>标准广播：异步执行，所有的 BroadcastReceiver 均会收到消息，没有先后顺序。<ul><li>优点：效率高</li><li>缺点：无法被截断</li></ul></li><li>系统广播：同步执行，同一时刻只有一个 BroadcastReceiver 能收到消息，逻辑执行完毕才会继续传递，有先后顺序。<ul><li>优点：优先级高的 BroadcastReceiver 能先收到消息，并能截断广播</li><li>缺点：效率没有标准广播高</li></ul></li></ul><h2 id="2、系统广播"><a href="#2、系统广播" class="headerlink" title="2、系统广播"></a>2、系统广播</h2><p>Android 内置很多系统级别的广播，可以监听这些广播来得到各种系统状态信息。</p><p>可以在<code>&lt;Android SDK&gt;/platforms/&lt;任意api&gt;/data/broadcast_actions.txt</code>中查看</p><h3 id="1、动态注册"><a href="#1、动态注册" class="headerlink" title="1、动态注册"></a>1、动态注册</h3><p>程序启动之后才能接收广播</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">    intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>) <span class="comment">// 系统广播动作</span></span><br><span class="line">    timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">    registerReceiver(timeChangeReceiver, intentFilter) <span class="comment">// 动态注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    unregisterReceiver(timeChangeReceiver) <span class="comment">// 取消注册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类注册</span></span><br><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeChangeReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123; <span class="comment">// 继承 BroadcastReceiver</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(p0: <span class="type">Context</span>?, p1: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 不允许多线程，所以不能执行耗时操作</span></span><br><span class="line">        p0?.let &#123;</span><br><span class="line">            <span class="string">&quot;Time has changed&quot;</span>.showToast(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、静态注册"><a href="#2、静态注册" class="headerlink" title="2、静态注册"></a>2、静态注册</h3><p>由于大量恶意程序利用静态注册机制在程序未启动时监听系统广播，从而使任意应用都可以频繁从后台唤醒，因此 Android 每个版本都在削减静态注册 BroadcastReceiver 的功能。</p><p>Android 8.0 以后，所有隐式广播（没有指定发送给哪个程序的广播，大多数系统广播都属于此）都不允许使用静态注册接收。</p><p>例外情况见 <a href="https://developer.android.com/guide/components/broadcast-exceptions?hl=zh-cn">隐式广播例外情况  | Android 开发者  | Android Developers</a></p><p><strong>注意</strong>：尽管这些隐式广播仍在后台运行，但应避免为其注册监听器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span>  <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 需要权限 android.permission.RECEIVE_BOOT_COMPLETED--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.INPUT_METHOD_CHANGED&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、自定义广播"><a href="#3、自定义广播" class="headerlink" title="3、自定义广播"></a>3、自定义广播</h2><h3 id="1、发送标准广播"><a href="#1、发送标准广播" class="headerlink" title="1、发送标准广播"></a>1、发送标准广播</h3><h4 id="创建-BroadcastReceiver"><a href="#创建-BroadcastReceiver" class="headerlink" title="创建 BroadcastReceiver"></a>创建 BroadcastReceiver</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(p0: <span class="type">Context</span>?, p1: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2021/9/28  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span>  <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.MY_BROADCAST&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.MY_BROADCAST&quot;</span>)</span><br><span class="line">intent.setPackage(packageName) <span class="comment">// 指定包名，使其成为显示广播</span></span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure><h3 id="2、发送有序广播"><a href="#2、发送有序广播" class="headerlink" title="2、发送有序广播"></a>2、发送有序广播</h3><p>前面与标准广播相同，发送广播时选择 <code>sendOrderedBroadcast(intent,null)</code> （参数2是与权限相关的字符串）</p><h4 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h4><p>因为有序广播可以被截断，在静态注册时指定优先级：</p><p><code>&lt;intent-filter android:priority=&quot;100&quot;&gt;</code></p><h4 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h4><p>使用 <code>abortBroadcast()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(p0: <span class="type">Context</span>?, p1: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2021/9/28  </span></span><br><span class="line">        abortBroadcast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 应用与 Android 系统和其他 Android 应用之间可以相互收发广播消息，这与&lt;a href=&quot;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&quot;&gt;发布-订阅&lt;/a&gt;设计模式相似。这些广播会在所关注的事件发生时发送。&lt;/p&gt;
&lt;p&gt;一般来说，广播可作为跨应用和普通用户流之外的消息传递系统。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Component" scheme="http://blog.sukiu.top/tags/Component/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件——Activity</title>
    <link href="http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Activity/"/>
    <id>http://blog.sukiu.top/Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E2%80%94Activity/</id>
    <published>2021-09-28T00:45:08.000Z</published>
    <updated>2021-11-07T14:58:35.713Z</updated>
    
    <content type="html"><![CDATA[<p><code>Activity</code> 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 <code>main()</code> 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 <code>Activity</code> 实例中的代码。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn">Activity 简介  | Android 开发者  | Android Developers</a></p><p><a href="https://guolin.blog.csdn.net/article/details/105233078">《第一行代码 Android 第3版》</a></p></blockquote><h2 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>每个 Activity 至多有4种状态：</p><ul><li>运行状态：Activity 位于返回栈栈顶（系统不回收）</li><li>暂停状态：Activity 不处于栈顶，但仍然可见（只有内存极低时才可能被系统回收）</li><li>停止状态：Activity 不处于栈顶，并不可见（系统仍然保留相应的状态和成员变量，当其他地方需要内存时才可能被回收）</li><li>销毁状态：Activity 从返回栈移除（系统回收）</li></ul><h3 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h3><p>为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code>，另有一个<code>onRestart()</code>。当 Activity 进入新状态时，系统会调用其中每个回调。</p><ul><li><code>onCreate()</code>：首次创建 Activity 时调用，在其中完成初始化操作，比如加载布局、绑定事件等。会相继调用 <code>onStart()</code> 和 <code>onResume()</code> 方法</li><li><code>onStart()</code>：由不可见到可见时调用。会非常快速地完成，一旦此回调结束便会进入<code>onResume()</code></li><li><code>onResume()</code>：当准备好和用户交互时调用。此时Activity处于返回栈栈顶，并且处于运行状态</li><li><code>onPause()</code>：当准备去启动或恢复另一个 Activity 时调用，在其中释放消耗 CPU 的资源，保存关键数据</li><li><code>onStop()</code> ：当完全不可见时调用。与<code>onPause()</code> 的区别在于：如果新活动是对话框，<code>onPause()</code>执行，它不执行</li><li><code>onDestroy()</code>：在被销毁前调用，在其中释放内存。之后 Activity 变为消费状态</li><li><code>onRestart()</code>：由停止到运行时调用，即活动被重启</li></ul><center><img src="https://developer.android.com/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="Activity 生命周期的简化图示" style="zoom: 80%;" /></center><p>以上除了<code>onRestart()</code>两两对应，即：</p><ul><li>完整生存期：<code>onCreate()</code>→<code>onDestroy()</code></li><li>可见生存期：<code>onStart()</code>→<code>onStop()</code></li><li>前台生存期：<code>onResume()</code>→<code>onPause()</code></li></ul><h2 id="2、启动模式"><a href="#2、启动模式" class="headerlink" title="2、启动模式"></a>2、启动模式</h2><p>通过<code>AndroidManifest.xml</code>中为<code>&lt;activity&gt;</code>指定<code>android:launchMode</code></p><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>默认值。每次创建 Activity 的新实例，并将 intent 传送给该实例。</p><p>Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>在启动 Activity 时如果发现返回栈栈顶已经是该 Activity，则直接使用而不创建。</p><p>Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（但前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>在启动 Activity 时如果返回栈中已经有了该实例，则直接使用，并把在此 Activity 之上的所有其他 Activity 出栈，没有则新建实例。</p><p>Activity 一次只能有一个实例存在。</p><p><strong>注意</strong>：虽然 Activity 在新任务中启动，但用户按<strong>返回</strong>按钮仍会返回到上一个 Activity。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>与 <code>&quot;singleTask&quot;</code> 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。</p><p>该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。</p><p>即有单独的返回栈管理此 Activity，不管哪个应用访问这个活动，都共用一个返回栈。</p><p>用于其他应用中调用此 Activity。</p><h2 id="3、意图"><a href="#3、意图" class="headerlink" title="3、意图"></a>3、意图</h2><h3 id="显示-intent"><a href="#显示-intent" class="headerlink" title="显示 intent"></a>显示 intent</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><h3 id="隐式-intent"><a href="#隐式-intent" class="headerlink" title="隐式 intent"></a>隐式 intent</h3><p>在<code>&lt;activity&gt;</code>下配置<code>&lt;intent-filter&gt;</code>，在<code>&lt;action&gt;</code>中指名可以相应的<code>action</code>，<code>&lt;category&gt;</code>中添加附加信息，只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>同时匹配，当前活动才会响应 <code>intent</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ExampleActivity&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/app_icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(com.example.activitytest.ACTION_START) <span class="comment">// default 默认添加category</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><h3 id="向下一个-Activity-传递数据"><a href="#向下一个-Activity-传递数据" class="headerlink" title="向下一个 Activity 传递数据"></a>向下一个 Activity 传递数据</h3><p>在显示 intent 中添加：<code>intent.putExtra()</code></p><h3 id="向上一个Activity-传递数据"><a href="#向上一个Activity-传递数据" class="headerlink" title="向上一个Activity 传递数据"></a>向上一个Activity 传递数据</h3><p><code>SecondActivity.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed()</span><br><span class="line">    <span class="keyword">val</span> intent = Intent()</span><br><span class="line">    intent.putExtra(<span class="string">&quot;data_return&quot;</span>,<span class="string">&quot;msg...&quot;</span>)</span><br><span class="line">    setResult(RESULT_OK, intent)</span><br><span class="line">    finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FirstActivity.ky</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = ...</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>) <span class="comment">// 参数2是请求码，唯一值即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="keyword">if</span> (requestCode = RESULT_OK) &#123;</span><br><span class="line">            <span class="keyword">val</span> retrunedData = <span class="keyword">data</span>?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Activity&lt;/code&gt; 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 &lt;code&gt;main()&lt;/code&gt; 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 &lt;code&gt;Activity&lt;/code&gt; 实例中的代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://blog.sukiu.top/categories/Android/"/>
    
    
    <category term="Component" scheme="http://blog.sukiu.top/tags/Component/"/>
    
  </entry>
  
</feed>
