<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千反田</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2022-02-25T08:17:50.949Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>智力题</title>
    <link href="http://blog.sukiu.top/Knowledge/Brain-Teaser/"/>
    <id>http://blog.sukiu.top/Knowledge/Brain-Teaser/</id>
    <published>2022-02-25T08:04:34.000Z</published>
    <updated>2022-02-25T08:17:50.949Z</updated>
    
    <content type="html"><![CDATA[<p>面试智力题汇总</p><span id="more"></span><blockquote><p>转载自：</p><p><a href="https://codetop.cc/discuss/logic?tags=&page=1&type=read_num">CodeTop企业题库</a></p></blockquote><h2 id="1000瓶药水找毒药"><a href="#1000瓶药水找毒药" class="headerlink" title="1000瓶药水找毒药"></a>1000瓶药水找毒药</h2><p>一共 1000 瓶药水，其中 1 瓶有毒药。</p><p>已知小白鼠喝毒药一天内死，若想在一天内找到毒药，最少需要几只小白鼠？</p><blockquote><p>答案：<strong>10 只</strong>。</p><p>解析：二进制思想。</p><p><code>0 000 000 001</code>表示 1 号老鼠，喝了药水 1 。</p><p><code>0 000 000 010</code>表示 2 号老鼠，喝了药水 2 。</p><p><code>0 000 000 011</code>表示 1 号、 2 号老鼠，喝了药水 3 。</p><p>… …</p><p><code>1 111 101 000</code>表示 4、6、7、8、9、10号老鼠，喝了药水 1000。</p><p>按照上述的方法依次喝</p><p>第一回合，1 号老鼠喝药水 1</p><p>第二回合，2 号老鼠喝药水 2</p><p>…</p><p>第一千回合，4、6、7、8、9、10号老鼠喝药水 1000</p><p>喝完一天时，看 10 只老鼠的状态，根据老鼠状态就知道哪瓶药水有毒了。</p><p>比如最后只是 2 号老鼠死了，那就说明第2瓶药水有毒；如果4、6、7、8、9、10死了，那就说明第1000瓶药水有毒！</p><p>想明白这个道理，再来看怎么答案为何是10</p><p>我们需要让二进制表示的种类数&gt;=药水总数（1000）</p><p>求的是最小值，显然，为10的时候满足要求</p><p>也可以这么计算：<code>⌈ log N ⌉</code>，log底数为2</p></blockquote><h2 id="抢30"><a href="#抢30" class="headerlink" title="抢30"></a>抢30</h2><p>抢 30 是双人游戏<br>游戏规则是：第一个人喊 “ 1 ”或 “ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。</p><p>两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略。</p><blockquote><p>答案：<strong>尽量喊3的倍数</strong>。</p><p>解析：倒着看，其实，喊 27 时，就决定胜负了。假设 A 喊了 27，B只能喊 28 或 29 ，下个回合，A 一定可以喊30。也就是说，喊 27 者必胜。</p><p>再倒着看，其实喊 24 时，就定胜负了。假设 A 喊了 24 ，B 只能喊 25 或 26 ，下个回合 A 一定能喊 27 。</p><p>由于喊 27 者必胜，因此喊 24 者也必胜。</p><p>同理可以推出：<strong>喊 3 的倍数者必胜</strong>。</p><p>然后就会发现，这个游戏，<strong>谁先喊，谁一定输</strong>。</p></blockquote><h2 id="灯泡开关"><a href="#灯泡开关" class="headerlink" title="灯泡开关"></a>灯泡开关</h2><p>一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。</p><p>设计一种算法，对于任意初始状态，使所有灯泡全亮。</p><blockquote><p>将灯泡编号 1 ~ 100</p><p><strong>步骤一：将灯泡变为全亮或只剩一个为暗</strong></p><p>从 1 循环到 98 ，遇到暗的则按它<strong>下一个</strong>，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。</p><ul><li>若为亮亮，皆大欢喜，满足题目要求</li><li>暗亮、亮暗，达到只剩一个为暗的状态；</li><li>若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。</li></ul><p><strong>步骤二：将灯泡变为全暗</strong></p><p>由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。</p><p><strong>步骤三：将灯泡变为全亮</strong></p><p>将所有灯泡按一下，灯泡变为全亮。</p></blockquote><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>对于 N 个灯泡的任意初始状态 ( N &gt; 3 ) ，能否经过若干次操作使得所有灯泡全亮？</p><blockquote><p>N 个灯泡做分类讨论。</p><ol><li><code>N = 3*k+1</code>一定可以。方法与上述步骤相同，在步骤二中可以将3k个亮的灯泡分为k组。</li><li><code>N = 3*k+2</code>一定可以。将上述步骤一目标状态的只剩一个为暗改成<strong>剩两个相邻为暗</strong>，其余 3 * k 个灯泡分组按即可。因为，对于任意只剩一个为暗的状态，按下该灯泡左右任意一个就可以变成剩两个相邻为暗的状态！</li><li><code>N = 3*k</code>不一定。如果经过上述步骤一可以将灯泡变成全亮的状态则有解；否则，无解。（该结论有待证明）</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试智力题汇总&lt;/p&gt;</summary>
    
    
    
    <category term="Knowledge" scheme="http://blog.sukiu.top/categories/Knowledge/"/>
    
    
    <category term="Interview" scheme="http://blog.sukiu.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Go的设计模式</title>
    <link href="http://blog.sukiu.top/Design-Pattern/Go-Design-Pattern/"/>
    <id>http://blog.sukiu.top/Design-Pattern/Go-Design-Pattern/</id>
    <published>2022-02-23T03:19:37.000Z</published>
    <updated>2022-02-23T06:40:29.992Z</updated>
    
    <content type="html"><![CDATA[<p>Go的设计模式：❌指在Go中不常用</p><ul><li>创建型<ul><li>单例模式：一个类只有一个实例<ul><li>饿汉：系统初始化时创建并初始化单例对象</li><li>懒汉：调用实例时初始化单例对象</li></ul></li><li>工厂模式：使用共同接口创建对象</li><li>建造者模式：与工厂不同在于，创建参数复杂的对象</li><li>原型模式：利用已有对象复制的方式来创建新的对象 ❌</li></ul></li><li>结构型<ul><li>代理模式：为其他对象提供⼀种代理以控制这个对象的访问 <strong>代理访问</strong></li><li>桥接模式：将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化 <strong>抽象实现拆分独立</strong></li><li>装饰模式：动态地给⼀个对象添加⼀些额外的职责 <strong>附加职责</strong></li><li>适配器模式：将⼀个类的接口转换成用户希望得到的另⼀个接口 <strong>转换接口</strong></li><li>门面模式：定义⼀个高层接口，为子系统中的⼀组接口提供一个一致的外观 <strong>对外统一接口</strong> ❌</li><li>组合模式：将对象组合成树型结构以表示”整体-部分”的层次结构 <strong>树型目录结构</strong> ❌</li><li>享元模式：提供支持大量细粒度对象共享的有效方法 ❌</li></ul></li><li>行为型<ul><li>观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</li><li>模板模式：定义⼀个操作中的算法骨架，而将⼀些步骤延迟到子类中，使得子类可以不改变⼀个算法的结构即可重新定义算法的某些特定步骤</li><li>策略模式：定义⼀系列算法，把它们⼀个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化</li><li>职责链模式：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有⼀个对象处理这个请求 <strong>传递职责</strong></li><li>状态模式：允许⼀个对象在其内部状态改变时改变它的行为</li><li>迭代器模式：提供⼀种方法来顺序访问⼀个聚合对象中的各个元素而不需要暴露该对象的内部表示</li><li>访问者模式：表示⼀个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 ❌</li><li>备忘录模式：在不破坏封装性的前提下，捕获⼀个对象的内部状态，并在该对象之外保存这个状态，从而可用在以后将该对象恢复到原先保存的状态 ❌</li><li>命令模式：将⼀个请求封装为⼀个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求⽇志，支持可撤销的操作 ❌</li><li>解释器模式：给定⼀种语言，定义它的文法表示，并定义⼀个解释器，该解释器用来根据文法表示来解释语言中的句子 ❌</li><li>中介模式：用⼀个中介对象来封装⼀系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 ❌</li></ul></li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://lailin.xyz/post/go-design-pattern.html">Go设计模式24-总结(更新完毕) - Mohuishou</a></p></blockquote><h1 id="1、创建型"><a href="#1、创建型" class="headerlink" title="1、创建型"></a>1、创建型</h1><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231202054.png" alt="创建型模式"></p><h2 id="单例模式-singleton"><a href="#单例模式-singleton" class="headerlink" title="单例模式 singleton"></a>单例模式 singleton</h2><p><strong>一个类只允许创建一个对象（实例）</strong>，这个类就是单例类，这种设计模式就叫单例模式</p><p><strong>用处：</strong> 业务上，有些数据在系统中只应该保存一份</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231129062.png" alt="单例模式"></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><blockquote><p>在系统初始化的时候我们已经把对象创建好了，需要用的时候直接拿过来用就好了</p></blockquote><p>类一旦加载，就把单例初始化完成，保证<code>getInstance</code>的时候，单例是已经存在的了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><blockquote><p>创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建</p></blockquote><p>只有当调用<code>getInstance</code>的时候，才会去初始化这个单例。</p><p>为了实现懒汉式不可避免的需要加锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    lazySingleton *Singleton</span><br><span class="line">    once          = &amp;sync.Once&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetLazyInstance 懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLazyInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lazySingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            lazySingleton = &amp;Singleton&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazySingleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式-factory"><a href="#工厂模式-factory" class="headerlink" title="工厂模式 factory"></a>工厂模式 factory</h2><p>在工厂模式中，在创建对象时不会对客户端暴露创建逻辑，并且是通过<strong>使用一个共同的接口来指向新创建的对象</strong>。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231147355.png" alt="工厂模式"></p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>Go 本身是没有构造函数的，一般而言采用 <code>NewName</code> 的方式创建对象/接口，当它返回的是接口的时候，其实就是简单工厂模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRuleConfigParser IRuleConfigParser</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Parse(data []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonRuleConfigParser jsonRuleConfigParser</span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse Parse</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(J jsonRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yamlRuleConfigParser yamlRuleConfigParser</span></span><br><span class="line"><span class="keyword">type</span> yamlRuleConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse Parse</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Y yamlRuleConfigParser)</span> <span class="title">Parse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIRuleConfigParser NewIRuleConfigParser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIRuleConfigParser</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;json&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonRuleConfigParser&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yaml&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> yamlRuleConfigParser&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象。</p><p>做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p><blockquote><p>组合复用原则：优先使用组合 contains a（聚合 has a），而不是继承 is a 来达到目的</p><p>迪米特法则：⼀个对象应当对其他对象有尽可能少的了解，即不和陌生人说话</p><ul><li>优点：降低类之间的耦合</li><li>缺点：产生大量中介类，设计变复杂</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRuleConfigParserFactory 工厂方法接口</span></span><br><span class="line"><span class="keyword">type</span> IRuleConfigParserFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateParser() IRuleConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类</span></span><br><span class="line"><span class="keyword">type</span> yamlRuleConfigParserFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateParser CreateParser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(y yamlRuleConfigParserFactory)</span> <span class="title">CreateParser</span><span class="params">()</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> yamlRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类</span></span><br><span class="line"><span class="keyword">type</span> jsonRuleConfigParserFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateParser CreateParser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j jsonRuleConfigParserFactory)</span> <span class="title">CreateParser</span><span class="params">()</span> <span class="title">IRuleConfigParser</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jsonRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIRuleConfigParserFactory</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="title">IRuleConfigParserFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;json&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonRuleConfigParserFactory&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yaml&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> yamlRuleConfigParserFactory&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式-builder"><a href="#建造者模式-builder" class="headerlink" title="建造者模式 builder"></a>建造者模式 builder</h2><p>在 Golang 中对于创建类参数比较多的对象的时候，常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231158567.png" alt="建造者模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfigOption option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOption <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxTotal <span class="keyword">int</span></span><br><span class="line">    maxIdle  <span class="keyword">int</span></span><br><span class="line">    minIdle  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcePoolConfigOptFunc to set option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOptFunc <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewResourcePoolConfig NewResourcePoolConfig</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourcePoolConfig</span><span class="params">(name <span class="keyword">string</span>, opts ...ResourcePoolConfigOptFunc)</span> <span class="params">(*ResourcePoolConfig, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    option := &amp;ResourcePoolConfigOption&#123;</span><br><span class="line">        maxTotal: <span class="number">10</span>,</span><br><span class="line">        maxIdle:  <span class="number">9</span>,</span><br><span class="line">        minIdle:  <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(option)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> option.maxTotal &lt; <span class="number">0</span> || option.maxIdle &lt; <span class="number">0</span> || option.minIdle &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;</span><br><span class="line">        name:     name,</span><br><span class="line">        maxTotal: option.maxTotal,</span><br><span class="line">        maxIdle:  option.maxIdle,</span><br><span class="line">        minIdle:  option.minIdle,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式-prototype"><a href="#原型模式-prototype" class="headerlink" title="原型模式 prototype"></a>原型模式 prototype</h2><p>利用已有对象（原型）进行复制（拷贝）的方式来创建新的对象，达到节省创建时间的目的。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231203233.png" alt="原型模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> prototype</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keyword 搜索关键字</span></span><br><span class="line"><span class="keyword">type</span> Keyword <span class="keyword">struct</span> &#123;</span><br><span class="line">    word      <span class="keyword">string</span></span><br><span class="line">    visit     <span class="keyword">int</span></span><br><span class="line">    UpdatedAt *time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone 这里使用序列化与反序列化的方式深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *Keyword)</span> <span class="title">Clone</span><span class="params">()</span> *<span class="title">Keyword</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newKeyword Keyword</span><br><span class="line">    b, _ := json.Marshal(k)</span><br><span class="line">    json.Unmarshal(b, &amp;newKeyword)</span><br><span class="line">    <span class="keyword">return</span> &amp;newKeyword</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keywords 关键字 map</span></span><br><span class="line"><span class="keyword">type</span> Keywords <span class="keyword">map</span>[<span class="keyword">string</span>]*Keyword</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone 复制一个新的 keywords</span></span><br><span class="line"><span class="comment">// updatedWords: 需要更新的关键词列表，由于从数据库中获取数据常常是数组的方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(words Keywords)</span> <span class="title">Clone</span><span class="params">(updatedWords []*Keyword)</span> <span class="title">Keywords</span></span> &#123;</span><br><span class="line">    newKeywords := Keywords&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> words &#123;</span><br><span class="line">        <span class="comment">// 这里是浅拷贝，直接拷贝了地址</span></span><br><span class="line">        newKeywords[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉需要更新的字段，这里用的是深拷贝</span></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> updatedWords &#123;</span><br><span class="line">        newKeywords[word.word] = word.Clone()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newKeywords</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、结构型"><a href="#2、结构型" class="headerlink" title="2、结构型"></a>2、结构型</h1><h2 id="代理模式-proxy"><a href="#代理模式-proxy" class="headerlink" title="代理模式 proxy"></a>代理模式 proxy</h2><p>为其他对象提供⼀种代理以控制这个对象的访问。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231208710.png" alt="代理模式"></p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IUser IUser</span></span><br><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Login(username, password <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 用户</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 用户登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Login</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不实现细节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserProxy 代理类</span></span><br><span class="line"><span class="keyword">type</span> UserProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    user *User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserProxy NewUserProxy</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserProxy</span><span class="params">(user *User)</span> *<span class="title">UserProxy</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserProxy&#123;</span><br><span class="line">        user: user,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 登录，和 user 实现相同的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *UserProxy)</span> <span class="title">Login</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// before 这里可能会有一些统计的逻辑</span></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是原有的业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> err := p.user.Login(username, password); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after 这里可能也有一些监控统计的逻辑</span></span><br><span class="line">    log.Printf(<span class="string">&quot;user login cost time: %s&quot;</span>, time.Now().Sub(start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式-bridge"><a href="#桥接模式-bridge" class="headerlink" title="桥接模式 bridge"></a>桥接模式 bridge</h2><p>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231210754.png" alt="桥接模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMsgSender IMsgSender</span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件</span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现</span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;</span><br><span class="line">    emails []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="keyword">string</span>)</span> *<span class="title">EmailMsgSender</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send Send</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span> <span class="title">Send</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里去发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INotification 通知接口</span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;</span><br><span class="line">    Notify(msg <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorNotification 错误通知</span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别</span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;</span><br><span class="line">    sender IMsgSender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span> *<span class="title">ErrorNotification</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 发送通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span> <span class="title">Notify</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n.sender.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰模式-decorator"><a href="#装饰模式-decorator" class="headerlink" title="装饰模式 decorator"></a>装饰模式 decorator</h2><p>动态地给⼀个对象添加⼀些额外的职责。它提供了用子类扩展功能的⼀个灵活的替代，比派生一个子类更加灵活。</p><p><strong>附加职责</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231212129.png" alt="装饰模式"></p><p>下面是一个简单的画画的例子，默认的 <code>Square</code> 只有基础的画画功能， <code>ColorSquare</code> 为他加上了颜色</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDraw IDraw</span></span><br><span class="line"><span class="keyword">type</span> IDraw <span class="keyword">interface</span> &#123;</span><br><span class="line">    Draw() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Square 正方形</span></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw Draw</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Square)</span> <span class="title">Draw</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;this is a square&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ColorSquare 有颜色的正方形</span></span><br><span class="line"><span class="keyword">type</span> ColorSquare <span class="keyword">struct</span> &#123;</span><br><span class="line">    square IDraw</span><br><span class="line">    color  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewColorSquare NewColorSquare</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewColorSquare</span><span class="params">(square IDraw, color <span class="keyword">string</span>)</span> <span class="title">ColorSquare</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ColorSquare&#123;color: color, square: square&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw Draw</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ColorSquare)</span> <span class="title">Draw</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.square.Draw() + <span class="string">&quot;, color is &quot;</span> + c.color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式-adapter"><a href="#适配器模式-adapter" class="headerlink" title="适配器模式 adapter"></a>适配器模式 adapter</h2><p>将⼀个类的接口转换成用户希望得到的另⼀个接口，它使原本不相容的接口得以协同⼯作。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231214029.png" alt="适配器模式"></p><p>假设现在有一个运维系统，需要分别调用阿里云和 AWS 的 SDK 创建主机，两个 SDK 提供的创建主机的接口不一致，此时就可以通过适配器模式，将两个接口统一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ICreateServer 创建云主机</span></span><br><span class="line"><span class="keyword">type</span> ICreateServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateServer(cpu, mem <span class="keyword">float64</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AWSClient aws sdk</span></span><br><span class="line"><span class="keyword">type</span> AWSClient <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunInstance 启动实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AWSClient)</span> <span class="title">RunInstance</span><span class="params">(cpu, mem <span class="keyword">float64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;aws client run success, cpu： %f, mem: %f&quot;</span>, cpu, mem)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AwsClientAdapter 适配器</span></span><br><span class="line"><span class="keyword">type</span> AwsClientAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    Client AWSClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateServer 启动实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AwsClientAdapter)</span> <span class="title">CreateServer</span><span class="params">(cpu, mem <span class="keyword">float64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    a.Client.RunInstance(cpu, mem)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunClient aliyun sdk</span></span><br><span class="line"><span class="keyword">type</span> AliyunClient <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateServer 启动实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AliyunClient)</span> <span class="title">CreateServer</span><span class="params">(cpu, mem <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;aws client run success, cpu： %d, mem: %d&quot;</span>, cpu, mem)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunClientAdapter 适配器</span></span><br><span class="line"><span class="keyword">type</span> AliyunClientAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">    Client AliyunClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateServer 启动实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AliyunClientAdapter)</span> <span class="title">CreateServer</span><span class="params">(cpu, mem <span class="keyword">float64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    a.Client.CreateServer(<span class="keyword">int</span>(cpu), <span class="keyword">int</span>(mem))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="门面模式-facade"><a href="#门面模式-facade" class="headerlink" title="门面模式 facade"></a>门面模式 facade</h2><p>定义⼀个高层接口，为子系统中的⼀组接口提供一个一致的外观，从而简化了该子系统的使用。</p><p><strong>对外统一接口</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231353536.jpeg" alt="门面模式"></p><blockquote><p>假设现在我有一个网站，以前有登录和注册的流程，登录的时候调用用户的查询接口，注册时调用用户的创建接口。为了简化用户的使用流程，我们现在提供直接验证码登录/注册的功能，如果该手机号已注册那么我们就走登录流程，如果该手机号未注册，那么我们就创建一个新的用户。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade</span><br><span class="line"></span><br><span class="line"><span class="comment">// IUser 用户接口</span></span><br><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Login(phone <span class="keyword">int</span>, code <span class="keyword">int</span>) (*User, error)</span><br><span class="line">    Register(phone <span class="keyword">int</span>, code <span class="keyword">int</span>) (*User, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IUserFacade 门面模式</span></span><br><span class="line"><span class="keyword">type</span> IUserFacade <span class="keyword">interface</span> &#123;</span><br><span class="line">    LoginOrRegister(phone <span class="keyword">int</span>, code <span class="keyword">int</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 用户</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService UserService</span></span><br><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserService)</span> <span class="title">Login</span><span class="params">(phone <span class="keyword">int</span>, code <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 校验操作 ...</span></span><br><span class="line">    <span class="keyword">return</span> &amp;User&#123;Name: <span class="string">&quot;test login&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register 注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserService)</span> <span class="title">Register</span><span class="params">(phone <span class="keyword">int</span>, code <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 校验操作 ...</span></span><br><span class="line">    <span class="comment">// 创建用户</span></span><br><span class="line">    <span class="keyword">return</span> &amp;User&#123;Name: <span class="string">&quot;test register&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoginOrRegister 登录或注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UserService)</span><span class="title">LoginOrRegister</span><span class="params">(phone <span class="keyword">int</span>, code <span class="keyword">int</span>)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">    user, err := u.Login(phone, code)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> user != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u.Register(phone, code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式-composite"><a href="#组合模式-composite" class="headerlink" title="组合模式 composite"></a>组合模式 composite</h2><p>将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有⼀致性。</p><p><strong>树形目录结构</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231355688.png" alt="组合模式"></p><blockquote><p>公司的人员组织就是一个典型的树状的结构，现在假设我们现在有部分，和员工，两种角色，一个部门下面可以存在子部门和员工，员工下面不能再包含其他节点。</p></blockquote><p>我们现在要实现一个统计一个部门下员工数量的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite</span><br><span class="line"></span><br><span class="line"><span class="comment">// IOrganization 组织接口，都实现统计人数的功能</span></span><br><span class="line"><span class="keyword">type</span> IOrganization <span class="keyword">interface</span> &#123;</span><br><span class="line">    Count() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 员工</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count 人数统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Employee)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Department 部门</span></span><br><span class="line"><span class="keyword">type</span> Department <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    SubOrganizations []IOrganization</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count 人数统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Department)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, org := <span class="keyword">range</span> d.SubOrganizations &#123;</span><br><span class="line">        c += org.Count()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddSub 添加子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Department)</span> <span class="title">AddSub</span><span class="params">(org IOrganization)</span></span> &#123;</span><br><span class="line">    d.SubOrganizations = <span class="built_in">append</span>(d.SubOrganizations, org)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewOrganization 构建组织架构 demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrganization</span><span class="params">()</span> <span class="title">IOrganization</span></span> &#123;</span><br><span class="line">    root := &amp;Department&#123;Name: <span class="string">&quot;root&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        root.AddSub(&amp;Employee&#123;&#125;)</span><br><span class="line">        root.AddSub(&amp;Department&#123;Name: <span class="string">&quot;sub&quot;</span>, SubOrganizations: []IOrganization&#123;&amp;Employee&#123;&#125;&#125;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式-flyweight"><a href="#享元模式-flyweight" class="headerlink" title="享元模式 flyweight"></a>享元模式 flyweight</h2><p>提供支持大量细粒度对象共享的有效方法。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231358380.png" alt="享元模式"></p><blockquote><p>象棋，无论是什么对局，棋子的基本属性其实是固定的，并不会因为随着下棋的过程变化。那我们就可以把棋子变为享元，让所有的对局都共享这些对象，以此达到节省内存的目的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flyweight</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> units = <span class="keyword">map</span>[<span class="keyword">int</span>]*ChessPieceUnit&#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">        ID:    <span class="number">1</span>,</span><br><span class="line">        Name:  <span class="string">&quot;車&quot;</span>,</span><br><span class="line">        Color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;</span><br><span class="line">        ID:    <span class="number">2</span>,</span><br><span class="line">        Name:  <span class="string">&quot;炮&quot;</span>,</span><br><span class="line">        Color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ... 其他棋子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChessPieceUnit 棋子享元</span></span><br><span class="line"><span class="keyword">type</span> ChessPieceUnit <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID    <span class="keyword">uint</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewChessPieceUnit 工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChessPieceUnit</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">ChessPieceUnit</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> units[id]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChessPiece 棋子</span></span><br><span class="line"><span class="keyword">type</span> ChessPiece <span class="keyword">struct</span> &#123;</span><br><span class="line">    Unit *ChessPieceUnit</span><br><span class="line">    X    <span class="keyword">int</span></span><br><span class="line">    Y    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChessBoard 棋局</span></span><br><span class="line"><span class="keyword">type</span> ChessBoard <span class="keyword">struct</span> &#123;</span><br><span class="line">    chessPieces <span class="keyword">map</span>[<span class="keyword">int</span>]*ChessPiece</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewChessBoard 初始化棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChessBoard</span><span class="params">()</span> *<span class="title">ChessBoard</span></span> &#123;</span><br><span class="line">    board := &amp;ChessBoard&#123;chessPieces: <span class="keyword">map</span>[<span class="keyword">int</span>]*ChessPiece&#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> units &#123;</span><br><span class="line">        board.chessPieces[id] = &amp;ChessPiece&#123;</span><br><span class="line">            Unit: NewChessPieceUnit(id),</span><br><span class="line">            X:    <span class="number">0</span>,</span><br><span class="line">            Y:    <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move 移动棋子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChessBoard)</span> <span class="title">Move</span><span class="params">(id, x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c.chessPieces[id].X = x</span><br><span class="line">    c.chessPieces[id].Y = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、行为型"><a href="#3、行为型" class="headerlink" title="3、行为型"></a>3、行为型</h1><h2 id="观察者模式-observer"><a href="#观察者模式-observer" class="headerlink" title="观察者模式 observer"></a>观察者模式 observer</h2><p>定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231408656.png" alt="观察者模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ISubject subject</span></span><br><span class="line"><span class="keyword">type</span> ISubject <span class="keyword">interface</span> &#123;</span><br><span class="line">    Register(observer IObserver)</span><br><span class="line">    Remove(observer IObserver)</span><br><span class="line">    Notify(msg <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IObserver 观察者</span></span><br><span class="line"><span class="keyword">type</span> IObserver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Update(msg <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject Subject</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">    observers []IObserver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register 注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sub *Subject)</span> <span class="title">Register</span><span class="params">(observer IObserver)</span></span> &#123;</span><br><span class="line">    sub.observers = <span class="built_in">append</span>(sub.observers, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 移除观察者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sub *Subject)</span> <span class="title">Remove</span><span class="params">(observer IObserver)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, ob := <span class="keyword">range</span> sub.observers &#123;</span><br><span class="line">        <span class="keyword">if</span> ob == observer &#123;</span><br><span class="line">            sub.observers = <span class="built_in">append</span>(sub.observers[:i], sub.observers[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify 通知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sub *Subject)</span> <span class="title">Notify</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> sub.observers &#123;</span><br><span class="line">        o.Update(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer1 Observer1</span></span><br><span class="line"><span class="keyword">type</span> Observer1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 实现观察者接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Observer1)</span> <span class="title">Update</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Observer1: %s&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer2 Observer2</span></span><br><span class="line"><span class="keyword">type</span> Observer2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 实现观察者接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Observer2)</span> <span class="title">Update</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Observer2: %s&quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式-template"><a href="#模板模式-template" class="headerlink" title="模板模式 template"></a>模板模式 template</h2><p>定义⼀个操作中的算法骨架，而将⼀些步骤延迟到子类中，使得子类可以不改变⼀个算法的结构即可重新定义算法的某些特定步骤。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231409069.png" alt="模板模式"></p><blockquote><p>要做一个短信推送的系统，那么需要</p><ol><li>检查短信字数是否超过限制</li><li>检查手机号是否正确</li><li>发送短信</li><li>返回状态</li></ol><p>我们可以发现，在发送短信的时候由于不同的供应商调用的接口不同，所以会有一些实现上的差异，但是他的算法（业务逻辑）是固定的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ISMS ISMS</span></span><br><span class="line"><span class="keyword">type</span> ISMS <span class="keyword">interface</span> &#123;</span><br><span class="line">    send(content <span class="keyword">string</span>, phone <span class="keyword">int</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SMS 短信发送基类</span></span><br><span class="line"><span class="keyword">type</span> sms <span class="keyword">struct</span> &#123;</span><br><span class="line">    ISMS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Valid 校验短信字数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sms)</span> <span class="title">Valid</span><span class="params">(content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content) &gt; <span class="number">63</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;content is too long&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 发送短信</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sms)</span> <span class="title">Send</span><span class="params">(content <span class="keyword">string</span>, phone <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := s.Valid(content); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用子类的方法发送短信</span></span><br><span class="line">    <span class="keyword">return</span> s.send(content, phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TelecomSms 走电信通道</span></span><br><span class="line"><span class="keyword">type</span> TelecomSms <span class="keyword">struct</span> &#123;</span><br><span class="line">    *sms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTelecomSms NewTelecomSms</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTelecomSms</span><span class="params">()</span> *<span class="title">TelecomSms</span></span> &#123;</span><br><span class="line">    tel := &amp;TelecomSms&#123;&#125;</span><br><span class="line">    <span class="comment">// 这里有点绕，是因为 go 没有继承，用嵌套结构体的方法进行模拟</span></span><br><span class="line">    <span class="comment">// 这里将子类作为接口嵌入父类，就可以让父类的模板方法 Send 调用到子类的函数</span></span><br><span class="line">    <span class="comment">// 实际使用中，我们并不会这么写，都是采用组合+接口的方式完成类似的功能</span></span><br><span class="line">    tel.sms = &amp;sms&#123;ISMS: tel&#125;</span><br><span class="line">    <span class="keyword">return</span> tel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tel *TelecomSms)</span> <span class="title">send</span><span class="params">(content <span class="keyword">string</span>, phone <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;send by telecom success&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式-strategy"><a href="#策略模式-strategy" class="headerlink" title="策略模式 strategy"></a>策略模式 strategy</h2><p>定义⼀系列算法，把它们⼀个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231410116.png" alt="策略模式"></p><blockquote><p>在保存文件的时候，由于政策或者其他的原因可能需要选择不同的存储方式，敏感数据我们需要加密存储，不敏感的数据我们可以直接明文保存。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// StorageStrategy 存储策略</span></span><br><span class="line"><span class="keyword">type</span> StorageStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    Save(name <span class="keyword">string</span>, data []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strategys = <span class="keyword">map</span>[<span class="keyword">string</span>]StorageStrategy&#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>:         &amp;fileStorage&#123;&#125;,</span><br><span class="line">    <span class="string">&quot;encrypt_file&quot;</span>: &amp;encryptFileStorage&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStorageStrategy NewStorageStrategy</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorageStrategy</span><span class="params">(t <span class="keyword">string</span>)</span> <span class="params">(StorageStrategy, error)</span></span> &#123;</span><br><span class="line">    s, ok := strategys[t]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found StorageStrategy: %s&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileStorage 保存到文件</span></span><br><span class="line"><span class="keyword">type</span> fileStorage <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save Save</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *fileStorage)</span> <span class="title">Save</span><span class="params">(name <span class="keyword">string</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encryptFileStorage 加密保存到文件</span></span><br><span class="line"><span class="keyword">type</span> encryptFileStorage <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save Save</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *encryptFileStorage)</span> <span class="title">Save</span><span class="params">(name <span class="keyword">string</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    data, err := encrypt(data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioutil.WriteFile(name, data, os.ModeAppend)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encrypt</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里实现加密算法</span></span><br><span class="line">    <span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="职责链模式-chain-of-responsibility"><a href="#职责链模式-chain-of-responsibility" class="headerlink" title="职责链模式 chain of responsibility"></a>职责链模式 chain of responsibility</h2><p>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请 求，直到有⼀个对象处理这个请求。<br><strong>传递职责</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231411476.png" alt="职责链模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package chain 职责链模式</span></span><br><span class="line"><span class="comment">// 🌰 假设我们现在有个校园论坛，由于社区规章制度、广告、法律法规的原因需要对用户的发言进行敏感词过滤</span></span><br><span class="line"><span class="comment">//    如果被判定为敏感词，那么这篇帖子将会被封禁</span></span><br><span class="line"><span class="keyword">package</span> chain</span><br><span class="line"></span><br><span class="line"><span class="comment">// SensitiveWordFilter 敏感词过滤器，判定是否是敏感词</span></span><br><span class="line"><span class="keyword">type</span> SensitiveWordFilter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Filter(content <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SensitiveWordFilterChain 职责链</span></span><br><span class="line"><span class="keyword">type</span> SensitiveWordFilterChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    filters []SensitiveWordFilter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddFilter 添加一个过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SensitiveWordFilterChain)</span> <span class="title">AddFilter</span><span class="params">(filter SensitiveWordFilter)</span></span> &#123;</span><br><span class="line">    c.filters = <span class="built_in">append</span>(c.filters, filter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter 执行过滤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SensitiveWordFilterChain)</span> <span class="title">Filter</span><span class="params">(content <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, filter := <span class="keyword">range</span> c.filters &#123;</span><br><span class="line">        <span class="comment">// 如果发现敏感直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> filter.Filter(content) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AdSensitiveWordFilter 广告</span></span><br><span class="line"><span class="keyword">type</span> AdSensitiveWordFilter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter 实现过滤算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *AdSensitiveWordFilter)</span> <span class="title">Filter</span><span class="params">(content <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实现算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoliticalWordFilter 政治敏感</span></span><br><span class="line"><span class="keyword">type</span> PoliticalWordFilter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter 实现过滤算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PoliticalWordFilter)</span> <span class="title">Filter</span><span class="params">(content <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实现算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式-state"><a href="#状态模式-state" class="headerlink" title="状态模式 state"></a>状态模式 state</h2><p>允许⼀个对象在其内部状态改变时改变它的行为。</p><p><strong>状态变成类</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231412401.png" alt="状态模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package state 状态模式</span></span><br><span class="line"><span class="comment">// 笔记请查看: https://lailin.xyz/state.html</span></span><br><span class="line"><span class="comment">// 这是一个工作流的例子，在企业内部或者是学校我们经常会看到很多审批流程</span></span><br><span class="line"><span class="comment">// 假设我们有一个报销的流程: 员工提交报销申请 -&gt; 直属部门领导审批 -&gt; 财务审批 -&gt; 结束</span></span><br><span class="line"><span class="comment">// 在这个审批流中，处在不同的环节就是不同的状态</span></span><br><span class="line"><span class="comment">// 而流程的审批、驳回就是不同的事件</span></span><br><span class="line"><span class="keyword">package</span> state</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine 状态机</span></span><br><span class="line"><span class="keyword">type</span> Machine <span class="keyword">struct</span> &#123;</span><br><span class="line">    state IState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetState 更新状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Machine)</span> <span class="title">SetState</span><span class="params">(state IState)</span></span> &#123;</span><br><span class="line">    m.state = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetStateName 获取当前状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Machine)</span> <span class="title">GetStateName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.state.GetName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Machine)</span> <span class="title">Approval</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.state.Approval(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Machine)</span> <span class="title">Reject</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.state.Reject(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IState 状态</span></span><br><span class="line"><span class="keyword">type</span> IState <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 审批通过</span></span><br><span class="line">    Approval(m *Machine)</span><br><span class="line">    <span class="comment">// 驳回</span></span><br><span class="line">    Reject(m *Machine)</span><br><span class="line">    <span class="comment">// 获取当前状态名称</span></span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leaderApproveState 直属领导审批</span></span><br><span class="line"><span class="keyword">type</span> leaderApproveState <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approval 获取状态名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(leaderApproveState)</span> <span class="title">Approval</span><span class="params">(m *Machine)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;leader 审批成功&quot;</span>)</span><br><span class="line">    m.SetState(GetFinanceApproveState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetName 获取状态名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(leaderApproveState)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;LeaderApproveState&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject 获取状态名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(leaderApproveState)</span> <span class="title">Reject</span><span class="params">(m *Machine)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLeaderApproveState</span><span class="params">()</span> <span class="title">IState</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;leaderApproveState&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// financeApproveState 财务审批</span></span><br><span class="line"><span class="keyword">type</span> financeApproveState <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approval 审批通过</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f financeApproveState)</span> <span class="title">Approval</span><span class="params">(m *Machine)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;财务审批成功&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;出发打款操作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f financeApproveState)</span> <span class="title">Reject</span><span class="params">(m *Machine)</span></span> &#123;</span><br><span class="line">    m.SetState(GetLeaderApproveState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetName 获取名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f financeApproveState)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;FinanceApproveState&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetFinanceApproveState GetFinanceApproveState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFinanceApproveState</span><span class="params">()</span> <span class="title">IState</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;financeApproveState&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器模式-iterator"><a href="#迭代器模式-iterator" class="headerlink" title="迭代器模式 iterator"></a>迭代器模式 iterator</h2><p>提供⼀种⽅法来顺序访问⼀个聚合对象中的各个元素而不需要暴露该对象的内部表示。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231412859.png" alt="迭代器模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 迭代器接口</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">    HasNext() <span class="keyword">bool</span></span><br><span class="line">    Next()</span><br><span class="line">    <span class="comment">// 获取当前元素，由于 Go 1.15 中还没有泛型，所以我们直接返回 interface&#123;&#125;</span></span><br><span class="line">    CurrentItem() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayInt 数组</span></span><br><span class="line"><span class="keyword">type</span> ArrayInt []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 返回迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ArrayInt)</span> <span class="title">Iterator</span><span class="params">()</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ArrayIntIterator&#123;</span><br><span class="line">        arrayInt: a,</span><br><span class="line">        index:    <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayIntIterator 数组迭代</span></span><br><span class="line"><span class="keyword">type</span> ArrayIntIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    arrayInt ArrayInt</span><br><span class="line">    index    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HasNext 是否有下一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *ArrayIntIterator)</span> <span class="title">HasNext</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> iter.index &lt; <span class="built_in">len</span>(iter.arrayInt)<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 游标加一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *ArrayIntIterator)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">    iter.index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CurrentItem 获取当前元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *ArrayIntIterator)</span> <span class="title">CurrentItem</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> iter.arrayInt[iter.index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="访问者模式-visitor"><a href="#访问者模式-visitor" class="headerlink" title="访问者模式 visitor"></a>访问者模式 visitor</h2><p>表示⼀个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231413188.png" alt="访问者模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;path&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor 访问者</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">    Visit(IResourceFile) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IResourceFile IResourceFile</span></span><br><span class="line"><span class="keyword">type</span> IResourceFile <span class="keyword">interface</span> &#123;</span><br><span class="line">    Accept(Visitor) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewResourceFile NewResourceFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourceFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="params">(IResourceFile, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> path.Ext(filepath) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;.ppt&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;PPTFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;.pdf&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;PdfFile&#123;path: filepath&#125;, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found file type: %s&quot;</span>, filepath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PdfFile PdfFile</span></span><br><span class="line"><span class="keyword">type</span> PdfFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PdfFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile PPTFile</span></span><br><span class="line"><span class="keyword">type</span> PPTFile <span class="keyword">struct</span> &#123;</span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept Accept</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *PPTFile)</span> <span class="title">Accept</span><span class="params">(visitor Visitor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> visitor.Visit(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compressor 实现压缩功能</span></span><br><span class="line"><span class="keyword">type</span> Compressor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit 实现访问者模式方法</span></span><br><span class="line"><span class="comment">// 我们可以发现由于没有函数重载，我们只能通过断言来根据不同的类型调用不同函数</span></span><br><span class="line"><span class="comment">// 但是我们即使不采用访问者模式，我们其实也是可以这么操作的</span></span><br><span class="line"><span class="comment">// 并且由于采用了类型断言，所以如果需要操作的对象比较多的话，这个函数其实也会膨胀的比较厉害</span></span><br><span class="line"><span class="comment">// 后续可以考虑按照命名约定使用 generate 自动生成代码</span></span><br><span class="line"><span class="comment">// 或者是使用反射简化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">Visit</span><span class="params">(r IResourceFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> f := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *PPTFile:</span><br><span class="line">        <span class="keyword">return</span> c.VisitPPTFile(f)</span><br><span class="line">    <span class="keyword">case</span> *PdfFile:</span><br><span class="line">        <span class="keyword">return</span> c.VisitPDFFile(f)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not found resource typr: %#v&quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPPTFile VisitPPTFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPPTFile</span><span class="params">(f *PPTFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is ppt file&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VisitPDFFile VisitPDFFile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Compressor)</span> <span class="title">VisitPDFFile</span><span class="params">(f *PdfFile)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is pdf file&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="备忘录模式-memento"><a href="#备忘录模式-memento" class="headerlink" title="备忘录模式 memento"></a>备忘录模式 memento</h2><p>在不破坏封装性的前提下，捕获⼀个对象的内部状态，并在该对象之外保存这个状态，从而可用在以后将该对象恢复到原先保存的状态。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231414592.png" alt="备忘录模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package memento 备忘录模式</span></span><br><span class="line"><span class="comment">// 下面这个例子采用原课程的例子，一个输入程序</span></span><br><span class="line"><span class="comment">// 如果输入 :list 则显示当前保存的内容</span></span><br><span class="line"><span class="comment">// 如果输入 :undo 则删除上一次的输入</span></span><br><span class="line"><span class="comment">// 如果输入其他的内容则追加保存</span></span><br><span class="line"><span class="keyword">package</span> memento</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputText 用于保存数据</span></span><br><span class="line"><span class="keyword">type</span> InputText <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append 追加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *InputText)</span> <span class="title">Append</span><span class="params">(content <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    in.content += content</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetText 获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *InputText)</span> <span class="title">GetText</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> in.content</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 创建快照</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *InputText)</span> <span class="title">Snapshot</span><span class="params">()</span> *<span class="title">Snapshot</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Snapshot&#123;content: in.content&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore 从快照中恢复</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *InputText)</span> <span class="title">Restore</span><span class="params">(s *Snapshot)</span></span> &#123;</span><br><span class="line">    in.content = s.GetText()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 快照，用于存储数据快照</span></span><br><span class="line"><span class="comment">// 对于快照来说，只能不能被外部（不同包）修改，只能获取数据，满足封装的特性</span></span><br><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetText GetText</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Snapshot)</span> <span class="title">GetText</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令模式-command"><a href="#命令模式-command" class="headerlink" title="命令模式 command"></a>命令模式 command</h2><p>将⼀个请求封装为⼀个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求⽇志，支持可撤销的操作。</p><p><strong>日志记录，可撤销</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231415154.png" alt="命令模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package command 命令模式</span></span><br><span class="line"><span class="comment">// Blog: https://lailin.xyz/post/command.html</span></span><br><span class="line"><span class="comment">// 这是示例一，采用将函数封装为对象的方式实现，</span></span><br><span class="line"><span class="comment">// 示例说明:</span></span><br><span class="line"><span class="comment">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span></span><br><span class="line"><span class="comment">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span></span><br><span class="line"><span class="comment">// 然后我们在另外一个 goroutine 中来执行它</span></span><br><span class="line"><span class="keyword">package</span> command</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ICommand 命令</span></span><br><span class="line"><span class="keyword">type</span> ICommand <span class="keyword">interface</span> &#123;</span><br><span class="line">    Execute() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StartCommand 游戏开始运行</span></span><br><span class="line"><span class="keyword">type</span> StartCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStartCommand NewStartCommand</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStartCommand</span><span class="params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="title">StartCommand</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StartCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *StartCommand)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;game start&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArchiveCommand 游戏存档</span></span><br><span class="line"><span class="keyword">type</span> ArchiveCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewArchiveCommand NewArchiveCommand</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArchiveCommand</span><span class="params">( /*正常情况下这里会有一些参数*/ )</span> *<span class="title">ArchiveCommand</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ArchiveCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute Execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ArchiveCommand)</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;game archive&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释器模式-interpreter"><a href="#解释器模式-interpreter" class="headerlink" title="解释器模式 interpreter"></a>解释器模式 interpreter</h2><p>给定⼀种语言，定义它的文法表示，并定义⼀个解释器，该解释器用来根据文法表示来解释语言中的句子。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231416104.png" alt="解释器模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package interpreter 解释器模式</span></span><br><span class="line"><span class="comment">// 采用原课程的示例, 并且做了一下简化</span></span><br><span class="line"><span class="comment">// 假设我们现在有一个监控系统</span></span><br><span class="line"><span class="comment">// 现在需要实现一个告警模块，可以根据输入的告警规则来决定是否触发告警</span></span><br><span class="line"><span class="comment">// 告警规则支持 &amp;&amp;、&gt;、&lt; 3种运算符</span></span><br><span class="line"><span class="comment">// 其中 &gt;、&lt; 优先级比  &amp;&amp; 更高</span></span><br><span class="line"><span class="keyword">package</span> interpreter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;regexp&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AlertRule 告警规则</span></span><br><span class="line"><span class="keyword">type</span> AlertRule <span class="keyword">struct</span> &#123;</span><br><span class="line">    expression IExpression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewAlertRule NewAlertRule</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAlertRule</span><span class="params">(rule <span class="keyword">string</span>)</span> <span class="params">(*AlertRule, error)</span></span> &#123;</span><br><span class="line">    exp, err := NewAndExpression(rule)</span><br><span class="line">    <span class="keyword">return</span> &amp;AlertRule&#123;expression: exp&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpret 判断告警是否触发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r AlertRule)</span> <span class="title">Interpret</span><span class="params">(stats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.expression.Interpret(stats)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IExpression 表达式接口</span></span><br><span class="line"><span class="keyword">type</span> IExpression <span class="keyword">interface</span> &#123;</span><br><span class="line">    Interpret(stats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GreaterExpression &gt;</span></span><br><span class="line"><span class="keyword">type</span> GreaterExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="keyword">string</span></span><br><span class="line">    value <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpret Interpret</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GreaterExpression)</span> <span class="title">Interpret</span><span class="params">(stats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    v, ok := stats[g.key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v &gt; g.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGreaterExpression NewGreaterExpression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreaterExpression</span><span class="params">(exp <span class="keyword">string</span>)</span> <span class="params">(*GreaterExpression, error)</span></span> &#123;</span><br><span class="line">    data := regexp.MustCompile(<span class="string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != <span class="number">3</span> || data[<span class="number">1</span>] != <span class="string">&quot;&gt;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;exp is invalid: %s&quot;</span>, exp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := strconv.ParseFloat(data[<span class="number">2</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;exp is invalid: %s&quot;</span>, exp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;GreaterExpression&#123;</span><br><span class="line">        key:   data[<span class="number">0</span>],</span><br><span class="line">        value: val,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LessExpression &lt;</span></span><br><span class="line"><span class="keyword">type</span> LessExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="keyword">string</span></span><br><span class="line">    value <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpret Interpret</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g LessExpression)</span> <span class="title">Interpret</span><span class="params">(stats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    v, ok := stats[g.key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v &lt; g.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLessExpression NewLessExpression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLessExpression</span><span class="params">(exp <span class="keyword">string</span>)</span> <span class="params">(*LessExpression, error)</span></span> &#123;</span><br><span class="line">    data := regexp.MustCompile(<span class="string">`\s+`</span>).Split(strings.TrimSpace(exp), <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != <span class="number">3</span> || data[<span class="number">1</span>] != <span class="string">&quot;&lt;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;exp is invalid: %s&quot;</span>, exp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := strconv.ParseFloat(data[<span class="number">2</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;exp is invalid: %s&quot;</span>, exp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;LessExpression&#123;</span><br><span class="line">        key:   data[<span class="number">0</span>],</span><br><span class="line">        value: val,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AndExpression &amp;&amp;</span></span><br><span class="line"><span class="keyword">type</span> AndExpression <span class="keyword">struct</span> &#123;</span><br><span class="line">    expressions []IExpression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interpret Interpret</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e AndExpression)</span> <span class="title">Interpret</span><span class="params">(stats <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, expression := <span class="keyword">range</span> e.expressions &#123;</span><br><span class="line">        <span class="keyword">if</span> !expression.Interpret(stats) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewAndExpression NewAndExpression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAndExpression</span><span class="params">(exp <span class="keyword">string</span>)</span> <span class="params">(*AndExpression, error)</span></span> &#123;</span><br><span class="line">    exps := strings.Split(exp, <span class="string">&quot;&amp;&amp;&quot;</span>)</span><br><span class="line">    expressions := <span class="built_in">make</span>([]IExpression, <span class="built_in">len</span>(exps))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, e := <span class="keyword">range</span> exps &#123;</span><br><span class="line">        <span class="keyword">var</span> expression IExpression</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> strings.Contains(e, <span class="string">&quot;&gt;&quot;</span>):</span><br><span class="line">            expression, err = NewGreaterExpression(e)</span><br><span class="line">        <span class="keyword">case</span> strings.Contains(e, <span class="string">&quot;&lt;&quot;</span>):</span><br><span class="line">            expression, err = NewLessExpression(e)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;exp is invalid: %s&quot;</span>, exp)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expressions[i] = expression</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;AndExpression&#123;expressions: expressions&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中介模式-mediator"><a href="#中介模式-mediator" class="headerlink" title="中介模式 mediator"></a>中介模式 mediator</h2><p>用⼀个中介对象来封装⼀系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。</p><p><strong>不直接引用</strong></p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202202231416106.png" alt="中介模式"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package mediator 中介模式</span></span><br><span class="line"><span class="comment">// 采用原课程的示例，并且做了一些裁剪</span></span><br><span class="line"><span class="comment">// 假设我们现在有一个较为复杂的对话框，里面包括，登录组件，注册组件，以及选择框</span></span><br><span class="line"><span class="comment">// 当选择框选择“登录”时，展示登录相关组件</span></span><br><span class="line"><span class="comment">// 当选择框选择“注册”时，展示注册相关组件</span></span><br><span class="line"><span class="keyword">package</span> mediator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 假设这表示一个输入框</span></span><br><span class="line"><span class="keyword">type</span> Input <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String String</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Input)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Selection 假设这表示一个选择框</span></span><br><span class="line"><span class="keyword">type</span> Selection <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Selected 当前选中的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Selection)</span> <span class="title">Selected</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button 假设这表示一个按钮</span></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">    onClick <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetOnClick 添加点击事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Button)</span> <span class="title">SetOnClick</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    b.onClick = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMediator 中介模式接口</span></span><br><span class="line"><span class="keyword">type</span> IMediator <span class="keyword">interface</span> &#123;</span><br><span class="line">    HandleEvent(component <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dialog 对话框组件</span></span><br><span class="line"><span class="keyword">type</span> Dialog <span class="keyword">struct</span> &#123;</span><br><span class="line">    LoginButton         *Button</span><br><span class="line">    RegButton           *Button</span><br><span class="line">    Selection           *Selection</span><br><span class="line">    UsernameInput       *Input</span><br><span class="line">    PasswordInput       *Input</span><br><span class="line">    RepeatPasswordInput *Input</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleEvent HandleEvent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialog)</span> <span class="title">HandleEvent</span><span class="params">(component <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.DeepEqual(component, d.Selection):</span><br><span class="line">        <span class="keyword">if</span> d.Selection.Selected() == <span class="string">&quot;登录&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;select login&quot;</span>)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;show: %s\n&quot;</span>, d.UsernameInput)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;show: %s\n&quot;</span>, d.PasswordInput)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> d.Selection.Selected() == <span class="string">&quot;注册&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;select register&quot;</span>)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;show: %s\n&quot;</span>, d.UsernameInput)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;show: %s\n&quot;</span>, d.PasswordInput)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;show: %s\n&quot;</span>, d.RepeatPasswordInput)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// others, 如果点击了登录按钮，注册按钮</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go的设计模式：❌指在Go中不常用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型&lt;ul&gt;
&lt;li&gt;单例模式：一个类只有一个实例&lt;ul&gt;
&lt;li&gt;饿汉：系统初始化时创建并初始化单例对象&lt;/li&gt;
&lt;li&gt;懒汉：调用实例时初始化单例对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工厂模式：使用共同接口创建对象&lt;/li&gt;
&lt;li&gt;建造者模式：与工厂不同在于，创建参数复杂的对象&lt;/li&gt;
&lt;li&gt;原型模式：利用已有对象复制的方式来创建新的对象 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构型&lt;ul&gt;
&lt;li&gt;代理模式：为其他对象提供⼀种代理以控制这个对象的访问 &lt;strong&gt;代理访问&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;桥接模式：将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化 &lt;strong&gt;抽象实现拆分独立&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;装饰模式：动态地给⼀个对象添加⼀些额外的职责 &lt;strong&gt;附加职责&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;适配器模式：将⼀个类的接口转换成用户希望得到的另⼀个接口 &lt;strong&gt;转换接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;门面模式：定义⼀个高层接口，为子系统中的⼀组接口提供一个一致的外观 &lt;strong&gt;对外统一接口&lt;/strong&gt; ❌&lt;/li&gt;
&lt;li&gt;组合模式：将对象组合成树型结构以表示”整体-部分”的层次结构 &lt;strong&gt;树型目录结构&lt;/strong&gt; ❌&lt;/li&gt;
&lt;li&gt;享元模式：提供支持大量细粒度对象共享的有效方法 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行为型&lt;ul&gt;
&lt;li&gt;观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新&lt;/li&gt;
&lt;li&gt;模板模式：定义⼀个操作中的算法骨架，而将⼀些步骤延迟到子类中，使得子类可以不改变⼀个算法的结构即可重新定义算法的某些特定步骤&lt;/li&gt;
&lt;li&gt;策略模式：定义⼀系列算法，把它们⼀个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化&lt;/li&gt;
&lt;li&gt;职责链模式：通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有⼀个对象处理这个请求 &lt;strong&gt;传递职责&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;状态模式：允许⼀个对象在其内部状态改变时改变它的行为&lt;/li&gt;
&lt;li&gt;迭代器模式：提供⼀种方法来顺序访问⼀个聚合对象中的各个元素而不需要暴露该对象的内部表示&lt;/li&gt;
&lt;li&gt;访问者模式：表示⼀个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 ❌&lt;/li&gt;
&lt;li&gt;备忘录模式：在不破坏封装性的前提下，捕获⼀个对象的内部状态，并在该对象之外保存这个状态，从而可用在以后将该对象恢复到原先保存的状态 ❌&lt;/li&gt;
&lt;li&gt;命令模式：将⼀个请求封装为⼀个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求⽇志，支持可撤销的操作 ❌&lt;/li&gt;
&lt;li&gt;解释器模式：给定⼀种语言，定义它的文法表示，并定义⼀个解释器，该解释器用来根据文法表示来解释语言中的句子 ❌&lt;/li&gt;
&lt;li&gt;中介模式：用⼀个中介对象来封装⼀系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Design Pattern" scheme="http://blog.sukiu.top/categories/Design-Pattern/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>模拟题</title>
    <link href="http://blog.sukiu.top/Algorithm/Simulation/"/>
    <id>http://blog.sukiu.top/Algorithm/Simulation/</id>
    <published>2022-02-18T02:33:30.000Z</published>
    <updated>2022-03-02T14:11:59.571Z</updated>
    
    <content type="html"><![CDATA[<p>一些经典模拟题</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/">【宫水三叶】使用「双栈」解决「究极表达式计算」问题</a></p></blockquote><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>对于「任何表达式」而言，都使用两个栈 <code>nums</code> 和 <code>ops</code>：</p><ul><li><code>nums</code> ： 存放所有的数字</li><li><code>ops</code> ：存放所有的数字以外的操作</li></ul><p>从前往后遍历字符，分情况讨论：</p><ul><li>空格 : 跳过（开始去除所有空格）</li><li><code>(</code> : 直接加入 <code>ops</code> 中，等待与之匹配的 <code>)</code></li><li><code>)</code> : 使用现有的 <code>nums</code> 和 <code>ops</code> 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 <code>nums</code></li><li>数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 <code>nums</code></li><li><code>+ - * / ^ %</code> : 需要将操作放入 <code>ops</code> 中。<strong>在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算）</strong>，使用现有的 <code>nums</code> 和 <code>ops</code> 进行计算，直到没有操作或者遇到左括号，计算结果放到 <code>nums</code></li></ul><p><strong>只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</strong> 是什么意思：<br>从前往后做，假设我们当前已经扫描到 <code>2 + 1</code> 了（此时栈内的操作为 <code>+</code> ）。</p><ol><li>如果后面出现的 <code>+ 2</code> 或者 <code>- 1</code> 的话，满足「栈内运算符」比「当前运算符」优先级高/同等，可以将 <code>2 + 1</code> 算掉，把结果放到 <code>nums</code> 中；</li><li>如果后面出现的是 <code>* 2</code> 或者 <code>/ 1</code> 的话，不满足「栈内运算符」比「当前运算符」优先级高/同等，这时候不能计算 <code>2 + 1</code>。</li></ol><blockquote><ul><li>由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 <code>nums</code> 添加一个 0</li><li>从理论上分析，<code>nums</code> 最好存放的是 <code>long</code>，而不是 <code>int</code>，可能存在 中间结果溢出</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; opMap = &#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                                      &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    stack&lt;ll&gt; nums;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; ops;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> || ops.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        ll b = nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        ll a = nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">char</span> op = ops.<span class="built_in">top</span>();</span><br><span class="line">        ops.<span class="built_in">pop</span>();</span><br><span class="line">        ll ans;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                ans = a + b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                ans = a - b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                ans = a * b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                ans = a / b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                ans = a % b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                ans = <span class="built_in">pow</span>(a, b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">push</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去除所有空格</span></span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="built_in">remove</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27; &#x27;</span>), s.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>);  <span class="comment">// 防止第一个数是负数</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ops.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;  <span class="comment">// 计算到最近的左括号</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">calc</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="number">0</span>, j;</span><br><span class="line">                    <span class="keyword">for</span> (j = i; j &lt; n &amp;&amp; s[j] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[j] &lt;= <span class="string">&#x27;9&#x27;</span>; j++)</span><br><span class="line">                        num = num * <span class="number">10</span> + (s[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.<span class="built_in">push</span>(num);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 新操作入栈，先计算栈内</span></span><br><span class="line">                    <span class="comment">// 只有满足栈内运算符高于或等于当前运算符才计算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.<span class="built_in">empty</span>() &amp;&amp; ops.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (opMap[ops.<span class="built_in">top</span>()] &lt; opMap[c]) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="built_in">calc</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.<span class="built_in">empty</span>()) <span class="built_in">calc</span>();</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h2><h3 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">sum</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=a.<span class="built_in">size</span>()<span class="number">-1</span>,j=b.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--,j--) &#123;</span><br><span class="line">        a[i]=(<span class="keyword">char</span>)(a[i]+(j&gt;=<span class="number">0</span>?b[j]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (a[i]-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">            a[i]=(<span class="keyword">char</span>)((a[i]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i) a[i<span class="number">-1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> a=<span class="string">&#x27;1&#x27;</span>+a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">differ</span><span class="params">(string a,string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>; <span class="comment">//标记符号</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">size</span>()==b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a,b);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>,j=b.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--,j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j&gt;=<span class="number">0</span>) b[i]=b[j];</span><br><span class="line">        <span class="keyword">else</span> b[i]=<span class="string">&#x27;0&#x27;</span>; <span class="comment">//给减数不足的位数补0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;<span class="comment">//模拟减法操作</span></span><br><span class="line">        <span class="keyword">if</span> (a[i]&gt;=b[i])</span><br><span class="line">            a[i]=a[i]-b[i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i]=a[i]-b[i]+<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            a[i<span class="number">-1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (a[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; a.<span class="built_in">size</span>()!=<span class="number">1</span>) &#123;<span class="comment">//去掉开头的0，如果全为0留一个</span></span><br><span class="line">        a.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) a=<span class="string">&#x27;-&#x27;</span>+a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">product</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string ans=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>,j=a.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=j;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">int</span> next=<span class="number">0</span>;<span class="comment">//表示进位</span></span><br><span class="line">        <span class="keyword">while</span> (t&gt;=<span class="number">0</span>)&#123;<span class="comment">//循环得出中间的数</span></span><br><span class="line">            <span class="keyword">int</span> mid=(b[i]-<span class="string">&#x27;0&#x27;</span>)*(a[t]-<span class="string">&#x27;0&#x27;</span>)+next;<span class="comment">//存储中间的乘积</span></span><br><span class="line">            tmp=(<span class="keyword">char</span>)(mid%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>)+tmp;</span><br><span class="line">            <span class="keyword">if</span> (mid&gt;=<span class="number">10</span>)<span class="comment">//乘积大于10则进位</span></span><br><span class="line">                next=mid/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> next=<span class="number">0</span>;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next!=<span class="number">0</span>) tmp=(<span class="keyword">char</span>)(next+<span class="string">&#x27;0&#x27;</span>)+tmp;<span class="comment">//如果循环结束进位不为0，则在前面补</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;cnt; k++)<span class="comment">//错位相加时补0</span></span><br><span class="line">            tmp=tmp+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans=<span class="built_in">sum</span>(ans,tmp);</span><br><span class="line">        tmp.<span class="built_in">clear</span>();<span class="comment">//将存储清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ans[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; ans.<span class="built_in">size</span>()!=<span class="number">1</span>)<span class="comment">//去掉前面多余的0</span></span><br><span class="line">        ans.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些经典模拟题&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Simulation" scheme="http://blog.sukiu.top/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>文件管理</title>
    <link href="http://blog.sukiu.top/Operating-System/File-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/File-Management/</id>
    <published>2022-01-21T06:40:38.000Z</published>
    <updated>2022-01-23T12:59:14.342Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统是操作系统中负责管理持久数据的子系统，即负责把用户的文件存到磁盘硬件中。</p><p>因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件是对长期存储介质的抽象。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://juejin.cn/post/6916446785775468557">理解文件系统 - 掘金</a></p></blockquote><h2 id="1、文件"><a href="#1、文件" class="headerlink" title="1、文件"></a>1、文件</h2><p>文件是⼀种抽象机制，它提供了⼀种在磁上保存信息而且方便以后读取的方法。<br>这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘⼯作方式等有关细节。</p><blockquote><p>win95、win98用的都是MS-DOS的文件系统，即FAT-16， win98扩展了FAT-16成为FAT-32。<br>较新版的操作系统NTFS，win8配备ReFS。微软优化FAT,叫作exFAT。<br>prog.c，圆点后面的部分称为文件扩展名。</p></blockquote><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul><li>字节结构：把文件看成字节序列为操作系统提供了最大的灵活度</li><li>记录序列：文件结构上的第⼀步改进，这种模型中，文件是具有固定长度记录的序列</li><li>树：文件在这种结构中由⼀棵记录树构成，每个记录不必具有相同的长度，记录的固定位置上有⼀个键字段。这棵树按“键”字段进行排序，从而可以对特定“键”进行快速查找。</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ol><li>普通文件</li><li>目录</li><li>字符特殊文件（UNIX）</li><li>块特殊文件（UNIX）</li></ol><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>除了文件名和数据外，文件还具有<strong>属性</strong>来对文件本身做更具体的描述，这类信息也称为<strong>元数据</strong>。<br>这些属性会存于文件结构中的某些区域中，具体要视该文件的类型而定。</p><p><strong>举例</strong>：</p><ul><li>创建时间、修改时间、存取时间、文件大小、当前大小、所有者等</li><li>保护：对文件的访问限制，谁可以访问文件</li><li>口令：访问文件需要的密码</li><li>只读标志、隐藏标志、系统标志（普通文件或系统文件）、加锁标志、存档标志</li><li>最大长度：文件可能增长到的字节数</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是<strong>存储信息并方便以后检索</strong>。对于存储和检索，不同系统提供了不同的操作。</p><p>文件系统大多都会提供如下的<strong>文件操作</strong>：</p><ul><li>create()：创建不包含任何数据的文件。</li><li>delte()：删除该文件以释放磁盘空间。</li><li>open()：在使用文件之前，先打开文件，目的是把文件属性和磁盘地址表装入内存，以便后续调用的快速访问。</li><li>close()：文件访问结束之后，关闭文件并释放内部空间表空间。</li><li>write()：向文件写数据，如果当前位置是文件尾，那么数据长度会增加；如果当前位置是其中某个位置，那么写入位置的数据将会被覆盖。</li><li>append()：相当于write()在尾部添加数据。</li><li>seek()：随机访问文件，需要指定相对于文件数据开始的位置。</li><li>getAttribute()：读取文件的属性。</li><li>setAttribute()：设置文件的属性。</li><li>rename()：重命名文件。</li></ul><p>一般来说，打开文件将会获得一个<strong>文件描述符</strong>(一个小整数)，通过文件描述符，就可以操作文件。</p><h2 id="2、目录"><a href="#2、目录" class="headerlink" title="2、目录"></a>2、目录</h2><p>文件系统通常提供目录或文件夹用于记录文件的位置，在很多操作系统中目录本身也是文件</p><p>现在的文件目录结构，大多采用文件树结构。<br>这里的路径，用<strong>路径名</strong>表示，分为<strong>绝对路径名</strong>和<strong>相对路径名</strong>，路径每往下一层，使用分隔符进行分隔。</p><p>分隔符视系统而定，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Windows：\usr\ast\maibox</span><br><span class="line">&gt; Linux: /usr/ast/mailbox</span><br><span class="line">&gt; MULTICS: &gt;usr&gt;ast&gt;mailbox</span><br></pre></td></tr></table></figure><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>对于目录，也提供了相应的操作：</p><ul><li>create(): 创建目录</li><li>delete(): 删除目录</li><li>opendir(): 打开目录</li><li>closedir(): 关闭目录，释放内部表空间</li><li>readdir(): 返回一个目录项，在内存中，以目录项来表达一个目录</li><li>rename(): 重命名</li><li>link(): 链接一个文件，之后能使同一个文件，能通过多个文件路径访问到(后续会提到)</li><li>unlink(): 解除文件的链接</li></ul><h2 id="3、文件系统"><a href="#3、文件系统" class="headerlink" title="3、文件系统"></a>3、文件系统</h2><p>以上内容是以用户（即使用者）的角度看待文件。<br>那么，从文件系统实现者的角度来看，文件系统应该如何实现？</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201232026680.png" style="zoom:67%;" /><p>文件系统存放在磁盘上，磁盘被划分为一个或者多个分区，每个分区中有一个独立的文件系统。<br>磁盘的0号扇区称为<strong>主引导记录（Master Boot Record, MBR）</strong>，用来引导计算机。<br>紧接着，是分区表，用来标记每个分区的起始和结束位置，表中的一个分区被标记为活动分区。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201232028987.png" style="zoom:50%;" /><blockquote><p>当计算机被引导时，BIOS读入并执行MBR。<br>MBR会确定活动分区，读入并执行它的<strong>引导块（boot block）</strong>。引导块中的程序将装载该分区中的系统。<br><strong>超级块</strong>（superblock）包含文件系统的所有关键参数，会被读入内存，其中的信用可用来确定文件系统的魔数、文件系统中的块的数量和其他重要的管理信息。</p><p>空闲块的信息可以用位图或者指针的形式指出，随后跟随的是一组i节点（一种数据结构，用来说明文件的方方面面）。最后，存放了所有其他的文件和目录。</p></blockquote><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配是把每个文件作为⼀连串连续数据块存储在磁盘</p><p><strong>优点：</strong></p><ul><li>实现简单，只需记住开始位置，文件的块数。</li><li>读操作性能好，单个操作就能从磁盘中读出整个文件。只需要一次寻找，之后不再有寻道和旋转延迟。</li></ul><p><strong>缺点：</strong></p><ul><li>尾部会浪费一些空间，以块为存储单位时，无论是否完全使用完块大小，都会占用整个块</li><li>需要知道文件的最终大小，然后，在维护的连续空闲表找到合适的位置存入文件，并且知道文件的最终大小这一问题不可回避。</li><li>随时间迁移，将会产生大量碎片块，使磁盘变得零碎，当一个较大的新文件要加入时，将找不到合适的连续位置，此时要压缩磁盘空间（把文件复制到新位置，以得到更多的连续空间），代价极高。</li></ul><blockquote><p>新建文件时要知道文件的最终大小，使得这一存储方式难以应用于实际场景，但是在一些情形下是可行的。</p><p>如在CD-ROM、DVD、BD（蓝光光盘）上，在它们的场景里，所有的文件的大小是事先知道的，并且在后续的使用中，这些文件的大小也不会改变。</p></blockquote><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>可以为每个文件构造磁盘块链表，每一块的第一个字指向下块，块的其他部分存放数据。</p><p><strong>优点：</strong></p><ul><li>不会因为磁盘碎片浪费存储空间，充分利用磁盘块。</li><li>只需要第一块的磁盘地址，就能找到其他的块。</li></ul><p><strong>缺点：</strong></p><ul><li>随机方法访问很慢，访问块n总是要先访问其面的n-1块。</li><li>指向下一块的指针占据了一些字节，每个磁盘块存储的字节数不再是2的整次幂，因大多数程序以长度为2的整次幂来读写磁盘块，降低了实际系统的运行效率。</li><li>要读出一个完成的文件块时，要从两个磁盘块中获得和拼接信息，带来额外的开销</li></ul><h4 id="内存中的表进行链表分配"><a href="#内存中的表进行链表分配" class="headerlink" title="内存中的表进行链表分配"></a>内存中的表进行链表分配</h4><p>弥补链表分配的不足，可以在内存中建立磁盘块的指针表。</p><p>表项中，使用一个特殊的标记（如-1）表示结束。这样，沿着表就可以文件的所有块。</p><p>这样的表也称为 <strong>FAT（File Allocation Table）</strong> 。</p><p><strong>优点：</strong></p><ul><li>整个块都可以存放数据。</li><li>随机访问也简单得多，虽然仍要顺着链表寻找偏移量（但减少了可能的寻到和旋转延迟）</li><li>不需要磁盘引用</li></ul><p><strong>缺点：</strong></p><ul><li>必须把整个表都放在内存中。假设1TB的磁盘和1KB的块大小，则表需要10亿项，每一项至少要3个字节，则表大小要占用2.4GB内存。因此FAT的应用场景有限，不太实用。</li></ul><h4 id="i-节点"><a href="#i-节点" class="headerlink" title="i 节点"></a>i 节点</h4><p>最普遍的方式，是为每个文件创建一个中数据结构以表示此文件的关键描述，这种数据结构也称为<strong>i节点（index-node）</strong>。</p><p>一个可能的inode结构，记录了文件属性，以及每个文件块对应的磁盘块地址，并能指向其他的inode来记录更多的存储数据。</p><p>这样的机制有很大的优势：</p><ul><li>给定inode，就能找到所有的文件块。</li><li>只有在文件打开时，inode才会存在于内存中，如果每个i节点有n字节，那么k个文件同时打开，inode总共占据kn字节，只需提前保留这么多的空间即可。也就是说，内存中inode占据的大小和文件大小无关，只和同时使用的文件数有关。</li><li>如果一个inode不够存储一个文件占用的所有磁盘块，可以通过最后一个地址之前其他inode得以解决。甚至可以指向其他存放地址的磁盘的磁盘块。</li></ul><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>在读文件之前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应的目录项。</p><ul><li>简单目录：包含固定大⼩的目录，在目录项中有磁盘地址和属性</li><li>采用i节点的系统：把文件属性存放在i节点中而不是目录项中。这种情形下，目录项会更短。</li></ul><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>共享文件与目录的联系称为⼀个链接（link）。<br>这样文件系统本身就是⼀个有向⽆环图（DAG），而不是⼀棵树。</p><ul><li>硬链接：指向目标数据对象的链接，<strong>可以看作是一个既有文件的别名</strong></li></ul><blockquote><p>当目标被删除时，硬链接继续存在，且可以正常打开、编辑。因为他具备一个完整的文件结构。</p><p>当硬链接被删除时，目标文件继续存在，不受影响。</p><p>只有当一个文件 ID 对应的所有硬链接被删除时，数据才真正被标记为删除。</p></blockquote><ul><li>符号链接：指向目标路径的链接，会跳转到符号链接所指向的目标中去，而不改变此时的文件路径</li></ul><blockquote><p>当目标被删除时，符号链接继续存在，但会成为死链，无法打开。</p><p>当符号链接被删除时，它指向的目标不受影响。</p></blockquote><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>将多个文件系统整合到⼀个统⼀的结构中。</p><blockquote><p>⼀个Linux系统可以用<code>ext2</code>作为根文件系统，<code>ext3</code>分区装载在<code>/usr</code>下，另⼀块采用ReiserFS文件系统的硬盘装载在<code>/home</code>下，以及⼀个ISO 9660的CD-ROM临时装载在<code>/mnt</code>下。</p></blockquote><p>从用户的观点来看，只有⼀个文件系统层级。但它们事实上是多种文件系统，对于用户和进程是不可见的。</p><p>绝大多数Unix操作系统都在使用虚拟文件系统（VirtualFile System, VFS）</p><h3 id="文件系统面对的问题"><a href="#文件系统面对的问题" class="headerlink" title="文件系统面对的问题"></a>文件系统面对的问题</h3><h4 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h4><p>几乎所有的文件系统将文件分割成固定大小的块来存储，各块之间不一定相邻。</p><h5 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h5><p>块大小将直接影响此消彼长的两个指标<strong>空间利用率</strong>和<strong>磁盘数据率</strong>。</p><blockquote><p>从历史的观点上来说，文件系统将大⼩设在1~4KB之间。</p><p>但现在随着磁盘超过了1TB，还是将块的大⼩提升到64KB 并且接受浪费的磁盘孔空间，这样也许更好。磁盘空间⼏乎不再会短缺。</p></blockquote><h5 id="空闲块记录"><a href="#空闲块记录" class="headerlink" title="空闲块记录"></a>空闲块记录</h5><p>确定了块大小，需要考虑空闲块如何记录。</p><ul><li>链表记录：链表的每个块中包含尽可能多的空闲磁盘块号。（通常情况下，采用空闲块存放空闲表，这样不会影响存储器）</li><li>位图记录：在位图中，空闲块用1表示，已分配块用0表示。</li></ul><h5 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h5><p>做磁盘备份主要是处理好两个潜在问题中的⼀个：</p><ol><li>从意外的灾难中恢复</li><li>从错误的操作中恢复</li></ol><p>将文件从磁盘转储到磁带，有两种方法，<strong>物理转储</strong>和<strong>逻辑转储</strong>。</p><h4 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h4><p>文件进行修改后，需将所有的修改都写回磁盘，如果在所有的磁盘块都写回磁盘前，系统崩溃，一些被修改的信息可能未被写回磁盘，那么文件系统将不一致。</p><p>因此，文件系统一般都有独立的程序可检查其一致性。</p><p>致性检查分为两种<strong>块的一致性检查</strong>和<strong>文件的一致性检查</strong></p><h4 id="文件系统的性能"><a href="#文件系统的性能" class="headerlink" title="文件系统的性能"></a>文件系统的性能</h4><p>磁盘访问的速度比内存访问的速度慢得多，如果每次读文件时，都从磁盘块中读取，那么IO时间将是大大拖累程序效率。</p><p>主要通过以下方法提高性能：</p><ul><li>高速缓存：减少磁盘访问次数技术是块高速缓存（block cache）或者缓冲区高速缓存（buffer cache）</li><li>块预读：在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。</li><li>减少磁盘臂运动：把可能顺序访问的块放⼀起，当然最好是同⼀柱面上，从而减少磁盘臂的移动次数。</li><li>磁盘碎片整理：移动文件使它们相邻，并把所有的空闲空间放在⼀个或多个大的连续区域内。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件系统是操作系统中负责管理持久数据的子系统，即负责把用户的文件存到磁盘硬件中。&lt;/p&gt;
&lt;p&gt;因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p&gt;
&lt;p&gt;文件是对长期存储介质的抽象。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="File" scheme="http://blog.sukiu.top/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>设备管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Device-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/Device-Management/</id>
    <published>2022-01-21T06:27:49.000Z</published>
    <updated>2022-01-22T05:12:23.211Z</updated>
    
    <content type="html"><![CDATA[<p>磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。</p><p>早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。</p><p>电脑外设就是除主机外的大部分硬件设备都可称作外部设备，或叫外围设备，简称外设。<br>计算机系统没有输入输出设备，就如计算机系统没有软件一样，是毫无意义的。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/or7mr5/">设备管理 - 力扣</a></p></blockquote><h2 id="1、磁盘"><a href="#1、磁盘" class="headerlink" title="1、磁盘"></a>1、磁盘</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211431280.png"  /><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。</p><p>缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。</p><p>如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。</p><p>具体来说，两端的磁道请求更容易出现饥饿现象。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png" alt="image" style="zoom:80%;" /><h4 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h4><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png" alt="image" style="zoom:80%;" /><h2 id="2、外设"><a href="#2、外设" class="headerlink" title="2、外设"></a>2、外设</h2><h3 id="如何让外设动起来"><a href="#如何让外设动起来" class="headerlink" title="如何让外设动起来"></a>如何让外设动起来</h3><ol><li>CPU 向外设的控制器发送指令，即 out 指令</li><li>形成 ⽂件视图（为了统⼀ out 指令的形式）</li><li>中断（外设处理完事后，需要通知 cpu 继续接手下⼀步处理）</li></ol><h3 id="显示器如何工作"><a href="#显示器如何工作" class="headerlink" title="显示器如何工作"></a>显示器如何工作</h3><blockquote><p>Printf 函数的工作流程</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211437690.png" alt="image-20220121143755635" style="zoom: 67%;" /><h3 id="键盘如何工作"><a href="#键盘如何工作" class="headerlink" title="键盘如何工作"></a>键盘如何工作</h3><ol><li>中断处理（根据扫描码获取 对应的 ascii 码）</li><li>将对应的 ascii 码加入缓冲队列 read_que 中，等待上层程序调用</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;磁盘是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失。&lt;/p&gt;
&lt;p&gt;早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。&lt;/p&gt;
&lt;p&gt;电脑外设就是除主机外的大部分硬件设备都可称作外部设备，或叫外围设备，简称外设。&lt;br&gt;计算机系统没有输入输出设备，就如计算机系统没有软件一样，是毫无意义的。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Device" scheme="http://blog.sukiu.top/tags/Device/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Memory-Management/"/>
    <id>http://blog.sukiu.top/Operating-System/Memory-Management/</id>
    <published>2022-01-21T05:20:42.000Z</published>
    <updated>2022-01-21T06:23:25.574Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。<br>其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p><p>虚拟内存是内存管理技术的一个极其实用的创新。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/ool031/">内存管理 - leetcode</a></p></blockquote><h2 id="1、页面置换算法"><a href="#1、页面置换算法" class="headerlink" title="1、页面置换算法"></a>1、页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。<br>此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。<br>在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="最佳置换-OPT"><a href="#最佳置换-OPT" class="headerlink" title="最佳置换 OPT"></a>最佳置换 OPT</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><blockquote><p>三个物理块：</p><p>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</p><p>开始运行时，先将 7, 0, 1 三个页面装入内存。</p><p>当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p></blockquote><h3 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出 FIFO"></a>先进先出 FIFO</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3 id="最近最久未使用-LRU"><a href="#最近最久未使用-LRU" class="headerlink" title="最近最久未使用 LRU"></a>最近最久未使用 LRU</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><blockquote><p>4，7，0，7，1，0，1，2，1，2，6 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211358376.png"  /></p></blockquote><h3 id="最近未使用-NRU"><a href="#最近未使用-NRU" class="headerlink" title="最近未使用 NRU"></a>最近未使用 NRU</h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。</p><p>可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3 id="第二次机会"><a href="#第二次机会" class="headerlink" title="第二次机会"></a>第二次机会</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><ul><li>当页面被访问 (读或写) 时设置该页面的 R 位为 1。</li><li>需要替换的时候，检查最老页面的 R 位：<ul><li>如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉</li><li>如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211402284.png"  /><h3 id="时钟-Clock"><a href="#时钟-Clock" class="headerlink" title="时钟 Clock"></a>时钟 Clock</h3><p>第二次机会算法需要在链表中移动页面，降低了效率。</p><p>时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201211400217.png"  /><h2 id="2、分段"><a href="#2、分段" class="headerlink" title="2、分段"></a>2、分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>如果使用分页系统的⼀维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，⼀个段构成⼀个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png" /><h3 id="纯分段"><a href="#纯分段" class="headerlink" title="纯分段"></a>纯分段</h3><p>分段和分页本质上是不同的，页面是定长的而段不是。</p><p>优点：</p><ul><li>共享：有助于几个进程之间共享过程和数据。 比如共享库</li><li>保护：每个段都可以独立地增大或减小而不会影响其他的段</li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。</p><p>这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分段与分页的比较"><a href="#分段与分页的比较" class="headerlink" title="分段与分页的比较"></a>分段与分页的比较</h3><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：</p><ul><li>分页主要用于实现虚拟内存，从而获得更大的地址空间；</li><li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul></li></ul><h2 id="3、虚拟内存"><a href="#3、虚拟内存" class="headerlink" title="3、虚拟内存"></a>3、虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>属于计算机系统内存管理的⼀种技术，虚拟地址空间构成虚拟内存，它使得应用程序认为自己拥有连续的可用内存空间，但实际上是被分隔的多个物理内存页、以及部分暂时存储在磁盘上的交换分区所构成的。</p><p>虚拟内存的实现通过硬件异常、硬件地址翻译、主存、磁盘以及内核软件共同完成。</p><blockquote><p>地址空间：是物理内存的抽象，是⼀个进程可用于寻址内存的⼀套地址集合</p><p>分页：地址空间被分割成多个块，每⼀块称作⼀页或页面(Page)。每⼀页有连续的地址范围，这些页被映射到连续的物理内存(页框)。</p><p>页表：把虚拟页面(虚拟地址)映射为页框(物理地址)。页表给出了虚拟地址与物理地址的映射关系。从数学的角度说页表是⼀个函数，他的参数是虚拟页号，结果是物理页页框号</p></blockquote><blockquote><p>虚拟内存的思想，整体来看就是：</p><p>通过结合磁盘和内存各自的优势，利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统⼀的抽象。</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h4><p>将虚拟地址直接映射到物理地址，而不必再访问页表，这种设备被称为转换检测缓冲区（TLB）、相联存储器或快表</p><p>⼯作过程：将⼀个虚拟地址放⼊MMU（内存管理单元）中进行转换时，硬件首先通过将该虚拟页号与 TLB 中所有表项同时进行匹配，</p><p>判断虚拟页面是否在其中：</p><ol><li>虚拟页号在TLB中。如果MMU检测⼀个有效的匹配并且访问操作并不违反保护位，则将页框号直接从 TLB 中取出而不必访问页表。</li><li>虚拟页号不在TLB中。如果MMU检测到没有有效的匹配项就会进行正常的页表查询。接着从 TLB 中淘汰⼀个表项，然后用新的页表项替换它。</li></ol><h4 id="加大"><a href="#加大" class="headerlink" title="加大"></a>加大</h4><ul><li><p>多级页表</p></li><li><p>倒排页表</p></li></ul><h3 id="重要能力"><a href="#重要能力" class="headerlink" title="重要能力"></a>重要能力</h3><ul><li>高速缓存</li><li>内存管理</li><li>内存保护：如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存管理是指软件运行时对计算机内存资源的分配和使用的技术。&lt;br&gt;其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。&lt;/p&gt;
&lt;p&gt;虚拟内存是内存管理技术的一个极其实用的创新。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Memory" scheme="http://blog.sukiu.top/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://blog.sukiu.top/Algorithm/All-Sort/"/>
    <id>http://blog.sukiu.top/Algorithm/All-Sort/</id>
    <published>2022-01-19T13:36:14.000Z</published>
    <updated>2022-02-22T04:45:37.746Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><span id="more"></span><blockquote><p>稳定性是指排序过程中，原来相同的元素保持原来的相对位置<br>比如 a[i] = a[j] ，且 i&lt;j , 排序后 i&lt;j 依然成立</p></blockquote><h2 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h2><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="(1) 直接插入排序"></a>(1) 直接插入排序</h3><blockquote><p>时间复杂度：O(n^2)，最好 O(n)<br>空间复杂度：O(1)<br>稳定性：稳定</p></blockquote><ul><li>思路：<br>  将开头元素视作已排序<br>  执行下述过程，直到未排序过程消失：</li></ul><ol><li>取出未排序部分的开头元素赋给变量 v</li><li>在已排序部分，将所有比 v 大的元素向后移动一位</li><li>将已取出的元素 v 插入空位</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192140735.png" style="zoom: 67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; v&lt;a[j];j--)</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j]; <span class="comment">// 后移</span></span><br><span class="line">        a[j+<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="(2) 希尔排序"></a>(2) 希尔排序</h3><blockquote><p>时间复杂度：平均 O(n^1.3)，最坏 O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p><strong>缩小增量法</strong></p><ul><li><p>n 个记录，增量为 di，则分组</p><ul><li><p>下标 0, di, 2di, 3di, …… 为 1 组</p></li><li><p>下标 1, di +1, 2di +1, 3di +1, …… 为 1 组</p></li><li><p>下标 2, di +2, 2di +2, 3di +2, …… 为 1 组</p></li><li><p>…… …… …… ……</p></li><li><p>下标 di-1, di+di -1, 2di+di -1, …… 为 1 组</p></li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192141773.png" style="zoom: 80%;"  ><p>思路：</p><ul><li><p>增量为 d1 时，在各组内，进行排序</p></li><li><p>减小增量，重新分组，组内排序</p><ul><li>减小增量：初始：d1 = n/2，则模式：di+1 = di /2</li></ul></li><li><p>重复第 2 步， 直到 di==1，所有记录在同一组，组内排序</p><ul><li>排序均为直接插入排序</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192141543.png" style="zoom:67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 按照 ShellSort 定义写出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, gap;</span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gap; i++)                   <span class="comment">// 分组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + gap; j &lt; n; j += gap)  <span class="comment">// 组内插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - gap]) &#123;            <span class="comment">// 直接插入排序</span></span><br><span class="line">                    <span class="keyword">int</span> v = a[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j - gap; k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; v; k -= gap)</span><br><span class="line">                        a[k + gap] = a[k];  <span class="comment">// 后移</span></span><br><span class="line">                    a[k + gap] = v;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 优化</span></span><br><span class="line"><span class="comment">// - 上述 i 的作用是为了确认 j 的位置，并与组内元素比较</span></span><br><span class="line"><span class="comment">// - 明显每次 gap 与 j-gap 就是组内比较，不需要再分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, gap;</span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = gap; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - gap]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = a[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j - gap; k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; v; k -= gap)</span><br><span class="line">                    a[k + gap] = a[k];  <span class="comment">// 后移</span></span><br><span class="line">                a[k + gap] = v;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、交换排序"><a href="#2、交换排序" class="headerlink" title="2、交换排序"></a>2、交换排序</h2><h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="(3) 冒泡排序"></a>(3) 冒泡排序</h3><blockquote><p>时间复杂度：平均 O(n^2)，最坏 O(n^2)，最好 O(n)<br>空间复杂度：O(1)<br>稳定性：稳定</p></blockquote><ul><li>思路：<br>  重复执行下述处理，直到数组中不包含顺序相反的相邻元素：<br>  1、从数组开头开始依次比较相邻两个元素，如果大小关系相反则交换位置</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192140973.png" style="zoom:67%;" ><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4) 快速排序"></a>(4) 快速排序</h3><blockquote><p>时间复杂度：平均 O(nlogn)，最坏 O(n^2)<br>空间复杂度：平均 O(logn)，最坏 O(n)<br>稳定性：不稳定</p></blockquote><ul><li><p>思路：<br>  以整个数组为对象执行 QuickSort<br>  QuickSort 流程如下：<br>  1、通过分割将对象局部数组分割为前后两个局部数组<br>  2、对前半部分的局部数组执行 QuickSort<br>  3、对后半部分的局部数组执行 QuickSort</p></li><li><p>第 1 趟快排：</p><ul><li><p>从待排序码中，选出 1 个 K（如 R0.key ）</p><ul><li>将小于 k 的记录移动到左边（左子表），</li><li>大于 k 的记录移动到右边（右子表），</li><li>将 k 放在左、右两个子表的分界处</li></ul></li><li><p>左游历下标：i=0， 右游历下标：j=n-1,<br>  取出分区基准：temp=R[0]</p><ul><li>初始空位 R[0]：在左表中，即 R[i]</li></ul></li><li><p>重复以下两种扫描，<strong>直到 i==j （空位置在左，则 j 扫描；空位置在右，则 i 扫描)</strong></p><ul><li>j 向左扫描，直到 R[j].key &lt; temp.key，<br>  将 R[j]移动到空位 R[i]中，则 R[j]为空，令 i++</li><li>i 向右扫描，直到 R[i].key &gt; temp.key，<br>  将 R[i]移动到空位 R[ j]中，则 R[i]为空，令 j - -</li></ul></li><li><p>将“分区基准” temp，放到空位 R[i]中</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192143880.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192144818.png" style="zoom:50%;" ></li></ul></li></ul></li><li><p>第 2 趟快排：</p><ul><li>对 K 左、右两个字表，分别执行 1 趟快排 - 4 个子表<br>  … …</li></ul></li><li><p>直到：各子表长度 ≤1</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192148803.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192149615.png" style="zoom:50%;" ></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192149319.png" style="zoom:50%;" ></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 快排划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = a[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;                      <span class="comment">// l != r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[r] &gt;= p) --r;  <span class="comment">// r 向左扫描</span></span><br><span class="line">        a[l] = a[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] &lt;= p) ++l;  <span class="comment">// l 向右扫描</span></span><br><span class="line">        a[r] = a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l] = p;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">Partition</span>(a, l, r);</span><br><span class="line">        <span class="built_in">QuickSort</span>(a, l, p - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(a, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 三数取中优化，此版本快的飞起</span></span><br><span class="line"><span class="comment">// https://www.cnblogs.com/chengxiao/p/6262208.html</span></span><br><span class="line"><span class="comment">// - 左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; mid) i++;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; mid) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; j) <span class="built_in">QuickSort</span>(a, l, j);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r) <span class="built_in">QuickSort</span>(a, i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;string&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    string m = nums[l + ((r - l) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] + m &lt; m + nums[i]) i++;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] + m &gt; m + nums[j]) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; j) <span class="built_in">qsort</span>(nums, l, j);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r) <span class="built_in">qsort</span>(nums, i, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h2><h3 id="5-简单选择排序"><a href="#5-简单选择排序" class="headerlink" title="(5) 简单选择排序"></a>(5) 简单选择排序</h3><blockquote><p>时间复杂度：平均 O(n^2)，最坏 O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p>思路：</p><ul><li>重复执行 N-1 次 下述处理：<ol><li>找出未排序部分最小值的位置 minj</li><li>将 minj 位置的元素与未排序部分的起始元素交换</li></ol></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192152371.png" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j]&lt;a[k]) k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i!=k) <span class="built_in">swap</span>(a[i],a[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="(6) 堆排序"></a>(6) 堆排序</h3><blockquote><p>时间复杂度：平均 O(nlogn)，最坏 O(nlogn)，最好 n(nlogn)<br>空间复杂度：O(1)<br>稳定性：不稳定</p></blockquote><p>思路：</p><ul><li><p>将待排序数据建立成大根堆</p><ul><li><p>将待排序记录建成 1 个完全二叉树（<strong>从左往右</strong>插入），再“<strong>从后向前</strong>”依次调整 sift</p>  <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192153994.png" style="zoom:50%;" />  <ul><li>sift（待调整：x）：<strong>就是让其满足大根堆</strong><ul><li>判断“待调整 x”是否 &gt;左孩子 &amp;&amp; &gt;右孩子<ul><li>是，则无需调整，结束</li><li>否，继续“调整 x”，即：重复，直到 x 与孩子满足堆序性，或 x 成为叶子</li></ul></li></ul></li><li>从<strong>最后结点的父亲</strong>开始，最后结点下标：n-1 父亲下标 p= (n-1-1)/2<ul><li>“从后向前”：依次调整 p, p-1, p-2, …, 0 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192154341.png" style="zoom:50%;" /><ul><li>之后 sift (3)，sift(2)，sift(1)，sift(0)，构成大根堆</li></ul></li></ul></li></ul></li></ul></li><li><p>重复：选出最大值（堆顶）、并<strong>调整</strong>剩余部分（<strong>较大的孩子上升，空位置下降</strong></p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192154904.png" style="zoom: 33%;" /></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155185.png" style="zoom: 50%;" /></li><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155222.png" style="zoom: 50%;" /></li><li><p>以此类推，直到堆无剩余元素</p><ul><li><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192155994.png" style="zoom:50%;" /></li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - 图解 https://www.cnblogs.com/chengxiao/p/6129630.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 调整以 k 为根的子树，即 shift 操作</span></span><br><span class="line"><span class="comment">// - 大孩子上升，空位置下降</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  如果左子结点小于右子结点，i指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; a[i] &lt; a[i + <span class="number">1</span>]) i++;</span><br><span class="line">        <span class="comment">//  如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; t) &#123;</span><br><span class="line">            a[k] = a[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[k] = t;  <span class="comment">// t 放在最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// - 建立大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">HeadAdjust</span>(a, i, len);</span><br><span class="line">    <span class="comment">// - 交换堆顶堆低元素 + 调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">HeadAdjust</span>(a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、其他排序"><a href="#4、其他排序" class="headerlink" title="4、其他排序"></a>4、其他排序</h2><h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="(7) 归并排序"></a>(7) 归并排序</h3><blockquote><p>时间复杂度： O(nlogn) (好、坏、平均)<br>空间复杂度：O(n)<br>稳定性：稳定</p></blockquote><p>思路：</p><p>以整个数组为对象执行 mergeSort</p><ul><li>mergeSort：<ol><li>将给定包含 n 个元素的局部数组分割成两个局部数组</li><li>对局部数组分别 mergeSort</li><li>通过 merge 将两个已排序的数组整合为一个数组</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = begin, right = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - begin + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//顺序选取两个有序区的较小元素，存储到t数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="comment">//较小的先存入temp中</span></span><br><span class="line">        <span class="keyword">if</span> (a[left] &lt;= a[right])</span><br><span class="line">            temp[k++] = a[left++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = a[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若比较完之后，有序区仍有剩余，则直接复制到t数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) temp[k++] = a[left++];</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= end) temp[k++] = a[right++];</span><br><span class="line">    <span class="comment">//将排好序的存回arr中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin, k = <span class="number">0</span>; i &lt;= end; i++, k++) a[i] = temp[k];</span><br><span class="line">    <span class="comment">//删除指针，释放空间</span></span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(a, begin, mid);    <span class="comment">// 左侧递归</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a, mid + <span class="number">1</span>, end);  <span class="comment">// 右侧递归</span></span><br><span class="line">        <span class="built_in">Merge</span>(a, begin, mid, end);   <span class="comment">// 归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>, begin, mid, end;</span><br><span class="line">    <span class="keyword">while</span> (size &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin + size &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            mid = begin + size - <span class="number">1</span>;</span><br><span class="line">            end = mid + size;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; n - <span class="number">1</span>)  <span class="comment">//第二个序列个数不足size</span></span><br><span class="line">                end = n - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Merge</span>(a, begin, mid, end);</span><br><span class="line">            begin = end + <span class="number">1</span>;  <span class="comment">//下一次归并时第一关序列的下界</span></span><br><span class="line">        &#125;</span><br><span class="line">        size *= <span class="number">2</span>;  <span class="comment">//扩大范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="(8) 基数排序"></a>(8) 基数排序</h3><blockquote><p>时间复杂度： O(d(n+r)) d: d 趟分配和收集<br>空间复杂度：O(r) r: r 个队列<br>稳定性：稳定</p></blockquote><p><strong>看图理解：</strong> <img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" style="zoom:67%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 辅助函数，求数据的最大位数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> maxData = data[<span class="number">0</span>];  <span class="comment">///&lt; 最大数  </span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i]) maxData = data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p) &#123;  </span><br><span class="line">        <span class="comment">// p *= 10; // Maybe overflow  </span></span><br><span class="line">        maxData /= <span class="number">10</span>;  </span><br><span class="line">        ++d;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> d;  </span><br><span class="line"> <span class="comment">/*    </span></span><br><span class="line"><span class="comment"> int d = 1; //保存最大的位数  </span></span><br><span class="line"><span class="comment"> int p = 10;  </span></span><br><span class="line"><span class="comment"> for(int i = 0; i &lt; n; ++i)&#123;  </span></span><br><span class="line"><span class="comment"> while(data[i] &gt;= p)&#123;  </span></span><br><span class="line"><span class="comment"> p *= 10;  </span></span><br><span class="line"><span class="comment"> ++d;  </span></span><br><span class="line"><span class="comment"> &#125;  </span></span><br><span class="line"><span class="comment"> &#125;  </span></span><br><span class="line"><span class="comment"> return d;</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ? 基数排序  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(data, n);  </span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//计数器  </span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= d; i++)  <span class="comment">//进行d次排序  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) count[j] = <span class="number">0</span>;  <span class="comment">//每次分配前清空计数器  </span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;  <span class="comment">//统计每个桶中的记录数  </span></span><br><span class="line">            count[k]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)  </span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j];  <span class="comment">//将tmp中的位置依次分配给每个桶  </span></span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//将所有桶中记录依次收集到tmp中  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;  </span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];  </span><br><span class="line">            count[k]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)  <span class="comment">//将临时数组的内容复制到data中  </span></span><br><span class="line">            data[j] = tmp[j];  </span><br><span class="line">        radix = radix * <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">delete</span>[] tmp;  </span><br><span class="line">    <span class="keyword">delete</span>[] count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、排序比较"><a href="#5、排序比较" class="headerlink" title="5、排序比较"></a>5、排序比较</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192157440.png" style="zoom:50%;" /><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201192203045.png" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Sort" scheme="http://blog.sukiu.top/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://blog.sukiu.top/Language/Language-Golang/"/>
    <id>http://blog.sukiu.top/Language/Language-Golang/</id>
    <published>2022-01-19T07:30:14.000Z</published>
    <updated>2022-01-25T09:35:59.305Z</updated>
    
    <content type="html"><![CDATA[<p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://time.geekbang.org/column/intro/100093501?tab=catalog">Tony Bai · Go 语言第一课</a><br><a href="https://github.com/unknwon/the-way-to-go_ZH_CN">GitHub - unknwon/the-way-to-go_ZH_CN: 《The Way to Go》中文译本，中文正式名《Go 入门指南》</a><br><a href="https://learnku.com/docs/build-web-application-with-golang/about-this-book/3151">《Go Web 编程》| Go 技术论坛</a></p></blockquote><h2 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Go 是一门类似 C 的编译型语言，但是它的编译速度非常快。</p><p>这门语言的关键字总共也就二十五个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>    <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>    <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>     <span class="keyword">defer</span>        <span class="keyword">go</span>      <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>     <span class="keyword">else</span>         <span class="keyword">goto</span>    <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>    <span class="keyword">fallthrough</span>  <span class="keyword">if</span>      <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span> <span class="keyword">for</span>          <span class="keyword">import</span>  <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为<strong>变量</strong>。</p><p>声明变量的一般形式是使用 <code>var</code> 关键字：<code>var identifier type</code></p><blockquote><p>变量的类型放在变量的名称之后，是为了避免像 C 语言中那样含糊不清的声明形式。</p><p>C++：int* a, b;     // a 是指针，b 不是</p><p>Go：var a,b *int    // a，b 都是指针</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因式分解关键字的写法，一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明与赋值（初始化）语句也可以组合起来</span></span><br><span class="line"><span class="keyword">var</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">5</span> <span class="comment">// 自动推断</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;Go says hello to the world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短变量声明，用于函数体内声明局部变量</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">a, b, c := <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">a, b = b, a  <span class="comment">// 相当于C++中的 swap(a,b)</span></span><br></pre></td></tr></table></figure><blockquote><p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写</p><p>如果全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写</p></blockquote><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul><li>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值</li><li>像数组和结构体这些复合类型也是值类型</li><li>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝</li><li>可以通过 <code>&amp;i</code> 来获取变量 i 的内存地址（每次的地址都可能不一样），值类型的变量的值存储在栈中</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置（这个内存地址被称之为指针）</li><li>在 Go 语言中，指针、slices（切片）、maps 和 channel 都属于引用类型</li><li>当使用赋值语句 <code>r2 = r1</code> 时，只有引用（地址）被复制</li><li>当 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容</li><li>被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Go 语言的常量是一种在源码编译期间被创建的语法元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="keyword">float64</span> = <span class="number">3.14159265358979323846</span> <span class="comment">// 单行常量声明，显示</span></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14159</span> <span class="comment">// 隐式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以const代码块形式声明常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    size <span class="keyword">int64</span> = <span class="number">4096</span></span><br><span class="line">    i, j, s = <span class="number">13</span>, <span class="number">14</span>, <span class="string">&quot;bar&quot;</span> <span class="comment">// 单行声明多个常量</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>常量的类型只局限于基本数据类型，包括数值类型、字符串类型、布尔类型</p></blockquote><p>Go 语言在常量方面的创新包括下面这几点：</p><ul><li><p>支持无类型常量：</p><p>  可以不显示指定类型，比如 <code>const n = 13</code></p></li><li><p>支持隐式自动转型：</p><p>  对于无类型常量参与的表达式求值，Go 编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的</p></li><li><p>可用于实现枚举：</p><ul><li><p>隐式重复前一个非空表达式</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span> <span class="comment">// 使用上一行的初始化表达式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>iota 是一个预定义标识符，可以从 0 开始自增（位于同一行的 iota 即便出现多次，多个 iota 的值也是一样的）</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span>, <span class="literal">iota</span> + <span class="number">10</span> <span class="comment">// 0, 10 (iota = 0)</span></span><br><span class="line">    Strawberry, Grape <span class="comment">// 1, 11 (iota = 1)</span></span><br><span class="line">    Pear, Watermelon  <span class="comment">// 2, 12 (iota = 2)</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 如果想从 1 开始</span></span><br><span class="line"><span class="comment">// _ = iota // 0 </span></span><br><span class="line"><span class="comment">// 每遇到一次 const 关键字，iota 就重置为 0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一个长度固定的、由同构类型元素组成的连续序列，包含两个重要属性：元素的类型和数组长度（元素的个数）</p><p>数组变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> <span class="comment">// 一维</span></span><br><span class="line"><span class="keyword">var</span> mArr [<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span> <span class="comment">// 多维</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">6</span>]<span class="keyword">int</span> &#123; <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,&#125; <span class="comment">// [11 12 13 14 15 16]</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...]<span class="keyword">int</span> &#123; <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>,&#125; <span class="comment">// [21 22 23] ... 自动计算元素个数</span></span><br></pre></td></tr></table></figure><blockquote><p>数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。</p><p>这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针。</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。</p><p>切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。可以说，<strong>切片之于数组就像是文件描述符之于文件</strong>。</p><p>去掉“长度”这一束缚后，切片展现出更为灵活的特性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>切片的<strong>底层数据结构</strong>：在运行时其实是一个三元组结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 是指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 切片的长度，即切片中当前元素的个数</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同</p></blockquote><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>切片的创建根据情况不同，主要通过以下3种方法创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、make 函数</span></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>, <span class="number">10</span>) <span class="comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>) <span class="comment">// cap = len = 6</span></span><br><span class="line"><span class="comment">// 2、数组切片化 array[low : high : max]</span></span><br><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">sl := arr[<span class="number">3</span>:<span class="number">7</span>:<span class="number">9</span>] <span class="comment">// len = high - low ; cap = max - low ; 即数组下标 [3,7)</span></span><br><span class="line"><span class="comment">// 3、切片创建切片 与 方法2 书写方法相同</span></span><br></pre></td></tr></table></figure><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>当通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//1 1创建底层数组 u1（长度1）</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//2 2创建底层数组 u2（长度2 = u1的两倍），拷贝 u1 元素， array 指向 u2   </span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">13</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//3 4创建底层数组 u3（长度4 = u2的两倍），拷贝 u2 元素， array 指向 u3</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">14</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//4 4cap 足够</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">15</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">//5 8   创建底层数组 u4（长度8 = u3的两倍），拷贝 u3 元素， array 指向 u4</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。</p><p>形式：<code>map[key_type]value_type</code></p><blockquote><p>Go 语言中要求，key 的类型必须支持“==”和“!=”两种比较操作符。</p><p>函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。</p></blockquote><h4 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h4><p>Go 运行时使用一张<strong>哈希表</strong>来实现抽象的 map 类型。</p><p>运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。</p><p>在编译阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建map类型变量实例</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新键值对或给键重新赋值</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span> → v := runtime.mapassign(maptype, m, <span class="string">&quot;key&quot;</span>) v是用于后续存储value的空间的地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某键的值 </span></span><br><span class="line">v := m[<span class="string">&quot;key&quot;</span>]      → v := runtime.mapaccess1(maptype, m, <span class="string">&quot;key&quot;</span>)</span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某键</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)   → runtime.mapdelete(maptype, m, “key”)</span><br></pre></td></tr></table></figure><p><code>hmap</code> 类型是 <code>map</code> 类型的头部结构（header），之前提到的 map 类型的描述符，它存储了后续 map 类型操作所需的所有信息</p><blockquote><p>不要依赖 map 的元素遍历顺序；</p><p>map 不是线程安全的，不支持并发读写；</p><p>不要尝试获取 map 中元素（value）的地址</p></blockquote><p><strong>map扩容：</strong></p><p>当 count &gt; LoadFactor * 2^B 或 overflow bucket 过多时，运行时会自动对 map 进行扩容（ Go 最新 1.17 版本 LoadFactor 设置为 6.5）</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>切片类型，初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用”</p><p>map 类型，因为它内部实现的复杂性，无法“零值可用”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// m = nil</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>         <span class="comment">// 发生运行时异常：panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、使用复合字面值初始化 map 类型变量，</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;     </span><br><span class="line">    x <span class="keyword">float64</span>     </span><br><span class="line">    y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go 允许省略字面值中的元素类型</span></span><br><span class="line">m2 := <span class="keyword">map</span>[Position]<span class="keyword">string</span>&#123;</span><br><span class="line">    Position&#123;<span class="number">29.935523</span>, <span class="number">52.568915</span>&#125;: <span class="string">&quot;school&quot;</span>, <span class="comment">// Postion 可省略，如下</span></span><br><span class="line">    &#123;<span class="number">25.352594</span>, <span class="number">113.304361</span>&#125;: <span class="string">&quot;shopping-mall&quot;</span>,</span><br><span class="line">    &#123;<span class="number">73.224455</span>, <span class="number">111.804306</span>&#125;: <span class="string">&quot;hospital&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、make 函数</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>) <span class="comment">// 未指定初始容量</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">8</span>) <span class="comment">// 指定初始容量为8</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>和切片类型一样，map 也是引用类型。</p><p>这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入，更新相同</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">v := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line">v, ok := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line">    <span class="comment">// &quot;key1&quot;不在map中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key2&quot;</span>) <span class="comment">// 删除&quot;key2&quot;</span></span><br><span class="line"><span class="comment">// 遍历，对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; </span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%d, %d] &quot;</span>, k, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、控制结构"><a href="#2、控制结构" class="headerlink" title="2、控制结构"></a>2、控制结构</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多返回值简化</span></span><br><span class="line"><span class="keyword">if</span> value, ok := readData(); ok &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkWorkday</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;it is a work day&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;it is a weekend day&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;are you live on earth&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要执行下一个 case 的代码逻辑，可以显式使用 Go 提供的关键字 fallthrough 来实现</span></span><br><span class="line"><span class="keyword">switch</span> switchexpr() &#123; </span><br><span class="line">    <span class="keyword">case</span> case1(): </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;exec case1&quot;</span>) </span><br><span class="line">    <span class="keyword">fallthrough</span> </span><br><span class="line">    <span class="keyword">case</span> case2(): </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;exec case2&quot;</span>) </span><br><span class="line">    <span class="keyword">fallthrough</span> </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;exec default&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Go 语言不提供 while，所以 for 循环更加强大</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;This is the %d iteration\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    i = i - <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The variable i is now: %d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h3><p>遍历数组、切片、字符串、map等的好帮手</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;sl[%d] = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>break、continue 与其他语言功能相同</p><p>label +goto 会造成可读性极差，不推荐使用（基本没看到人用）</p></blockquote><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><p>Go 函数支持多返回值，函数定义一般如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(参数列表)</span> 返回值列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> // 无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span> // 仅有一个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>, error)</span> // 有2或2个以上返回值</span></span><br></pre></td></tr></table></figure><p>函数在 Go 语言中属于“一等公民（First-Class Citizen）”：</p><ul><li>Go 函数可以存储在变量中，且拥有自己的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> // 函数类型</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;<span class="comment">// 匿名函数，闭包</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持在函数内创建并通过返回值返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(task <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作为参数传入函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.AfterFunc(time.Second*<span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;timer fired&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h4><blockquote><p>call by value</p></blockquote><p>Go 默认使用<strong>按值传递</strong>来传递参数，也就是传递参数的<strong>副本</strong>（逐位拷贝）。</p><ul><li>函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量</li></ul><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><blockquote><p>call by reference</p></blockquote><p>如果希望函数可以直接修改参数的值，而不是对参数的副本进行操作，</p><p>需要将参数的地址（变量名前面添加&amp;符号，比如 &amp;variable）传递给函数，这就是<strong>引用传递</strong>。</p><ul><li>传递指针（一个32位或者64位的值）的消耗都比传递副本来得少</li></ul><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>如果函数的最后一个参数是采用 <code>...type</code> 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greeting</span><span class="params">(prefix <span class="keyword">string</span>, who ...<span class="keyword">string</span>)</span></span></span><br><span class="line">Greeting(<span class="string">&quot;hello:&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Eileen&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p><strong>尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getX2AndX3</span><span class="params">(input <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 非命名</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * input, <span class="number">3</span> * input</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getX2AndX3_2</span><span class="params">(input <span class="keyword">int</span>)</span> <span class="params">(x2 <span class="keyword">int</span>, x3 <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 命名</span></span><br><span class="line">    x2 = <span class="number">2</span> * input</span><br><span class="line">    x3 = <span class="number">3</span> * input</span><br><span class="line">    <span class="comment">// return x2, x3</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。</p><ul><li><p>在 Go 中，只有在函数（和方法）内部才能使用 defer</p></li><li><p>defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。</p><p>  defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201191633765.png" style="zoom: 50%;" /><p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数。</p><p>所以，deferred 函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件流</span></span><br><span class="line"><span class="comment">// open a file  </span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 解锁加锁的资源</span></span><br><span class="line">mu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="comment">// 打印最终报告</span></span><br><span class="line">printHeader()  </span><br><span class="line"><span class="keyword">defer</span> printFooter()</span><br><span class="line"><span class="comment">// 关闭数据库连接</span></span><br><span class="line"><span class="comment">// open a database connection  </span></span><br><span class="line"><span class="keyword">defer</span> disconnectFromDB()</span><br></pre></td></tr></table></figure><h4 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h4><p>使用 defer 可以跟踪函数的执行过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trace</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;enter:&quot;</span>, name) </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;exit:&quot;</span>, name) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">defer</span> Trace(<span class="string">&quot;foo&quot;</span>)() </span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">defer</span> Trace(<span class="string">&quot;bar&quot;</span>)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">defer</span> Trace(<span class="string">&quot;main&quot;</span>)() </span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enter: main</span><br><span class="line">enter: foo</span><br><span class="line">enter: bar</span><br><span class="line">exit: bar</span><br><span class="line">exit: foo</span><br><span class="line">exit: main</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）<strong>new() 是一个函数，不要忘记它的括号</strong></td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real imag</td><td>用于创建和操作复数（详见第 4.5.2.2 节）</td></tr></tbody></table><h2 id="4、结构与方法"><a href="#4、结构与方法" class="headerlink" title="4、结构与方法"></a>4、结构与方法</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体定义的一般方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span> </span><br><span class="line">    Phone <span class="keyword">string</span></span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以无需提供字段的名字，只需要使用其类型就可以了</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123; </span><br><span class="line">    Title <span class="keyword">string</span> </span><br><span class="line">    Person  <span class="comment">// 嵌入字段（匿名字段）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type T struct &#123;a, b int&#125;</code> 也是合法的语法，它更适用于简单的结构体。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-struct as a value type:</span></span><br><span class="line"><span class="keyword">var</span> pers1 Person</span><br><span class="line">pers1.firstName = <span class="string">&quot;Chris&quot;</span></span><br><span class="line">pers1.lastName = <span class="string">&quot;Woodward&quot;</span></span><br><span class="line">upPerson(&amp;pers1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2—struct as a pointer:</span></span><br><span class="line">pers2 := <span class="built_in">new</span>(Person)</span><br><span class="line">pers2.firstName = <span class="string">&quot;Chris&quot;</span></span><br><span class="line">pers2.lastName = <span class="string">&quot;Woodward&quot;</span></span><br><span class="line">(*pers2).lastName = <span class="string">&quot;Woodward&quot;</span>  <span class="comment">// 这是合法的</span></span><br><span class="line">upPerson(pers2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3—struct as a literal:</span></span><br><span class="line">pers3 := &amp;Person&#123;<span class="string">&quot;Chris&quot;</span>,<span class="string">&quot;Woodward&quot;</span>&#125;</span><br><span class="line">upPerson(pers3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更常用：field:value 形式的复合字面值</span></span><br><span class="line">t := &amp;Timer&#123; </span><br><span class="line">    C: c, </span><br><span class="line">    r: runtimeTimer&#123; </span><br><span class="line">        when: when(d), </span><br><span class="line">    f: sendTime, </span><br><span class="line">        arg: c, </span><br><span class="line">    &#125;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>在 Go 语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？</p><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</p><p>定义方法的一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>方法声明要与 receiver 参数的基类型声明放在同一个包内。（即 struct 与 method 在同一个 package）</li><li>receiver 参数的基类型本身不能为指针类型或接口类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="receiver-参数的选择"><a href="#receiver-参数的选择" class="headerlink" title="receiver 参数的选择"></a>receiver 参数的选择</h4><ul><li>如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型</li><li>如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些</li><li>T 类型是否需要实现某个接口，也就是是否存在将 T 类型的变量赋值给某接口类型变量的情况。<ul><li>如果需要，那使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法</li><li>如果 T 不需要，但 <code>*T</code> 需要，<code>*T</code> 的方法集合是包含 T 的方法集合的，参考上面2个原则选择</li></ul></li></ul><p><strong>总结：</strong></p><blockquote><ul><li>类型 T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li><li>类型 *T 的可调用方法集包含接受者为 *T 的所有方法</li><li>类型 *T 的可调用方法集不包含接受者为 T 的方法</li></ul></blockquote><h2 id="5、接口与反射"><a href="#5、接口与反射" class="headerlink" title="5、接口与反射"></a>5、接口与反射</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>Go 语言不是一种 <em>“传统”</em> 的面向对象编程语言：它里面没有类和继承的概念。</p><p>但是 Go 语言里有非常灵活的 <strong>接口</strong> 概念，通过它可以实现很多面向对象的特性。</p><p>接口提供了一种方式来 <strong>说明</strong> 对象的行为：如果谁能搞定这件事，它就可以用在这儿。</p><p>接口定义了一组方法（<strong>方法集</strong>），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。</p><p>通过如下格式定义接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>Namer</code> 是一个 <strong>接口类型</strong>。</p><p><strong>命名：</strong></p><ul><li>接口的名字由方法名加 <code>er</code> 后缀组成</li><li>当后缀 <code>er</code> 不合适时，以 <code>able</code> 结尾或者以 <code>I</code> 开头，比如 <code>Recoverable</code></li></ul><p>通常它们会包含 0 个、最多 3 个方法（小接口，抽象程度高）</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><blockquote><p>如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集，类型 T 实现了接口类型 I，</p><p>那么类型 T 的变量就可以作为合法的右值赋值给接口类型 I 的变量。</p></blockquote><p>空接口类型的这一可接受任意类型变量值作为右值的特性，是 Go 加入泛型语法之前唯一一种具有“泛型”能力的语法元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">15</span> <span class="comment">// ok</span></span><br><span class="line">i = <span class="string">&quot;hello, golang&quot;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">i = t  <span class="comment">// ok</span></span><br><span class="line">i = &amp;t <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。</p><p>在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。</p><p>类型 <code>T</code> 的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)       <span class="comment">// unchecked type assertion，varI 必须是一个接口变量</span></span><br><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion，一般用这种方法</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type </span></span><br></pre></td></tr></table></figure><ul><li>如果断言成功，变量 v 的类型为 i 的值的类型，而并非接口类型 T</li><li>如果断言失败，v 的类型信息为接口类型 T，它的值为 nil</li></ul><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>接口变量的类型也可以使用一种特殊形式的 <code>switch</code> 来检测：<strong>type-switch</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type Square %T with value %v\n&quot;</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type Circle %T with value %v\n&quot;</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;nil value: nothing to check?\n&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Unexpected type %T\n&quot;</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h3><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。</p><p>反射可以在运行时检查类型和变量，例如它的大小、方法和 <code>动态</code> 的调用这些方法。</p><p>这对于没有源代码的包尤其有用，除非真得有必要，否则应当避免使用或小心使用。</p><p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。</p><p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure><p>更多查看<br><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.10.md">反射包 unknwon/the-way-to-go_ZH_CN · GitHub</a></p><h3 id="Go中的面向对象"><a href="#Go中的面向对象" class="headerlink" title="Go中的面向对象"></a>Go中的面向对象</h3><p>OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？</p><ul><li><p>封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层:</p><p>1）包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见</p><p>2）可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见</p></li></ul><p>类型只拥有自己所在包中定义的方法。</p><ul><li>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li><li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li></ul><h2 id="6、并发"><a href="#6、并发" class="headerlink" title="6、并发"></a>6、并发</h2><p>并发是一种能力，它让你的程序可以由若干个代码片段组合而成，并且每个片段都是独立运行的。</p><p>Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了<strong>goroutine</strong>这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。</p><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>相比传统操作系统线程来说，goroutine 的优势主要是：</p><ul><li>资源占用小，每个 goroutine 的初始栈大小仅为 2k</li><li>由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小</li><li>在语言层面而不是通过标准库提供。goroutine 由go关键字创建，一退出就会被回收或销毁，开发体验更佳</li><li>语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。</li></ul><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>Go 语言通过<code>go关键字+函数/方法</code>的方式创建一个 goroutine。</p><p>创建后，新 goroutine 将拥有独立的代码执行流，并与创建它的 goroutine 一起被 Go 运行时调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> fmt.Println(<span class="string">&quot;I am a goroutine&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 匿名函数/闭包</span></span><br><span class="line">    c &lt;- a + b</span><br><span class="line">&#125;(<span class="number">3</span>,<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/net/http/server.go</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line"><span class="keyword">go</span> c.serve(connCtx) <span class="comment">// 命名函数/方法</span></span><br></pre></td></tr></table></figure><p>不需要考虑对 goroutine 的退出进行控制：<strong>goroutine 的执行函数的返回，就意味着 goroutine 退出。</strong></p><p>如果需要手动控制，通过 <code>channel</code>实现</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><strong>传统语言的并发模型是基于对内存的共享的</strong></p><blockquote><p>传统的编程语言（比如：C++、Java、Python 等）并非面向并发而生的，所以他们面对并发的逻辑多是基于操作系统的线程。</p><p>并发的执行单元（线程）之间的通信，利用的也是操作系统提供的线程或进程间通信的原语，</p><p>比如：共享内存、信号（signal）、管道（pipe）、消息队列、套接字（socket）等。</p></blockquote><p>channel 既可以用来实现 Goroutine 间的通信，还可以实现 Goroutine 间的同步。</p><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>和切片、结构体、map 等一样，channel 也是一种复合数据类型。</p><p>channel 类型变量赋初值的唯一方法是使用 make 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 声明 int 类型的 channel 类型变量，默认值为 nil</span></span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">//无缓冲</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">//带缓冲，5是缓冲长度</span></span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 只发送channel类型</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 只接收channel类型</span></span><br></pre></td></tr></table></figure><h4 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h4><p>Go 提供了<code>&lt;-</code>操作符用于对 channel 类型变量进行发送与接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch1 &lt;- <span class="number">13</span>    <span class="comment">// 将整型字面值13发送到无缓冲channel类型变量ch1中</span></span><br><span class="line">n := &lt;- ch1  <span class="comment">// 从无缓冲channel类型变量ch1中接收一个整型值存储到整型变量n中</span></span><br><span class="line">ch2 &lt;- <span class="number">17</span>    <span class="comment">// 将整型字面值17发送到带缓冲channel类型变量ch2中</span></span><br><span class="line">m := &lt;- ch2  <span class="comment">// 从带缓冲channel类型变量ch2中接收一个整型值存储到整型变量m中</span></span><br></pre></td></tr></table></figure><ul><li>无缓冲 channel：发送与接收操作同步，一定要放在两个不同的 Goroutine 中进行，否则会导致 deadlock</li><li>带缓冲 channel：发送或接收不需要阻塞等待，异步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">n := &lt;-ch2 <span class="comment">// 由于此时ch2的缓冲区中无数据，因此对其进行接收操作将导致goroutine挂起</span></span><br><span class="line"></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">ch3 &lt;- <span class="number">17</span>  <span class="comment">// 向ch3发送一个整型数17</span></span><br><span class="line">ch3 &lt;- <span class="number">27</span>  <span class="comment">// 由于此时ch3中缓冲区已满，再向ch3发送数据也将导致goroutine挂起</span></span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>调用 go 内置的 <code>close()</code>函数，<strong>发送端负责关闭 channel</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否关闭可以用 c,ok</span></span><br><span class="line">n := &lt;- ch      <span class="comment">// 当ch被关闭后，n将被赋值为ch元素类型的零值</span></span><br><span class="line">m, ok := &lt;-ch   <span class="comment">// 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123; <span class="comment">// 当ch被关闭后，for range循环结束</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>通过 select，我们可以同时在多个 channel 上进行发送 / 接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:     <span class="comment">// 从channel ch1接收数据</span></span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> y, ok := &lt;-ch2: <span class="comment">// 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭</span></span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- z:       <span class="comment">// 将z值发送到channel ch3中:</span></span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:             <span class="comment">// 当上面case中的channel通信均无法实施时，执行该默认分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 和 select 的结合使用能形成强大的表达能力：</p><ul><li>利用 default 分支避免阻塞</li><li>实现超时机制</li><li>实现心跳机制</li></ul><h3 id="len"><a href="#len" class="headerlink" title="len"></a>len</h3><p>len 是 Go 语言的一个内置函数，它支持接收数组、切片、map、字符串和 channel 类型的参数，并返回对应类型的“长度”，也就是一个整型值。</p><p>针对 channel ch 的类型不同，len(ch) 有如下两种语义：</p><ul><li>当 ch 为无缓冲 channel 时，len(ch) 总是返回 0</li><li>当 ch 为带缓冲 channel 时，len(ch) 返回当前 channel ch 中尚未被读取的元素个数</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h4><p>无缓冲 channel 兼具通信和同步特性，在并发程序中应用颇为广泛。</p><ul><li>信号传递</li><li>替代锁机制</li></ul><h4 id="带缓冲"><a href="#带缓冲" class="headerlink" title="带缓冲"></a>带缓冲</h4><p>带缓冲的 channel 与无缓冲的 channel 的最大不同之处，就在于它的<strong>异步性。</strong></p><p>对一个带缓冲 channel：</p><ul><li>在缓冲区未满的情况下，对它进行发送操作的 Goroutine 不会阻塞挂起</li><li>在缓冲区有数据的情况下，对它进行接收操作的 Goroutine 也不会阻塞挂起</li></ul><p>所以可以用于：</p><ul><li>消息队列</li><li>计数信号量</li></ul><h2 id="7、常用包"><a href="#7、常用包" class="headerlink" title="7、常用包"></a>7、常用包</h2><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 <code>strings</code> 包来完成对字符串的主要操作。</p><p><a href="http://golang.org/pkg/strings/">strings package - strings - pkg.go.dev</a></p><p>常用函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断前缀</span></span><br><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span> </span><br><span class="line"><span class="comment">// 判断后缀</span></span><br><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// 字符串包含</span></span><br><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line">strings.Replace(str, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>) <span class="keyword">string</span> <span class="comment">// 替换old的前 n 个字符， n=-1 替换整个 old</span></span><br><span class="line"><span class="comment">// 判断索引（出现位置）</span></span><br><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span> <span class="comment">// -1 表示不包含</span></span><br><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span> <span class="comment">// 最后出现的位置</span></span><br><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span> <span class="comment">// 非 ASCII 编码的字符，strings.IndexRune(&quot;chicken&quot;, 99)</span></span><br><span class="line"><span class="comment">// 出现次数</span></span><br><span class="line">strings.Count(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">strings.Repeat(s, count <span class="keyword">int</span>) <span class="keyword">string</span> <span class="comment">//重复 count 次字符串 s 并返回一个新的字符串</span></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line">strings.ToLower(s) <span class="keyword">string</span></span><br><span class="line">strings.ToUpper(s) <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 修剪</span></span><br><span class="line">strings.TrimSpace(s) <span class="comment">// 剔除开头和结尾的空白符号</span></span><br><span class="line">strings.Trim(s, <span class="string">&quot;cut&quot;</span>) <span class="comment">// 剔除开头和结尾指定字符，TrimLeft，TrimRight 只剔除一边</span></span><br><span class="line"><span class="comment">// 分割，返回 slice</span></span><br><span class="line">strings.Fields(s) <span class="comment">// 用一个或多个空白分割，全是空白则返回长度 0 的切片</span></span><br><span class="line">strings.Split(s, sep) <span class="comment">// 用指定字符串 seq 分割</span></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line">strings.Join(sl []<span class="keyword">string</span>, sep <span class="keyword">string</span>) <span class="keyword">string</span> <span class="comment">// seq 为分隔符， sl 为字符串切片</span></span><br><span class="line"><span class="comment">// 例如：strings.Join([]string&#123;&quot;删除：文件夹&quot;, path&#125;, &quot; &quot;)</span></span><br></pre></td></tr></table></figure><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><p>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的。</p><p><a href="https://pkg.go.dev/strconv">strconv package - strconv - pkg.go.dev</a></p><p>常用函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">strconv.IntSize <span class="comment">// 当前操作系统 int 所占位置</span></span><br><span class="line"><span class="comment">// 整数转字符串</span></span><br><span class="line">strconv.Itoa(i <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 浮点数转字符串</span></span><br><span class="line">strconv.FormatFloat(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec <span class="keyword">int</span>, bitSize <span class="keyword">int</span>) <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 其中 fmt 表示格式（其值可以是 &#x27;b&#x27;、&#x27;e&#x27;、&#x27;f&#x27; 或 &#x27;g&#x27;）</span></span><br><span class="line">    <span class="comment">// prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64</span></span><br><span class="line"><span class="comment">// 字符串转整数</span></span><br><span class="line">strconv.Atoi(s <span class="keyword">string</span>) (i <span class="keyword">int</span>, err error)</span><br><span class="line"><span class="comment">// 浮点数转字符串</span></span><br><span class="line">strconv.ParseFloat(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>) (f <span class="keyword">float64</span>, err error)</span><br></pre></td></tr></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code> 包为我们提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。</p><p><a href="http://golang.org/pkg/time/">time package - time - pkg.go.dev</a></p><p>常用函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now() <span class="comment">// 当前时间</span></span><br><span class="line">t.Day()</span><br><span class="line">t.Minute()</span><br><span class="line"><span class="comment">// 标准格式化</span></span><br><span class="line">t.Format(<span class="string">&quot;02 Jan 2006 15:04&quot;</span>) <span class="comment">// 输出 21 Jul 2011 10:31</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="http://blog.sukiu.top/Operating-System/Process-And-Thread/"/>
    <id>http://blog.sukiu.top/Operating-System/Process-And-Thread/</id>
    <published>2022-01-15T11:03:07.000Z</published>
    <updated>2022-01-16T12:20:34.196Z</updated>
    
    <content type="html"><![CDATA[<p>线程是最小的执行单元，而进程由至少一个线程组成。</p><p>如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://wx.zsxq.com/dweb2/index/topic_detail/185515824245112">八股文（星球精华汇总）</a><br><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/or5lgc/">进程与线程 - 力扣（LeetCode）</a></p></blockquote><h2 id="1、进程概念"><a href="#1、进程概念" class="headerlink" title="1、进程概念"></a>1、进程概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们编译的代码可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU执行内存中指令，这个<strong>运行的程序</strong>被称为进程。</p><p>进程是对运行时程序的封装，操作系统进行资源调度和分配的基本单位。</p><blockquote><p>如果包含线程的话，<strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>独立调度</strong>的基本单位。</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li><p>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程⼀样，都是clone</p></li><li><p>从内核⾥看进程和线程是⼀样的，都有各自不同的PCB</p></li><li><p>进程可以蜕变成线程</p></li><li><p>在linux下，线程最是小的执⾏单位；进程是最小的分配资源单位</p></li></ol><blockquote><p><strong>进程与线程的区别</strong>：</p><p>Ⅰ拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></blockquote><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。</p><p>每个进程占有⼀个进程表项(进程控制块)。</p><blockquote><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p></blockquote><p>该表项是进程存在的唯⼀标识，其包括以下信息：</p><ul><li>进程描述信息： 进程标识符、用户标识符等</li><li>进程控制和管理信息： 进程状态，进程优先级等</li><li>进程资源分配清单： 虚拟内存地址空间信息，打开文件列表，IO设备信息等</li><li>CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续执行</li></ul><p>PCB通过链表形式组织起来，比如有就绪队列、阻塞队列等，方便增删，方便进程管理。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>单个核心在很短时间内分别执行多个进程，称为<strong>并发</strong>（同一时间段）</li><li>多个核⼼同时执行多个进程称为<strong>并行</strong>（同一时刻）</li><li>对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>除了<strong>创建</strong>和<strong>结束</strong>⼀般有三个状态：</p><ul><li><p>运行态： 该时刻进程占用CPU</p></li><li><p>就绪态： 可运行，由于其他进程处于运行状态而暂时停止运行 <strong>等待被调度</strong></p></li><li><p>阻塞态： 该进程正在等待某⼀事件发生（如等待输⼊/输出操作的完成）而暂时停止运行 <strong>等待资源</strong></p><blockquote><p>阻塞态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换⼊到物理内存。</p></blockquote></li></ul><p>挂起态：新的状态，描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</p><ul><li><p>阻塞挂起状态： 进程在外存（硬盘）并等待某个事件的出现</p></li><li><p>就绪挂起状态： 进程在外存（硬盘），但只要进⼊内存，马上运行</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201152122755.png" style="zoom: 67%;" /><blockquote><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。</li><li>就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态</li><li>运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul></blockquote><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。</p><ol><li>它是⼀个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</li><li>⼀般采用以d结尾的名字</li><li>所有的服务存在于 etc/init.d</li><li>守护进程是个特殊的孤儿进程</li><li>之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示</li><li>Linux 的⼤多数服务器就是用守护进程实现的</li></ol><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>多进程程序，父进程⼀般需要跟踪子进程的退出状态，当子进程退出，父进程在运行，子进程必须等到父进程捕获到了子进程的退出状态才真正结束。在子进程结束后，父进程读取状态前，此时子进程为僵尸进程。</p><p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。</p><p>但是子进程停止在僵尸态会占据内核资源，所以需要避免僵尸进程的产生或立即结束子进程的僵尸态。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>进程结构由以下几个部分组成：代码段、堆栈段、数据段。</p><p>代码段是静态的⼆进制代码，多个程序可以共享。</p><p>父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎⼀样。</p><p>父、子进程共享全部数据，子进程在写数据时会使用写时复制技术将公共的数据重新拷贝⼀份，之后在拷贝出的数 据上进行操作；不是对同⼀块数据进行操作；如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p><h2 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、进程调度</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><h4 id="先来先服务-first-come-first-serverd（FCFS）"><a href="#先来先服务-first-come-first-serverd（FCFS）" class="headerlink" title="先来先服务 first-come first-serverd（FCFS）"></a>先来先服务 first-come first-serverd（FCFS）</h4><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="短作业优先-shortest-job-first（SJF）"><a href="#短作业优先-shortest-job-first（SJF）" class="headerlink" title="短作业优先 shortest job first（SJF）"></a>短作业优先 shortest job first（SJF）</h4><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="最短剩余时间优先-shortest-remaining-time-next（SRTN）"><a href="#最短剩余时间优先-shortest-remaining-time-next（SRTN）" class="headerlink" title="最短剩余时间优先 shortest remaining time next（SRTN）"></a>最短剩余时间优先 shortest remaining time next（SRTN）</h4><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。</p><p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。<br>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系，因为进程切换都要保存进程的信息并且载入新进程的信息</p><ul><li>如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，</p><p>例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="3、进程通信"><a href="#3、进程通信" class="headerlink" title="3、进程通信"></a>3、进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。</p><ul><li><p>同一主机</p><ul><li>无名管道 ：半双工（单方向交替传输）、只能在父子进程或者兄弟进程中使用</li><li>有名管道：（FIFO）去除了管道只能在父子进程中使用的限制。</li><li>信号：信号是软件中断，它是在软件层次上对中断机制的⼀种模拟，是⼀种异步通信的方式</li><li>消息队列：A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。</li></ul><blockquote><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul></blockquote><ul><li>共享存储：存储映射I/O (Memory-mapped I/O) 使⼀个磁盘⽂件与存储空间中的⼀个缓冲区相映射。</li></ul><blockquote><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，可以直接读写内存，所以这是最快的一种 IPC</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p></blockquote><ul><li>信号量：它是一个计数器，用于为多个进程提供对共享数据对象的访问。</li></ul></li><li><p>不同主机</p><ul><li>Socket 套接字</li></ul></li></ul><h2 id="4、进程同步"><a href="#4、进程同步" class="headerlink" title="4、进程同步"></a>4、进程同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>也叫互斥量，互斥锁是⼀种简单的加锁的⽅法来控制对共享资源的访问，互斥锁只有两种状态，即加锁( lock )和解锁 ( unlock )</p><ol><li><p>在访问共享资源后临界区域前，对互斥锁进行加锁</p></li><li><p>在访问完成后释放互斥锁导上的锁</p></li><li><p>对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放</p></li></ol><p>互斥锁的数据类型是： <code>pthread_mutex_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="死锁-DeadLock"><a href="#死锁-DeadLock" class="headerlink" title="死锁 DeadLock"></a>死锁 DeadLock</h3><p>如果⼀个进程集合中的每⼀个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁</p><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>死锁产生必须同时满足四个条件，只要其中任意一条不成立，死锁就不会发生。</p><ul><li><p>互斥条件<br>  进程要求对所分配的资源（比如打印机）进行排他性控制，即在一段时间内某资源只能由一个进程占有。</p><p>  此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>不可剥夺条件<br>  进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。</p></li><li><p>请求并保持条件<br>  进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>循环等待条件<br>  存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p></li></ul><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p><strong>每种类型⼀个资源的死锁检测：</strong></p><p>通过检测有向图中是否存在环来实现，从⼀个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁发生。</p><p><strong>每种类型多个资源的死锁检测：</strong></p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><p><strong>从死锁中恢复：</strong></p><ul><li>利用抢占恢复：将进程挂起，强行取走资源给另⼀个进程使用，用完再放回</li><li>利用回滚恢复：复位到更早的状态，那时它还没有取得所需的资源</li><li>通过杀死进程恢复：杀掉环中的⼀个进程或多个，牺牲掉⼀个环外进程</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>在程序运行之前预防发生死锁，其实就是破坏死锁产生的必要条件，破坏任何一个，死锁都不会发生。</p><ul><li>破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li><li>破坏请求和保持条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</li><li>破坏不可剥夺条件：保证每⼀个进程在任何时刻只能占用⼀个资源，如果请求另⼀个资源必须先释放第⼀个资源。</li><li>破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li><strong>安全状态：</strong>如果没有死锁发⽣，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每⼀个进程运行完毕</li><li><strong>单个资源的银行家算法：</strong>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是<strong>判断对请求的满足是否会进入不安全状态</strong>，如果是，就拒绝请求；否则予以分配。</li><li><strong>多个资源的银行家算法：</strong>如果一个状态不是安全的，需要拒绝进入这个状态。</li></ul><blockquote><p>检查一个状态是否安全的算法如下：</p><ol><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ol></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应⽤。</p><p>为了满⾜当前能够允许多个读出，但只允许⼀个写入的需求，线程提供了读写锁来实现。</p><p><strong>读写锁的特点：</strong></p><ul><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作</li></ul><p>POSIX 定义的读写锁的数据类型是： <code>pthread_rwlock_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 读锁定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 写锁定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。</p><p>条件变量用来自动阻塞⼀个线程，直到某特殊情况发生为止。</p><p>通常条件变量和互斥锁同时使用。相较于mutex而言，条件变量可以减少竞争。</p><p><strong>条件变量的两个动作</strong>：</p><ul><li>条件不满, 阻塞线程</li><li>当条件满足 通知阻塞的线程开始工作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 删除条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct *<span class="keyword">restrict</span> abstime)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><blockquote><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。</strong>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了条件变量以及相关的操作：</p><ul><li><p>wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。</p></li><li><p>signal() 操作用于唤醒被阻塞的进程。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;线程是最小的执行单元，而进程由至少一个线程组成。&lt;/p&gt;
&lt;p&gt;如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。&lt;/p&gt;
&lt;p&gt;多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。&lt;/p&gt;</summary>
    
    
    
    <category term="Operating System" scheme="http://blog.sukiu.top/categories/Operating-System/"/>
    
    
    <category term="Thread" scheme="http://blog.sukiu.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://blog.sukiu.top/Algorithm/Dynamic-Programming/"/>
    <id>http://blog.sukiu.top/Algorithm/Dynamic-Programming/</id>
    <published>2022-01-03T05:47:38.000Z</published>
    <updated>2022-03-02T08:34:19.538Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（Dynamic Programming，简称DP），如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>和贪心的区别在于：</p><ul><li>动态规划中每一个状态一定是由上一个状态推导出来的</li><li>贪心没有状态推导，而是从局部直接选最优的，</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p></blockquote><p>卡子哥的<strong>DP五部曲</strong>：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201031418164.png" style="zoom: 50%;" /><h2 id="1、背包问题"><a href="#1、背包问题" class="headerlink" title="1、背包问题"></a>1、背包问题</h2><blockquote><p>对于面试，掌握01背包和完全背包就够用了，最多可以再来一个多重背包。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202201061504469.png" style="zoom:80%;" /><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>有N件物品和一个最多能背重量为 <code>W</code> 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。</p><p><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><ol><li><p><code>dp[i][j]</code>：从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少</p></li><li><p>有两个方向推出来<code>dp[i][j]</code>：</p></li></ol><ul><li><p><strong>不放物品 i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为j，里面不放物品i的最大价值</p></li><li><p><strong>放物品 i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]] </code>为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> ，就是背包放物品i得到的最大价值</p></li><li><p>动态转移公式：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])$</p></li></ul><ol start="3"><li>初始化：由递推公式看出，必须初始化<code>dp[0][j]</code>（存放编号0的物品的时候，各个容量的背包所能存放的最大价值）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(bagWeight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>遍历顺序：先遍历物品和先遍历背包重量都可，<strong>先遍历物品</strong>更好理解</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 01背包</span></span><br><span class="line"><span class="comment">- 动态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化, dp[0][j]</span></span><br><span class="line">    <span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &lt; weight[i] &#123; <span class="comment">// 放不下</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><p>滚动数组：把二维 dp 降为一维 dp</p><blockquote><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code></strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）</p><p><strong>倒叙遍历是为了保证物品i只被放入一次</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化 一维</span></span><br><span class="line"><span class="comment">// - dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblemBetter</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> weight &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bagWeight; j &gt;= weight[i]; j-- &#123; <span class="comment">// 倒序，正序会状态重复</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有 <code>N</code> 件物品和一个最多能背重量为 <code>W</code> 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。</p><p><strong>每件物品能用无数次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><blockquote><p><strong>01背包和完全背包唯一不同就是体现在遍历顺序上：</strong></p><ul><li><p>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p></li><li><p>完全背包的物品是可以添加多次的，所以要从小到大去遍历</p></li></ul><p><strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品, 再遍历背包</span></span><br><span class="line"><span class="comment">// ! 如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先遍历背包, 再遍历物品</span></span><br><span class="line"><span class="comment">// ! 如果求排列数就是外层for遍历背包，内层for循环遍历物品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem2</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weight[i] &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有 <code>N</code> 种物品和一个容量为 <code>V</code> 的背包。第 <code>i</code> 种物品最多有 $M_i$ 件可用，每件耗费的空间是  $C_i$ ，价值是 $W_i$ 。<br>求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p><blockquote><p>每件物品最多有 $M_i$ 件可用，把 $M_i$ 件摊开，其实就是一个01背包问题了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ! 转换成 01 背包</span></span><br><span class="line"><span class="comment">// - O(m*n*k)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bagProblem</span><span class="params">(weight, value, nums []<span class="keyword">int</span>, bagweight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagweight+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> weight &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bagweight; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">            <span class="comment">// 遍历背包个数</span></span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; j-k*weight[i] &gt;= <span class="number">0</span>; k++ &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-k*weight[i]]+k*value[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fmt.Println(dp)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagweight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、打家劫舍"><a href="#2、打家劫舍" class="headerlink" title="2、打家劫舍"></a>2、打家劫舍</h2><h3 id="一条边"><a href="#一条边" class="headerlink" title="一条边"></a>一条边</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p></blockquote><p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong></p><p>那么需要考虑2种情况：</p><ul><li>i 偷：$dp[i]=dp[i-2]+nums[i]$</li><li>i 不偷：$dp[i]=dp[i-1]$</li></ul><p>所以动态转移公式为：$dp[i]=max(dp[i-2]+nums[i],dp[i-1])$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="记录路径"><a href="#记录路径" class="headerlink" title="记录路径"></a>记录路径</h4><p>类似股票问题，多开2个状态：</p><ul><li><code>dp[i][0]</code>：不偷 i</li><li><code>dp[i][1]</code>：偷 i</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=dp.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][<span class="number">1</span>]==target)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                target-=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=path.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout&lt;&lt;path[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="围成圈"><a href="#围成圈" class="headerlink" title="围成圈"></a>围成圈</h3><blockquote><p>在一条边的基础上，收尾相连形成圈</p></blockquote><p>只要比较 首和尾存一个 的两种情况即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robrob</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>),</span><br><span class="line">                   <span class="built_in">robrob</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robrob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="形成树"><a href="#形成树" class="headerlink" title="形成树"></a>形成树</h3><blockquote><p>变成一棵二叉树，树形dp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure></blockquote><p>dp数组记录2个状态：</p><ul><li><p>dp[0]：记录不偷该节点所得到的的最大金钱</p></li><li><p>dp[1]：记录偷该节点所得到的的最大金钱</p></li></ul><blockquote><p>长度为2的数组怎么标记树中每个节点的状态呢？</p><p>在递归的过程中，系统栈会保存每一层递归的参数</p></blockquote><p>左右根顺序（后序）遍历，那么分为 2 种情况：</p><ul><li>根偷：两个子结点不偷 $  = left[0] + right[0] + root-&gt;val $</li><li>根不偷：考虑两个子结点偷 $  = max(left[0], left[1]) + max(right[0], right[1]) $</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> v2 = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> &#123;v1, v2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、股票问题"><a href="#3、股票问题" class="headerlink" title="3、股票问题"></a>3、股票问题</h2><p>主要通过二维数组记录各个状态，分析好每个状态的转移公式即可。</p><p>也可以滚动数组优化到一维，相当于覆盖前面的状态，不过不容易理解。</p><h3 id="买卖1次"><a href="#买卖1次" class="headerlink" title="买卖1次"></a>买卖1次</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code></p><blockquote><p>虽然有动态规划的思想，但第一感觉还是这样写</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minn = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minn &gt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, prices[i] - minn);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="买卖多次"><a href="#买卖多次" class="headerlink" title="买卖多次"></a>买卖多次</h3><blockquote><p>你可以尽可能地完成更多的交易</p></blockquote><p>二维数组记录2个状态：</p><ul><li><p><code>dp[i][0]</code> ：表示第<code>i</code>天持有股票所得最多现金</p></li><li><p><code>dp[i][1]</code> ：表示第<code>i</code>天不持有股票所得最多现金</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dp[i][0] 持有股票</span></span><br><span class="line">    <span class="comment">// dp[i][1] 不持有股票</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最多买卖2次"><a href="#最多买卖2次" class="headerlink" title="最多买卖2次"></a>最多买卖2次</h3><blockquote><p>你最多可以完成 <strong>两笔</strong> 交易。</p></blockquote><p>二维数组记录5个状态：</p><ul><li><code>dp[i][0]</code>：无操作</li><li><code>dp[i][1]</code>：第一次买入状态</li><li><code>dp[i][2]</code>：第一次卖出状态</li><li><code>dp[i][3]</code>：第二次买入状态</li><li><code>dp[i][4]</code>：第二次卖出状态</li></ul><blockquote><p>上面的状态不一定是第 i 天买入卖出，只是维持这种状态</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最多买卖k次"><a href="#最多买卖k次" class="headerlink" title="最多买卖k次"></a>最多买卖k次</h3><blockquote><p>你最多可以完成 <strong>k</strong> 笔交易。</p></blockquote><p>照着上面那个维护 $2*k+1$ 个状态即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * k; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="含冷却期"><a href="#含冷却期" class="headerlink" title="含冷却期"></a>含冷却期</h3><blockquote><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)</li></ul></blockquote><p>二维数组记录4个状态：</p><ul><li><code>dp[i][0]</code>：买入状态</li><li><code>dp[i][1]</code>：卖出状态（非冷却期）</li><li><code>dp[i][2]</code>：卖出状态（刚卖出）</li><li><code>dp[i][3]</code>：卖出状态（冷却期）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] =</span><br><span class="line">                <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                   <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="含手续费"><a href="#含手续费" class="headerlink" title="含手续费"></a>含手续费</h3><blockquote><p>每笔交易你只需要为支付一次手续费。</p></blockquote><p>跟买卖多次差不多，添上手续费即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee, dp[i - <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 这里减去手续费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、子序列问题"><a href="#4、子序列问题" class="headerlink" title="4、子序列问题"></a>4、子序列问题</h2><h3 id="子序列不连续"><a href="#子序列不连续" class="headerlink" title="子序列不连续"></a>子序列不连续</h3><blockquote><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p></blockquote><p><code>dp[i][j]</code>：长度为<code>[0, i - 1]</code>的字符串text1与长度为<code>[0, j - 1]</code>的字符串text2的最长公共子序列</p><p>那么分为两种情况：</p><ul><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>相同</li><li><code>text1[i - 1]</code> 与 <code>text2[j - 1]</code>不相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类似题目：不相交的线</p><p>只是换了种题目说法，解法一模一样，转换过来就是最长公共子序列</p></blockquote><h3 id="子序列连续"><a href="#子序列连续" class="headerlink" title="子序列连续"></a>子序列连续</h3><blockquote><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote><p><code>dp[i][j]</code>：以下标<code>i - 1</code><strong>结尾</strong>的字符串A与以下标<code>j - 1</code><strong>结尾</strong>的字符串B的最长重复子数组</p><p>那么只要考虑<code>nums1[i - 1]</code> 与 <code>nums2[j - 1]</code>相同时，更新长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// else 无事发生，即 dp[i][j] = 0</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><blockquote><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul></blockquote><p><code>dp[i][j]</code> 表示以下标<code>i-1</code>为结尾的字符串word1，和以下标<code>j-1</code>为结尾的字符串word2的最近编辑距离</p><p>那么需要维护以下4种状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure><ul><li>操作一：word1删除一个元素，那么就是以下标 <code>i - 2</code> 为结尾的word1 与 <code>j-1</code> 为结尾的word2的最近编辑距离 再加上一个操作</li></ul><p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p><ul><li>操作二：word2删除一个元素，那么就是以下标 <code>i - 1</code> 为结尾的word1 与 <code>j-2</code> 为结尾的word2的最近编辑距离 再加上一个操作</li></ul><p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p><blockquote><p>word2添加一个元素，相当于word1删除一个元素，即<strong>增删等同</strong></p></blockquote><ul><li><p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</p><p>  即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i; <span class="comment">// 删除 i 个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j; <span class="comment">// 删除 j 个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p></blockquote><p><code>dp[i][j]</code>：表示区间范围<code>[i,j]</code> （左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false</p><ul><li><p>当s[i]与s[j]不相等，<code>dp[i][j]</code>一定是false。</p></li><li><p>当s[i]与s[j]相等时，</p><ul><li><p>情况一：下标 i 与 j 相同，同一个字符例如 a，当然是回文子串</p></li><li><p>情况二：下标 i 与 j 相差为1，例如aa，也是文子串</p></li><li><p>情况三：下标 i 与 j 相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看 i 到 j 区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true</p></li></ul></li></ul><p><strong>一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="回文子序列"><a href="#回文子序列" class="headerlink" title="回文子序列"></a>回文子序列</h4><blockquote><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p></blockquote><p><code>dp[i][j]</code>：字符串 s 在<code>[i, j]</code>范围内最长的回文子序列的长度</p><ul><li>如果s[i]与s[j]相同，那么 $dp[i][j] = dp[i + 1][j - 1] + 2$</li><li>如果s[i]与s[j]不相同，那么 $dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划（Dynamic Programming，简称DP），如果某一问题有很多重叠子问题，使用动态规划是最有效的。&lt;/p&gt;
&lt;p&gt;和贪心的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划中每一个状态一定是由上一个状态推导出来的&lt;/li&gt;
&lt;li&gt;贪心没有状态推导，而是从局部直接选最优的，&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="DP" scheme="http://blog.sukiu.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Shell</title>
    <link href="http://blog.sukiu.top/Language/Shell/"/>
    <id>http://blog.sukiu.top/Language/Shell/</id>
    <published>2021-12-28T12:14:49.000Z</published>
    <updated>2022-01-06T07:30:33.209Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 脚本的一些注意点</p><span id="more"></span><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -e file/dir ] <span class="comment"># 如果文件/目录存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -f file ] <span class="comment"># 如果文件存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -d dir ]  <span class="comment"># 如果目录存在  </span></span><br><span class="line"><span class="keyword">if</span> [ -s file ] <span class="comment"># 如果文件存在且非空  </span></span><br><span class="line"><span class="keyword">if</span> [ -r file ] <span class="comment"># 如果文件存在且可读  </span></span><br><span class="line"><span class="keyword">if</span> [ -w file ] <span class="comment"># 如果文件存在且可写  </span></span><br><span class="line"><span class="keyword">if</span> [ -x file ] <span class="comment"># 如果文件存在且可执行</span></span><br></pre></td></tr></table></figure><h3 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ int1 -eq int2 ] <span class="comment"># 如果 ==  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ne int2 ] <span class="comment"># 如果 !=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -ge int2 ] <span class="comment"># 如果 &gt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -gt int2 ] <span class="comment"># 如果 &gt;  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -le int2 ] <span class="comment"># 如果 &lt;=  </span></span><br><span class="line"><span class="keyword">if</span> [ int1 -lt int2 ] <span class="comment"># 如果 &lt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$string1</span> == <span class="variable">$string2</span> ] <span class="comment"># 如果 == (字符串允许使用赋值号做等号)  </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$string1</span> != <span class="variable">$string2</span> ] <span class="comment"># 如果 !=  </span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$string</span> ]           <span class="comment"># 如果string 长度非0 </span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$string</span> ]           <span class="comment"># 如果string 长度为0  </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell 脚本的一些注意点&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://blog.sukiu.top/Algorithm/Backtracking/"/>
    <id>http://blog.sukiu.top/Algorithm/Backtracking/</id>
    <published>2021-12-26T05:15:41.000Z</published>
    <updated>2021-12-30T11:08:28.145Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回溯的本质是穷举，穷举所有可能，然后选出想要的答案</strong>，如果想让回溯法高效一些，需要进行<strong>剪枝</strong>操作。</p><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><blockquote><p><strong>组合不强调元素顺序，排列强调元素顺序</strong>：</p><p>即 不同顺序的同样元素集合 算作排列，但不算组合</p></blockquote><span id="more"></span><blockquote><p>参考：<br><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p></blockquote><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>看到回溯，感觉和 DFS（深度优先搜索）区别不太大，两者其实是包含关系。</p><p>回溯搜索是 DFS 的一种，对于某一个搜索树来说（搜索树记录路径和状态判断），其主要的区别是：</p><ul><li>回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树</li><li>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种方法使得深度优先搜索法与回溯法没什么区别</li></ul><h2 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h2><blockquote><p>N个数里面按一定规则找出k个数的集合。</p></blockquote><p>直接 DFS 暴搜，如果满足条件返回，再加上适当剪枝即可。</p><blockquote><p>如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>。<br>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p></blockquote><p>例题：<a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= n - (k - tmp.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、切割问题"><a href="#3、切割问题" class="headerlink" title="3、切割问题"></a>3、切割问题</h2><blockquote><p>一个字符串按一定规则有几种切割方式</p></blockquote><p>具体算法类似组合问题，判断函数比较复杂。</p><p>例题：<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(s, idx, i)) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(idx, i - idx + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">dfs</span>(s, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、子集问题"><a href="#4、子集问题" class="headerlink" title="4、子集问题"></a>4、子集问题</h2><blockquote><p>一个N个数的集合里有多少符合条件的子集</p></blockquote><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。</strong></p><p>例题：<a href="https://leetcode-cn.com/problems/subsets/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、排列问题"><a href="#5、排列问题" class="headerlink" title="5、排列问题"></a>5、排列问题</h2><blockquote><p>N个数按一定规则全排列，有几种排列方式</p><p>排列是区分顺序的，不同顺序的集合算不同排列</p></blockquote><p>和组合问题区别在每次循环的起始位置都是 0，同时用 vis 数组来记录状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, vis);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6、棋盘问题"><a href="#6、棋盘问题" class="headerlink" title="6、棋盘问题"></a>6、棋盘问题</h2><blockquote><p>N皇后，解数独等等</p></blockquote><p>给回溯函数加上 bool 返回值，找到一组成功解则返回。</p><p>例题：<a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归遍历行</span></span><br><span class="line"><span class="comment">     * 循环遍历列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(row, col, n, chess)) &#123;</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(row + <span class="number">1</span>, n, chess);</span><br><span class="line">                chess[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *不能同行（递归过程中进行了同行检查）</span></span><br><span class="line"><span class="comment">     *不能同列</span></span><br><span class="line"><span class="comment">     *不能同斜线 （45度和135度角）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n, vector&lt;string&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查列，剪枝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠45°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ∠135°</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chess</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n, chess);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;  <span class="comment">// 检查列</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;  <span class="comment">// 检查行</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 3x3</span></span><br><span class="line">        <span class="keyword">int</span> nRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> nCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nRow; i &lt; nRow + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nCol; j &lt; nCol + <span class="number">3</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check</span>(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 9 个数都不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="built_in">dfs</span>(board); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;回溯的本质是穷举，穷举所有可能，然后选出想要的答案&lt;/strong&gt;，如果想让回溯法高效一些，需要进行&lt;strong&gt;剪枝&lt;/strong&gt;操作。&lt;/p&gt;
&lt;p&gt;回溯法，一般可以解决如下几种问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合问题：N个数里面按一定规则找出k个数的集合&lt;/li&gt;
&lt;li&gt;切割问题：一个字符串按一定规则有几种切割方式&lt;/li&gt;
&lt;li&gt;子集问题：一个N个数的集合里有多少符合条件的子集&lt;/li&gt;
&lt;li&gt;排列问题：N个数按一定规则全排列，有几种排列方式&lt;/li&gt;
&lt;li&gt;棋盘问题：N皇后，解数独等等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;组合不强调元素顺序，排列强调元素顺序&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;即 不同顺序的同样元素集合 算作排列，但不算组合&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Backtracking" scheme="http://blog.sukiu.top/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://blog.sukiu.top/Computer-network/Physical-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Physical-Layer/</id>
    <published>2021-12-23T13:47:27.000Z</published>
    <updated>2021-12-23T13:58:07.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>物理层</strong>（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。</p><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong></p><p>物理层主要任务：确定与传输媒体接口有关的一些特性</p><p>四大特性：</p><ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</li><li>规程特性：定义各条物理线路的工作规程和时序关系</li></ul><p>物理层设备：中继器</p><span id="more"></span><h2 id="1、通信方式"><a href="#1、通信方式" class="headerlink" title="1、通信方式"></a>1、通信方式</h2><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232153357.png"><br>主要考虑：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="2、数据交换方式"><a href="#2、数据交换方式" class="headerlink" title="2、数据交换方式"></a>2、数据交换方式</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232156819.png" style="zoom: 40%;" /><h2 id="3、传输介质"><a href="#3、传输介质" class="headerlink" title="3、传输介质"></a>3、传输介质</h2><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><ul><li>无线电波</li><li>微波</li><li>红外线、激光</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;（Physical Layer）是计算机网络OSI模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。&lt;/p&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;strong&gt;传输数据比特流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理层主要任务：确定与传输媒体接口有关的一些特性&lt;/p&gt;
&lt;p&gt;四大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况&lt;/li&gt;
&lt;li&gt;电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制&lt;/li&gt;
&lt;li&gt;功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途&lt;/li&gt;
&lt;li&gt;规程特性：定义各条物理线路的工作规程和时序关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物理层设备：中继器&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://blog.sukiu.top/Computer-network/Data-Link-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Data-Link-Layer/</id>
    <published>2021-12-23T12:57:35.000Z</published>
    <updated>2021-12-23T13:47:32.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据链路层</strong> 是OSI参考模型中的第二层，介乎于物理层和网络层之间。</p><p>功能：在物理层提供服务的基础上向网络层提供服务</p><ul><li>最基本的服务：<strong>将源自于物理层的数据可靠地传输到相邻结点到目标机网络层</strong></li><li>主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li><li>为网络层提供服务：<ul><li>无确认的无连接服务</li><li>有确认的无连接服务</li><li>有确认的面向连接服务</li></ul></li></ul><p>重要协议：</p><ul><li>PPP（Point to Point Protocol）点-点协议</li></ul><p>链路层设备：</p><ul><li>交换机</li><li>网桥</li></ul><span id="more"></span><blockquote><p>参考：<br>王道考研</p></blockquote><h2 id="1、基本问题"><a href="#1、基本问题" class="headerlink" title="1、基本问题"></a>1、基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>针对用户是透明的；首尾是界定帧，转义字符去除数据部分和首尾相同引起歧义。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>链路层编码针对<strong>一组比特</strong>，通过冗余码的技术实现一组二进制比特串在传输过程中是否出现差错。</p><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><p>主要包括：</p><ul><li>检错编码<ul><li>奇偶校验码</li><li>循环冗余码</li></ul></li><li>纠错编码<ul><li>海明码</li></ul></li></ul><h2 id="2、流量控制"><a href="#2、流量控制" class="headerlink" title="2、流量控制"></a>2、流量控制</h2><p>主要通过滑动窗口协议，根据窗口大小分为：</p><ul><li>停止-等待协议：发送窗口 = 1，接收窗口 = 1</li><li>后退N帧协议（GBN）：发送窗口 &gt; 1，接收窗口 = 1</li><li>选择重传协议（SR）：发送窗口 &gt; 1，接收窗口 &gt; 1</li></ul><table><tr>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232122980.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123547.png" /></td>    <td><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232123892.png" /></td></tr>       </table><h2 id="3、介质访问控制"><a href="#3、介质访问控制" class="headerlink" title="3、介质访问控制"></a>3、介质访问控制</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232127804.png" style="zoom: 33%;" /><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><blockquote><p>CSMA/CD 为载波侦听多路访问/冲突检测，是像以太网这种广播网络采用的一种机制，我们知道在以太网中多台主机在同一个信道中进行数据传输，CSMA/CD 很好的解决了共享信道通信中出现的问题，它的工作原理主要包括两个部分：</p><ul><li><strong>载波监听</strong>：当使用 CSMA/CD 协议时，总线上的各个节点都在监听信道上是否有信号在传输，如果有的话，表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据。</li><li><strong>冲突检测</strong>：当两个或两个以上节点同时监听到信道空闲，便开始发送数据，此时就会发生碰撞（数据的传输延迟也可能引发碰撞）。当两个帧发生冲突时，数据帧就会破坏而失去了继续传输的意义。在数据的发送过程中，以太网是一直在监听信道的，当检测到当前信道冲突，就立即停止这次传输，避免造成网络资源浪费，同时向信道发送一个「冲突」信号，确保其它节点也发现该冲突。之后采用一种二进制退避策略让待发送数据的节点随机退避一段时间之后重新。</li></ul></blockquote><p>CSMA/CD的工作流程可以概括为：</p><ol><li>先听后发</li><li>边发边听</li><li>冲突停发</li><li>随机重发</li></ol><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232130101.png" style="zoom:33%;" /><blockquote><p>CSMA/CD: 载波监听多路访问 / 碰撞检测（Detect），用于有线局域网（LAN）<br>CSMA/CA: 载波监听多路访问 / 碰撞避免（Avoid），用于无线局域网（WIFI）</p></blockquote><h2 id="4、PPP-协议"><a href="#4、PPP-协议" class="headerlink" title="4、PPP 协议"></a>4、PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP（点对点） 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112232140255.png" style="zoom: 33%;" /><h2 id="5、MAC-地址"><a href="#5、MAC-地址" class="headerlink" title="5、MAC 地址"></a>5、MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><blockquote><p>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。<br>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</p></blockquote><h3 id="为什么需要-MAC-地址"><a href="#为什么需要-MAC-地址" class="headerlink" title="为什么需要 MAC 地址"></a>为什么需要 MAC 地址</h3><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p><h3 id="为什么需要-IP-地址"><a href="#为什么需要-IP-地址" class="headerlink" title="为什么需要 IP 地址"></a>为什么需要 IP 地址</h3><p>光有MAC地址的话，寻址困难。IP地址和地域有关，可以分区域寻址，效率更高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; 是OSI参考模型中的第二层，介乎于物理层和网络层之间。&lt;/p&gt;
&lt;p&gt;功能：在物理层提供服务的基础上向网络层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最基本的服务：&lt;strong&gt;将源自于物理层的数据可靠地传输到相邻结点到目标机网络层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;主要作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路&lt;/li&gt;
&lt;li&gt;为网络层提供服务：&lt;ul&gt;
&lt;li&gt;无确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的无连接服务&lt;/li&gt;
&lt;li&gt;有确认的面向连接服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PPP（Point to Point Protocol）点-点协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链路层设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机&lt;/li&gt;
&lt;li&gt;网桥&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>开源安卓应用推荐</title>
    <link href="http://blog.sukiu.top/Share/Open-Source-Apk-Share/"/>
    <id>http://blog.sukiu.top/Share/Open-Source-Apk-Share/</id>
    <published>2021-12-22T10:11:16.000Z</published>
    <updated>2021-12-22T11:11:30.007Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一些开源的安卓应用，可以在 <a href="https://www.f-droid.org/">F-Droid</a>或 <a href="https://github.com/">GitHub</a> 下载，主要是一些软件的第三方。</p><span id="more"></span><h2 id="F-Droid-第三方"><a href="#F-Droid-第三方" class="headerlink" title="F-Droid 第三方"></a>F-Droid 第三方</h2><h3 id="Aurora-Droid"><a href="#Aurora-Droid" class="headerlink" title="Aurora Droid"></a>Aurora Droid</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.adroid/">Aurora Droid</a></p><p>Aurora 家族成员，界面仿 PlayStroe 风格，不过上次更新已经是3月了，个人体验下来有点卡顿的感觉，没有中文。</p><p>推荐指数：⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss001.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss002.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss003.png" /></td><td><img src="https://f-droid.org/repo/com.aurora.adroid/en-US/phoneScreenshots/ss004.png" /></td></tr></table><h3 id="Droid-ify"><a href="#Droid-ify" class="headerlink" title="Droid-ify"></a>Droid-ify</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.looker.droidify/">Droid-ify</a></p><p>FoxyDroid 的 Fork，Matrial you风格，更新勤快，界面简洁且好看，内置了不少仓库，支持中文。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-light.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/app-amoled.png" style="zoom:10%;" /></td><td><img src="https://f-droid.org/repo/com.looker.droidify/en-US/phoneScreenshots/home-amoled.png" style="zoom:10%;" /></td></tr></table><h2 id="Play-Stroe-第三方"><a href="#Play-Stroe-第三方" class="headerlink" title="Play Stroe 第三方"></a>Play Stroe 第三方</h2><h3 id="Aurora-Store"><a href="#Aurora-Store" class="headerlink" title="Aurora Store"></a>Aurora Store</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.aurora.store/">Aurora Store</a></p><p>Auroara 家族成员，美观且支持匿名登录和选区。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss001.png"/</td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss002.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss003.png"/></td><td><img src="https://f-droid.org/repo/com.aurora.store/en-US/phoneScreenshots/ss004.png"/></td></tr></table><h2 id="Telegram-第三方"><a href="#Telegram-第三方" class="headerlink" title="Telegram 第三方"></a>Telegram 第三方</h2><h3 id="Nekogram-X"><a href="#Nekogram-X" class="headerlink" title="Nekogram X"></a>Nekogram X</h3><p><a href="https://f-droid.org/zh_Hans/packages/nekox.messenger/">Nekogram X</a></p><p>可以说专门为国人定制的了，自定义选项都很实用，可以自由选择 FCM 推送。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Reddit-第三方"><a href="#Reddit-第三方" class="headerlink" title="Reddit 第三方"></a>Reddit 第三方</h2><h3 id="Infinity-for-Reddit"><a href="#Infinity-for-Reddit" class="headerlink" title="Infinity for Reddit"></a>Infinity for Reddit</h3><p><a href="https://f-droid.org/zh_Hans/packages/ml.docilealligator.infinityforreddit/">Infinity for Reddit</a></p><p>自定义项多，支持安卓12 Material you，没有广告，比官方的好用多了。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/1.png"/</td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/6.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/7.png"/></td><td><img src="https://f-droid.org/repo/ml.docilealligator.infinityforreddit/en-US/phoneScreenshots/8.png"/></td></tr></table><h2 id="Youtube-第三方"><a href="#Youtube-第三方" class="headerlink" title="Youtube 第三方"></a>Youtube 第三方</h2><h3 id="NewPipe"><a href="#NewPipe" class="headerlink" title="NewPipe"></a>NewPipe</h3><p><a href="https://f-droid.org/zh_Hans/packages/org.schabi.newpipe/">NewPipe</a></p><p>不需要登陆，没有广告，更新勤快，对轻度使用者极其友好。<br>可惜不能自定义外观，略丑。</p><p>推荐指数：⭐⭐⭐⭐</p><table><tr><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_01.png"/</td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_02.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_06.png"/></td><td><img src="https://f-droid.org/repo/org.schabi.newpipe/en-US/phoneScreenshots/shot_07.png"/></td></tr></table><h2 id="Twitter-第三方"><a href="#Twitter-第三方" class="headerlink" title="Twitter 第三方"></a>Twitter 第三方</h2><h3 id="Twidere-X"><a href="#Twidere-X" class="headerlink" title="Twidere X"></a>Twidere X</h3><p><a href="https://f-droid.org/zh_Hans/packages/com.twidere.twiderex/">Twidere X</a></p><p>支持登录 Twitter 和 Mastodon，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><h2 id="Pixiv-第三方"><a href="#Pixiv-第三方" class="headerlink" title="Pixiv 第三方"></a>Pixiv 第三方</h2><h3 id="Pixiv-Shaft"><a href="#Pixiv-Shaft" class="headerlink" title="Pixiv-Shaft"></a>Pixiv-Shaft</h3><p><a href="https://github.com/CeuiLiSA/Pixiv-Shaft">Pixiv-Shaft</a></p><p>美观，且支持浏览部分热点排序，完美替代原版。</p><p>推荐指数：⭐⭐⭐⭐⭐</p><table><tr><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-0.jpg"/</td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-3.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-4.jpg"/></td><td><img src="https://cdn.jsdelivr.net/gh/CeuiLiSA/Pixiv-Shaft/snap/QQ20200106-5.jpg"/></td></tr></table><h2 id="贴吧-第三方"><a href="#贴吧-第三方" class="headerlink" title="贴吧 第三方"></a>贴吧 第三方</h2><h3 id="TiebaLite"><a href="#TiebaLite" class="headerlink" title="TiebaLite"></a>TiebaLite</h3><p><a href="https://github.com/HuanCheng65/TiebaLite">TiebaLite: 贴吧 Lite</a></p><p>测试版仍在更新，评论容易封号，适合只浏览。</p><p>推荐指数：⭐⭐⭐⭐</p><h2 id="V2EX-第三方"><a href="#V2EX-第三方" class="headerlink" title="V2EX 第三方"></a>V2EX 第三方</h2><h3 id="V2er"><a href="#V2er" class="headerlink" title="V2er"></a>V2er</h3><p><a href="https://github.com/v2er-app/Android">V2er.Android</a></p><p>原来付费，现在作者开源了，体验最好的 V2EX 第三方。</p><p>推荐指数：⭐⭐⭐⭐⭐</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;推荐一些开源的安卓应用，可以在 &lt;a href=&quot;https://www.f-droid.org/&quot;&gt;F-Droid&lt;/a&gt;或 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 下载，主要是一些软件的第三方。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://blog.sukiu.top/categories/Share/"/>
    
    
    <category term="App" scheme="http://blog.sukiu.top/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://blog.sukiu.top/Computer-network/Network-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Network-Layer/</id>
    <published>2021-12-22T06:57:49.000Z</published>
    <updated>2021-12-22T10:30:44.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络层</strong>（<strong>Network Layer</strong>）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。<br>由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。</p><p>网络层协议负责提供<strong>主机</strong>间的逻辑通信；传输层协议负责提供<strong>进程</strong>间的逻辑通信。</p><p>功能：</p><ul><li>路由选择与分组转发 <strong>最佳路径</strong></li><li>异构网络互联</li><li>拥塞控制</li></ul><p>网络层重要协议：</p><ul><li>IP（Internet Protocol）网际互连协议</li></ul><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>ARP（Address Resolution Protocol）地址解析协议</li><li>ICMP（Internet Control Message Protocol）网际控制报文协议</li><li>IGMP（Internet Group Management Protocol）网际组管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esz3b2/">力扣</a><br>王道考研</p></blockquote><h2 id="1、IP"><a href="#1、IP" class="headerlink" title="1、IP"></a>1、IP</h2><p>该协议工作在网络层，主要目的就是为了提高网络的可扩展性。</p><p>和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP 协议族的核心。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221614969.png" style="zoom: 67%;" /><p>IP 协议主要有以下几个作用：</p><ul><li><strong>寻址和路由</strong>：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li></ul><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><p>总长度单位1B，片位移单位8B，首部单位4B</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221622589.png" style="zoom:50%;" /><blockquote><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></blockquote><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221624491.png" style="zoom: 60%;" /><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>IP地址由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221637019.png" style="zoom: 33%;" /><p>以上分类还空出一些地址，这些特殊的地址包括：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221639252.png" style="zoom:60%;" /><p>另外还有私有地址（局域网）：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221641441.png" style="zoom: 33%;" /><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p><code>IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221643433.png" style="zoom: 40%;" /><p>子网掩码：主机位全0，其他全1（网络位、子网位）</p><h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>NAT（Network Address Translation)，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。</p><p>该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p><blockquote><p>在专用网连接到因特网（公用地址）的路由器上安装NAT软件（NAT路由器），它至少有一个有效的外部全球IP地址</p><ul><li>NAT路由器根据转换表替换源IP地址或者目的IP地址和端口号，所以转发数据报时需查看和转换传输层的端口号</li><li>普通路由器仅工作在网络层，不改变源IP和目的IP</li></ul></blockquote><p>NAT 的实现有三种方式：</p><ul><li>静态转换，一对一，一个私有对应一个公有</li><li>动态转换，一对多，一个私有每次转换的公有不唯一</li><li>端口多路复用，多对一，多个私有共享一个合法的外部IP，映射到了不同的端口上</li></ul><h4 id="CIDR-无分类域间路由选择"><a href="#CIDR-无分类域间路由选择" class="headerlink" title="CIDR 无分类域间路由选择"></a>CIDR 无分类域间路由选择</h4><p>CIDR（Classless Inter-Domain Routing）</p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p><code>IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</code></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221647430.png" style="zoom: 40%;" /><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>从根本上解决 IPV4 地址不够的问题。</p><blockquote><p>其他方法：<br>NAT：网络地址转换<br>DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址<br>（DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播方式进行交互，基于UDP）</p></blockquote><p>IPV6 将地址从32位（4B）扩大到了128位（64B）</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221715771.png" style="zoom: 78%;" /><h2 id="2、ARP"><a href="#2、ARP" class="headerlink" title="2、ARP"></a>2、ARP</h2><p>ARP（Address Resolution Protocol）地址解析协议，完成IP地址到MAC地址的映射（解决下一跳走哪的问题）</p><h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><ol><li>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong>，同一局域网内所有主机都能受到该请求</li><li>目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次）</li></ol><h3 id="典型情况"><a href="#典型情况" class="headerlink" title="典型情况"></a>典型情况</h3><ul><li>主机A发给本网络上的主机B：用ARP找到B的硬件地址</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址</li><li>路由器发给本网络的主机B：用ARP找到B的硬件地址</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li></ul><h2 id="3、ICMP"><a href="#3、ICMP" class="headerlink" title="3、ICMP"></a>3、ICMP</h2><p>ICMP（Internet Control Message Protocol）是网际控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）</li><li>辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>Ping</strong>：测试两个主机间的连通性，使用 ICMP 会送请求和回答报文</li><li><strong>TraceRoute</strong>：跟踪一个分组从源点到终点的路径，使用 ICMP 时间超过差错报告报文</li></ul><blockquote><p>ping 不通可能存在的问题：</p><ul><li>首先看网络是否连接正常，检查网卡驱动是否正确安装</li><li>局域网设置问题，检查 IP 地址是否设置正确</li><li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙</li><li>看是否被第三方软件拦截</li><li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到</li></ul></blockquote><h2 id="4、IGMP"><a href="#4、IGMP" class="headerlink" title="4、IGMP"></a>4、IGMP</h2><p>IGMP（Internet Group Management Protocol）网际组管理协议，让路由器知道局域网上是否有主机（的进程）参加或退出某个组播组。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221718842.png" style="zoom: 67%;" /><h2 id="5、路由器"><a href="#5、路由器" class="headerlink" title="5、路由器"></a>5、路由器</h2><p>路由器是网络层设备，通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。</p><p>路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</p><blockquote><p>交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</p></blockquote><h3 id="分组转发流程"><a href="#分组转发流程" class="headerlink" title="分组转发流程"></a>分组转发流程</h3><ol><li>从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络</li><li>判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器<strong>直接交付</strong>，否则执行 3</li><li>检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 4</li><li>逐条检查路由表，使用每一行的子网掩码与目的IP匹配。若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 5</li><li>若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 6</li><li>无法找到合适路由，向源主机报错</li></ol><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><ul><li>RIP（Routing Information Protocol）路由信息协议</li><li>OSPF（Open Shortest Path First）开放式最短路径优先</li><li>BGP（Border Gateway Protocol）边界网关协议</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112221732310.png" style="zoom:70%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;（&lt;strong&gt;Network Layer&lt;/strong&gt;）是 OSI模型 中的第三层（TCP/IP模型中的网际层），提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。&lt;br&gt;由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。&lt;/p&gt;
&lt;p&gt;网络层协议负责提供&lt;strong&gt;主机&lt;/strong&gt;间的逻辑通信；传输层协议负责提供&lt;strong&gt;进程&lt;/strong&gt;间的逻辑通信。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由选择与分组转发 &lt;strong&gt;最佳路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;异构网络互联&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP（Internet Protocol）网际互连协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARP（Address Resolution Protocol）地址解析协议&lt;/li&gt;
&lt;li&gt;ICMP（Internet Control Message Protocol）网际控制报文协议&lt;/li&gt;
&lt;li&gt;IGMP（Internet Group Management Protocol）网际组管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>传输层</title>
    <link href="http://blog.sukiu.top/Computer-network/Transport-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Transport-Layer/</id>
    <published>2021-12-21T11:17:05.000Z</published>
    <updated>2021-12-22T07:47:15.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层</strong>（<strong>Transport Layer</strong>）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。</p><p>功能：使用网络层服务，为应用层提供服务</p><ul><li>提供进程和进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li></ul><p>传输层的重要协议：</p><ul><li>TCP（Transmission Control Protocol）传输控制协议</li><li>UDP（User Datagram Protocol）用户数据报协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/">力扣</a><br>王道考研</p></blockquote><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212129515.png" style="zoom:33%;" /><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211934483.png" style="zoom: 40%;" /><blockquote><p>标志位：SYN（Synchronize）、ACK（ACKnowledge Character）<br>序号：seq<br>确认号：ack</p><p>第 2 次握手为什么还要传回 SYN：</p><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（seq）同步给客户端。</p></blockquote><h4 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h4><p>三次握手保证两点：</p><ul><li>保证双方都是双工通信：<ul><li>第一次握手，服务端确定客户端的发送正常</li><li>第二次握手，客户端确认服务端的收发正常</li><li>第三次握手，服务端确定客服端接收正常</li></ul></li><li>如果只有第二次握手，服务端发给客服端的包丢了之后：<ul><li>服务端直接建立了连接，端口就会一直开着</li><li>等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接</li><li>端口越来越多，造成服务器开销的浪费</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211949356.png" alt="image-20211221194951070" style="zoom: 33%;" /><h4 id="握手异常"><a href="#握手异常" class="headerlink" title="握手异常"></a>握手异常</h4><table><thead><tr><th>异常</th><th>如何处理</th><th>备注</th></tr></thead><tbody><tr><td>第一次握手 SYN 包丢失</td><td><strong>服务端</strong>不会进行任何相应的动作<br><strong>客户端</strong>在一段时间内没有收到服务器发来的确认报文， 会等待一段时间后重新发送 SYN 同步报文，<br>若仍没有回应，则重复上述直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1</td><td>客户端超时重传最大次数：<code>tcp_syn_retries</code>，默认5次（Linux 3.7 后为6次）</td></tr><tr><td>第二次握手 SYN、ACK 包丢失</td><td><strong>客户端</strong>会采取第一次握手失败时的动作（超时重传）<br><strong>服务端</strong>此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文（同样超时重传）</td><td>服务端超时重传最大次数：<code>tcp_synack_retries</code>，默认5次</td></tr><tr><td>第三次握手 ACK 包丢失</td><td>两次握手成功，<strong>客户端</strong>进入<code>ESTABLISHED</code>状态，<strong>服务端</strong>进入<code>SYN_REC</code>状态<br><strong>服务端</strong>收不到 ACK，就一直重传 SYN、ACK 包，直到超过最大次数，断开TCP连接<br><strong>客户端</strong>认为自己连接成功，开始向服务器端发送数据，服务端收到来自客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态</td><td></td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211951252.png" style="zoom: 40%;" /><blockquote><p>标志位：Fin（Finish）<br>阶段：FIN-WAIT（半关闭）</p><p>CLOSE-WAIT：是服务端发出第一次挥手（整体第二次）进入的状态</p><p>表示“我准备关闭了，但是还有自己的事情处理一下，你等我处理完”<br>等服务器处理好自己的数据业务，则表示“我准备好了”，再发送 FIN 包</p><p>TIME-WAIT：是第四次挥手后，客户端进入的状态，是客户端必要的等待时间。</p><p>目的是：等待服务端的对应端口关闭与客户端发送到服务端的数据到达（可能出现延迟）</p><p>如果不存在这个步骤就会导致两个问题:</p><ul><li><p>客户端立即关闭后，立即又用同样的端口握手并建立通信，此时上次的连接残留的数据包会被误认为是本次的，造成数据异常</p></li><li><p>客户端直接关闭后，若服务端重新发送 FIN 包，客户端就会回应 RST，会报异常，但是实际没有问题的</p></li></ul><p>MSL（Maximum Segment Lifetime）：指一段 TCP 报文在传输过程中的最大生命周期</p><p>2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长，为的是确认服务器能否接收到客户端发出的 ACK 确认报文</p></blockquote><h4 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h4><p>简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。</p><p>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的：</p><ul><li>当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文</li><li>当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212000734.png" style="zoom:33%;" /><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP 如何保证可靠传输：</p><ul><li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li><li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li><li><strong>流量控制</strong>：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li><li><strong>拥塞控制</strong>：当网络某个节点发生拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li></ul><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p>在已发送但未确认的报文被确认之前，发送方的滑动窗口将不会滑动（类比滑动窗口算法）</p><h4 id="最大连接数限制"><a href="#最大连接数限制" class="headerlink" title="最大连接数限制"></a>最大连接数限制</h4><ul><li><strong>Client 最大 TCP 连接数</strong>：TCP 端口的数据类型是 unsigned short（$2^{16}$），可用端口最多有 65535 个（除端口0）</li><li><strong>Server最大 TCP 连接数</strong>：客户端 IP 数 × 客户端 port 数（理论）</li></ul><blockquote><p>对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 $2^{32}$（IP 数）× $2^{16}$（port 数），即约为$2^{48}$</p></blockquote><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212120334.png" style="zoom: 33%;" /><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><p>常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212127381.png" style="zoom: 40%;" /><blockquote><p><strong>拥塞控制和流量控制的区别：</strong><br>拥塞控制往往是一种全局的控制，防止过多的数据注入到网络之中<br>流量控制往往指点对点通信量的控制，是端到端的问题（TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处）</p></blockquote><h2 id="2、UDP"><a href="#2、UDP" class="headerlink" title="2、UDP"></a>2、UDP</h2><h3 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212131402.png" style="zoom: 33%;" /><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20~60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8个字节</td></tr></tbody></table><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212058636.png" style="zoom: 50%;" /><h3 id="不可靠传输"><a href="#不可靠传输" class="headerlink" title="不可靠传输"></a>不可靠传输</h3><ul><li>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，当对方接收缓冲区满了后就会丢弃，因此 UDP 不能保证数据能够到达目的地</li><li>UDP 没有流量控制和重传机制</li><li>UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号</li></ul><blockquote><p>调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。<br>调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。<br>当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p></blockquote><h2 id="3、More"><a href="#3、More" class="headerlink" title="3、More"></a>3、More</h2><h3 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。<br>通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;（&lt;strong&gt;Transport Layer&lt;/strong&gt;）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。&lt;/p&gt;
&lt;p&gt;功能：使用网络层服务，为应用层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供进程和进程之间的逻辑通信&lt;/li&gt;
&lt;li&gt;复用和分用&lt;/li&gt;
&lt;li&gt;传输层对收到的报文进行差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP（Transmission Control Protocol）传输控制协议&lt;/li&gt;
&lt;li&gt;UDP（User Datagram Protocol）用户数据报协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://blog.sukiu.top/Computer-network/Application-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Application-Layer/</id>
    <published>2021-12-12T07:28:27.000Z</published>
    <updated>2021-12-22T07:47:09.653Z</updated>
    
    <content type="html"><![CDATA[<p><strong>应用层</strong>（<strong>Application layer</strong>）位于 <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" title="OSI模型">OSI模型</a>的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。</p><p>应用层的功能：</p><ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>应用层的重要协议：</p><ul><li>HTTP（HyperText Transfer Protocol）超文本传输协议</li><li>FTP（File Transfer Protocol）文件传输协议<ul><li>TFTP（Trivial File Transfer Protocol）简单文件传输协议</li></ul></li><li>DNS（Domain Name System）域名系统</li><li>SMTP（Simple Mail Transfer Protocol）简单邮件传输协议<ul><li>POP3（Post Office Protocol - Version 3）邮局协议</li></ul></li><li>DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议</li><li>SNMP（Simple Network Management Protocol）简单网络管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eksi0s/">力扣</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP Headers - HTTP | MDN</a></p></blockquote><h2 id="1、HTTP"><a href="#1、HTTP" class="headerlink" title="1、HTTP"></a>1、HTTP</h2><h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(General Header Fields)</li><li>请求头字段(Request Header Fields)</li><li>响应头字段(Response Header Fields)</li><li>实体头字段(Entity Header Fields)</li></ul><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>同时适用于请求和响应消息（客户端和服务器都可以使用），但与最终消息主体中传输的数据无关的消息头。</p><p>可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中是否使用缓存机制</td><td>Cache-Control: no-store</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td>Connection: keep-alive (Upgrade)</td></tr><tr><td>Date</td><td>报文创建时间</td><td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td></tr><tr><td>Trailer</td><td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td><td>Trailer: Expiress</td></tr><tr><td>Transfer-Encoding</td><td>用来改变报文格式</td><td>Transfer-Encoding: chunked</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容中可能存在错误</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h4><p>包含更多有关要获取的资源或客户端本身信息的消息头，如Accept头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器自己允许哪些媒体类型</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>浏览器申明可接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己接收的编码方法</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的响应内容语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于表示 HTTP 协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号</td><td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td></tr><tr><td>If-XXX</td><td>条件请求</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数</td><td>Max-Forwards: 10</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以 0 开始</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td><td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td>User-Agent: Mozilla/……</td></tr></tbody></table><h4 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h4><p>包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头，如Server头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>字段的值表示可用于定义范围的单位</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>创建响应的时间</td><td>Age：5744337</td></tr><tr><td>ETag</td><td>唯一标识分配的资源</td><td>Etag：W/"585cd998-7c0f"</td></tr><tr><td>Location</td><td>表示重定向后的 URL</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>告知客户端多久后再发送请求</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>告知客户端服务器信息</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Vary</td><td>缓存控制</td><td>Vary: Origin</td></tr></tbody></table><h4 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h4><p>请求/响应报文中实体部分的首部，包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型，如Content-Type头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p><strong>非Keep-alive</strong>：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。<br><strong>Keep-alive</strong>：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。</p><h5 id="长连接-or-短链接"><a href="#长连接-or-短链接" class="headerlink" title="长连接 or 短链接"></a>长连接 or 短链接</h5><p><a href="https://blog.csdn.net/luzhensmart/article/details/87186401">http的长连接和短连接（史上最通俗！）以及应用场景_luzhensmart的专栏-CSDN博客_长连接和短连接的使用场景</a></p><p><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接</strong>：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h4 id="报文长度"><a href="#报文长度" class="headerlink" title="报文长度"></a>报文长度</h4><p>长度在响应报文中有两种表现形式。</p><ol><li>对于小点的文件，直接给出 content-length，也就是本次返回的数据长度</li><li>对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分块传输，这也是订好了协议，客户端收到了会进行组装，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</li></ol><p>曾经用 py 写过下载脚本，就利用了分块传输的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_size = <span class="built_in">int</span>(r.headers[<span class="string">&#x27;content-length&#x27;</span>])</span><br><span class="line"><span class="keyword">with</span> tqdm(total=file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, unit_divisor=<span class="number">1024</span>, <span class="built_in">ascii</span>=<span class="literal">True</span>,desc=filename) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            fp.write(chunk)</span><br><span class="line">            bar.update(<span class="built_in">len</span>(chunk))</span><br></pre></td></tr></table></figure><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>HTTP/1.0 定义了三种请求方法：<code>GET</code>, <code>POST</code> 和 <code>HEAD</code> 方法。</p><p>HTTP/1.1 增加了六种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p><p><del>感觉实际生产中很少会用那6种方法，极大的复杂化了api</del></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h4 id="GET-or-POST"><a href="#GET-or-POST" class="headerlink" title="GET or POST"></a>GET or POST</h4><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）</li></ul><blockquote><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。<br>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p></blockquote><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限制</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP包头<br>如果数据是中文或其它字符，则进行BASE64编码。</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><p><strong>长度限制：</strong></p><ul><li>GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</li><li>POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</li></ul><h3 id="HTTP-状态"><a href="#HTTP-状态" class="headerlink" title="HTTP 状态"></a>HTTP 状态</h3><p>HTTP 协议是<strong>无连接无状态</strong>的，并不保存关于客户端的任何信息。<br>通常有两种方法保持会话：</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。</p><blockquote><p>优点：安全性高，因为状态信息保存在服务器端。<br>缺点：由于大型网站往往采用的是分布式服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。<br>【解决方法】：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息</p></blockquote><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。<br>客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。</p><blockquote><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。<br>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据；每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p></blockquote><h4 id="Cookie-被禁用"><a href="#Cookie-被禁用" class="headerlink" title="Cookie 被禁用"></a>Cookie 被禁用</h4><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。</p><p>HTTP 状态码共有 5 种类型：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1XX</td><td>指示信息--表示请求正在处理</td></tr><tr><td>2XX</td><td>成功--表示请求已被成功处理完毕</td></tr><tr><td>3XX</td><td>重定向--要完成的请求需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器端错误--服务器处理请求出现错误</td></tr></tbody></table><p>常见的状态码有如下几种：</p><ul><li><code>200 OK</code> 客户端请求成功</li><li><code>301 Moved Permanently</code> 请求永久重定向</li><li><code>302 Moved Temporarily</code> 请求临时重定向</li><li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li><li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li><li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li><li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><blockquote><p>更多可见 <a href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 状态码_w3cschool</a></p></blockquote><h4 id="面试对状态码常见问法"><a href="#面试对状态码常见问法" class="headerlink" title="面试对状态码常见问法"></a>面试对状态码常见问法</h4><h5 id="状态码-301-和-302-的区别"><a href="#状态码-301-和-302-的区别" class="headerlink" title="状态码 301 和 302 的区别"></a>状态码 301 和 302 的区别</h5><ul><li>301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</li><li>302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</li></ul><h5 id="HTTP-异常状态码"><a href="#HTTP-异常状态码" class="headerlink" title="HTTP 异常状态码"></a>HTTP 异常状态码</h5><p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p><h2 id="2、HTTPS"><a href="#2、HTTPS" class="headerlink" title="2、HTTPS"></a>2、HTTPS</h2><p>HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式：<br>首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性。<br>通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><table>    <tr>    <td>协议</td>    <td>特点</td>    <td>工作方式</td>    </tr>    <tr>        <td>HTTP</td>        <td>        <li>明文传输，数据未加密，安全性较差        <li>默认 80 端口        <li>3 次握手建立连接        </td>        <td>        <ol>        <li>客户端请求服务器 80 端口，建立 TCP 连接        <li>客户端从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文        <li>服务端从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文        <li>通信结束，客户端与服务器关闭连接        </ol>        </td>    </tr>    <tr>        <td>HTTPS</td>        <td>        <li>加密，安全性较好        <li>默认 443 端口        <li>需数字认证机构（Certificate Authority, CA）的证书        <li>除 TCP 的 3 次握手，还需要 SSL 协商        </td>         <td>        <ol>        <li>客户端请求服务器 443 端口，建立 TCP 连接（包括支持算法，密钥长度等）        <li>服务端从双方共同支持的加密算法列表中选择一种返回给客户端（包括密钥组件）        <li>服务器返回自身 CA 证书的报文（包含证书的颁发机构、过期时间、服务端的公钥等信息）        <li>服务端发送一个完成报文通知客户端 SSL 的第一阶段已经<b>协商完成</b>        <li>客户端用本地证书库的根证书校验CA证书，生成随机密码串，用公钥加密发送给服务器，即回应报文        <li>紧接着客户端会发送一个报文提示服务端在此之后的报文是采用密码串加密的        <li>客户端发送一个 finish 报文（包含第一次握手至今所有报文的整体校验值）        <li>服务端同样发送与第 6 步中相同作用的报文，最后发送 finish 报文告诉客户端自己能够正确解密报文        <li>SSL 连接建立        </ol>        </td>    </tr></table><blockquote><p>CA 证书防止的方式：（为什么可以信任 CA 证书）<br>篡改：加密签名与原文签名对比<br>调包：请求域名与证书域名对比</p></blockquote><p>另附 HTTP 版本演变：</p><blockquote><p>直接造访 <a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez4zv6/">HTTP x.x</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161819417.png" style="zoom:67%;" /><h2 id="3、DNS"><a href="#3、DNS" class="headerlink" title="3、DNS"></a>3、DNS</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，提供了主机名和 IP 地址之间相互转换的服务。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161824712.png" style="zoom:80%;" /><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><ul><li><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<strong>帮你查</strong></li><li><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<strong>自己查</strong></li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。</p><p>大多数情况下 DNS 使用 UDP 进行传输，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><p>在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据</li></ul><blockquote><p>因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p></blockquote><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。</p><p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。</p><h4 id="预防手段"><a href="#预防手段" class="headerlink" title="预防手段"></a>预防手段</h4><ul><li>直接使用IP访问</li><li>直接指定DNS服务器（如谷歌的 8.8.8.8）</li></ul><h2 id="4、More"><a href="#4、More" class="headerlink" title="4、More"></a>4、More</h2><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><blockquote><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p></blockquote><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。<br>例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><ul><li>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li><li>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</li><li>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li></ul><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><ul><li>URL，即统一资源定位符 ( <em>Uniform Resource Locator</em> )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</li><li>URI，即统一资源标识符（ <em>Uniform Resource Identifier</em> ），只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL</li></ul><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul><li>其实就是将抓包工具视为中间人，其对于本地而言相当于服务端；而对于真正的服务端而言则相当于客户端；</li><li>抓包工具分别和本地以及服务器都进行TLS握手协商；</li><li>这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书）</li></ul><h3 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程"></a>网页解析全过程</h3><blockquote><p>这部分可以看看：<a href="https://github.com/skyline75489/what-happens-when-zh_CN"> 当···时发生了什么？what-happens-when</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161850389.png" style="zoom:67%;" /><ol><li><strong>DNS 解析</strong>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。</li><li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了</li><li><strong>发送 HTTP 请求</strong>：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</li></ol><blockquote><p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。<br>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p></blockquote><ol start="4"><li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li><li><strong>浏览器渲染</strong>：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li><strong>断开连接</strong>：客户端和服务器通过四次挥手终止 TCP 连接。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;（&lt;strong&gt;Application layer&lt;/strong&gt;）位于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B&quot; title=&quot;OSI模型&quot;&gt;OSI模型&lt;/a&gt;的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。&lt;/p&gt;
&lt;p&gt;应用层的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件传输、访问和管理&lt;/li&gt;
&lt;li&gt;电子邮件&lt;/li&gt;
&lt;li&gt;虚拟终端&lt;/li&gt;
&lt;li&gt;查询服务和远程作业登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP（HyperText Transfer Protocol）超文本传输协议&lt;/li&gt;
&lt;li&gt;FTP（File Transfer Protocol）文件传输协议&lt;ul&gt;
&lt;li&gt;TFTP（Trivial File Transfer Protocol）简单文件传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS（Domain Name System）域名系统&lt;/li&gt;
&lt;li&gt;SMTP（Simple Mail Transfer Protocol）简单邮件传输协议&lt;ul&gt;
&lt;li&gt;POP3（Post Office Protocol - Version 3）邮局协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议&lt;/li&gt;
&lt;li&gt;SNMP（Simple Network Management Protocol）简单网络管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络模型与协议</title>
    <link href="http://blog.sukiu.top/Computer-network/Models-And-Protocols/"/>
    <id>http://blog.sukiu.top/Computer-network/Models-And-Protocols/</id>
    <published>2021-12-09T01:17:18.000Z</published>
    <updated>2021-12-22T07:47:03.627Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络主要有3种模型：</p><ul><li>ISO/OSI参考模型 7层</li><li>TCP/IP参考模型 5层</li><li><strong>TCP/IP参考模型 4层</strong></li></ul><p><strong>OSI</strong>是一种理论下的<strong>模型</strong>，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekz8lr/">力扣</a><br>王道考研</p></blockquote><h2 id="1、参考模型"><a href="#1、参考模型" class="headerlink" title="1、参考模型"></a>1、参考模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。<br>OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112090939525.png" style="zoom:67%;" /><ul><li><strong>应用层</strong>：用户与网络的界面，通过应用程序间的交互来完成特定的网络应用</li></ul><blockquote><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。<br>例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。<br>在应用层交互的数据单元为报文。</p></blockquote><ul><li><strong>表示层</strong>：使通信的应用程序能够解释交换数据的含义<ul><li>数据格式变换 翻译官 <strong>数据描述</strong></li><li>数据加密解密 <strong>数据加密</strong></li><li>数据压缩和恢复 <strong>数据压缩</strong></li></ul></li></ul><blockquote><p>这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p></blockquote><ul><li><strong>会话层</strong>：负责建立、管理和终止表示层实体之间的通信会话。</li></ul><blockquote><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法（类似断点续传）。</p></blockquote><ul><li><p><strong>传输层</strong>：负责主机中两个进程的通信，即端到端通信。<font color="red">传输单位是报文段或用户数据报</font></p><ul><li><em>可</em> 靠传输、不可靠传输</li><li><em>差</em> 错控制</li><li><em>流</em> 量控制</li><li><em>复</em> 用分用（记忆：可差的也能流用？）<ul><li>复用：多个应用层进程可同时使用下面传输层的服务</li><li>分用：传输层把收到的信息分别交付给上面应用层相应的进程</li></ul></li></ul></li><li><p><strong>网络层</strong>：选择合适的网间路由和交换节点，确保数据按时成功传送。<font color="red">传输单位是数据报</font></p><ul><li><p>路由选择与分组转发 <strong>最佳路径</strong></p><blockquote><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。</p></blockquote></li><li><p>流量控制 <strong>发送速度</strong></p></li><li><p>差错控制</p></li><li><p>拥塞控制 <strong>总体速度</strong></p></li></ul></li><li><p><strong>数据链路层</strong>：把网络层传下来的数据报组装成帧。<font color="red">传输单位是帧</font></p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制 <strong>帧错+位错</strong></li><li>流量控制</li><li>访问（接入）控制 <strong>控制对信道的访问</strong></li></ul></li><li><p><strong>物理层</strong>：在物理媒体上实现比特流的透明传输。<font color="red">传输单位是比特</font></p><blockquote><p>尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么</p></blockquote><ul><li>定义接口特性（机械特性、电气特性、功能特性，过程特性）</li><li>定义传输模式 （单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li></ul><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><blockquote><p>由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。<br>三层都在应用程序内实现，程序间无法共享，合三为一就形成了 TCP/IP 模型。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091411643.png" style="zoom: 33%;" /><ul><li><p><strong>应用层</strong><br>  TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。</p><p>  例如：FTP、Telnet、DNS、SMTP 等。</p></li><li><p><strong>传输层</strong></p><p>  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。</p><p>  传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。</p><p>  其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p></li><li><p><strong>网际互联层</strong></p><p>  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。</p><p>  在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。</p><p>  根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。</p><p>  除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p></li><li><p><strong>网络接口层</strong></p><p>  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</p><p>  事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p></li></ul><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091513659.png" style="zoom: 67%;" /><h2 id="2、模型异同"><a href="#2、模型异同" class="headerlink" title="2、模型异同"></a>2、模型异同</h2><p><strong>相同点</strong></p><ul><li><p>OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p></li><li><p>都能够提供面向连接和无连接两种通信服务机制。</p></li></ul><p><strong>不同点</strong></p><ul><li><p>OSI 采用的七层模型； TCP/IP 是四层结构。</p></li><li><p>TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p></li><li><p>OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p></li><li><p>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p></li><li><p>OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091512496.png" alt="image-20211209151215402" style="zoom:50%;" /><h2 id="3、各层协议"><a href="#3、各层协议" class="headerlink" title="3、各层协议"></a>3、各层协议</h2><table>    <tbody><tr><th>OSI 七层网络模型</th><th>TCP/IP 四层概念模型</th><th>对应的网络协议</th>    </tr>    <tr><td>应用层（Application）</td><td rowspan="3">应用层</td>        <td><b>HTTP, FTP, DNS</b>, SMTP,TFTP,NFS, WAIS, Telnet, SNMP</td>    </tr>    <tr><td>表示层（Presentation）</td><td>TIFF, GIF, JPEG, PICT</td>    </tr>    <tr><td>会话层（Session）</td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>    </tr>    <tr><td>传输层（Transport）</td><td>传输层</td>        <td><b>TCP, UDP</b></td>    </tr>    <tr><td>网络层（Network）</td><td>网际层</td>        <td><b>IP</b>, ICMP, ARP, RARP, RIP, IPX</td>    </tr>    <tr><td>数据链路层（Data Link）</td><td rowspan="2">网络接口层</td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>    </tr>    <tr><td>物理层（Physical）</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>    </tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络主要有3种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO/OSI参考模型 7层&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型 5层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP/IP参考模型 4层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;是一种理论下的&lt;strong&gt;模型&lt;/strong&gt;，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://blog.sukiu.top/Database/Redis/"/>
    <id>http://blog.sukiu.top/Database/Redis/</id>
    <published>2021-12-07T01:22:55.000Z</published>
    <updated>2021-12-22T07:46:58.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis (Remote Dictionary Server ) 远程字典服务</strong>，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。</p><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。</p><p>和Memcached类似，它支持存储的value类型相对更多，包括：</p><ul><li>string（字符串）</li><li>list（链表）</li><li>set（集合）</li><li>zset（sorted set 有序集合）</li><li>hash（哈希类型）</li></ul><p>与 memcached 一样，为了保证效率，数据都是缓存在<strong>内存</strong>中。<br>区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://www.w3cschool.cn/redis/">Redis 教程_w3cschool</a><br><a href="https://juejin.cn/post/6909672227734552583">Redis使用教程 - 掘金</a></p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高 </li></ul><blockquote><p>Redis能读的速度是110000次/s,写的速度是81000次/s 。</p></blockquote><ul><li>丰富的数据类型</li></ul><blockquote><p>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p></blockquote><ul><li>原子</li></ul><blockquote><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p></blockquote><ul><li>丰富的特性</li></ul><blockquote><p>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h4 id="Redis-与其他-key-value-存储的区别"><a href="#Redis-与其他-key-value-存储的区别" class="headerlink" title="Redis 与其他 key-value 存储的区别"></a>Redis 与其他 key-value 存储的区别</h4><ul><li>Redis 运行在内存中但是可以 <strong>持久化到磁盘</strong>，重启的时候可以再次加载进行使用。</li><li>Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。</li><li>Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。</li></ul><h4 id="Redis-和-MongoDB-的区别"><a href="#Redis-和-MongoDB-的区别" class="headerlink" title="Redis 和 MongoDB 的区别"></a>Redis 和 MongoDB 的区别</h4><p>更多可见：<a href="https://zhuanlan.zhihu.com/p/86777551">NoSQL，浅谈redis与mongoDB的区别 - 知乎</a></p><ul><li><strong>性能方面</strong>，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB；</li><li><strong>可操作性上</strong>，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 <strong>丰富的查询语言</strong>，操作比 Redis 更为便利；</li><li><strong>内存及存储方面</strong>，MongoDB 适合 <strong>大数据量存储</strong>，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 <strong>虚拟内存特性</strong>，突破物理内存限制，数据可以设置时效性；</li><li><strong>对于数据持久化和数据恢复</strong>，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能；</li><li><strong>在数据一致性上</strong>，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行；</li><li><strong>数据分析上</strong>，MongoDB 内置 <strong>数据分析功能（mapreduce）</strong>，而 Redis 不支持数据分析；</li><li><strong>应用场景不同</strong>，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Redis</code>支持五种数据类型：</p><ul><li><code>string（字符串）</code></li><li><code>hash（哈希）</code></li><li><code>list（列表）</code></li><li><code>set（集合）</code></li><li><code>zset(sorted set：有序集合)</code></li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>最基本的类型，一个<code>key</code>对应一个<code>value</code>。<br><code>string</code>类型是二进制安全的，即<code>redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</p><blockquote><p>一个键最大能存储512MB。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sukiu.top&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-strings.html">Redis 字符串(String)_w3cschool</a></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p><code>Redis hash</code> 是一个键值 <code>(key=&gt;value)</code> 对集合。<br><code>Redis hash</code> 是一个 <code>string</code> 类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象。</p><blockquote><p>每个 <code>hash</code> 可以存储 232 - 1键值对（40多亿）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">3) <span class="string">&quot;password&quot;</span></span><br><span class="line">4) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">5) <span class="string">&quot;points&quot;</span></span><br><span class="line">6) <span class="string">&quot;200&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;password&quot;</span></span><br><span class="line">3) <span class="string">&quot;points&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-hashes.html">Redis 哈希(Hash)_w3cschool</a></p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>Redis</code> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><blockquote><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange <span class="built_in">test</span> 0 10</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-lists.html">Redis 列表(List)_w3cschool</a></p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>Redis</code> 的 <code>Set</code>是 <code>string</code> 类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><blockquote><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd t1 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers t1</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sets.html">Redis 集合(Set)_w3cschool</a></p><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>和 <code>set</code> 不同的是每个元素都会关联一个 <code>double</code> 类型的分数。<code>redis</code> 正是通过分数来为集合中的成员进行从小到大的排序。</p><p><code>zset</code> 的成员是唯一的,但分数<code>(score)</code>却可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd t2 0 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore t2 0 1000</span><br><span class="line">1) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">2) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sorted-sets.html">Redis 有序集合(sorted set)_w3cschool</a></p><h2 id="2、高级"><a href="#2、高级" class="headerlink" title="2、高级"></a>2、高级</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><blockquote><p>更多：<br><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理 - SegmentFault 思否</a></p></blockquote><p>Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。<br>Redis支持两种方式的持久化：RDB快照和AOF。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。<br>它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。<br>到目前为止，仍是官方的默认支持方案。</p><p><strong>原理：</strong> Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><blockquote><p>整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。</p></blockquote><p><strong>优点</strong>:</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要不高</li></ol><p><strong>缺点</strong>：</p><ol><li>需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了</li><li>fork进程的时候，会占用一定的内容空间</li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File），它是Redis的完全持久化策略。</p><p><strong>原理：</strong> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。<br>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no-关闭，yes-开启，默认no</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;appendonTy.aof&quot;</span> <span class="comment">#持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always #每次修改都会sync,消耗性能 </span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒执行一次sync,可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快!</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>每一次修改都同步，文件的完整会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong>：</p><ol><li>相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><ul><li>前者称为主节点(master/leader)</li><li>后者称为从节点(slavel/follower)</li><li>数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</li></ul><blockquote><p>默认情况下，每台Redis服务器都是主节点<br>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</p></blockquote><p>主从复制的作用主要包括:</p><ul><li>数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><blockquote><p>更多：<br><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780">redis系列之——高可用（主从、哨兵、集群）</a></p></blockquote><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><p>原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。<br>redis 为了避免单点故障，也需要部署多台机器。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071701844.png" alt="主从"></p><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。<br>实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 <del>自动选取老大的模式</del></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071704740.png" alt="哨兵" style="zoom:50%;" /><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。<br>在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071707386.png" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Redis (Remote Dictionary Server ) 远程字典服务&lt;/strong&gt;，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。&lt;/p&gt;
&lt;p&gt;Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string（字符串）&lt;/li&gt;
&lt;li&gt;list（链表）&lt;/li&gt;
&lt;li&gt;set（集合）&lt;/li&gt;
&lt;li&gt;zset（sorted set 有序集合）&lt;/li&gt;
&lt;li&gt;hash（哈希类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 memcached 一样，为了保证效率，数据都是缓存在&lt;strong&gt;内存&lt;/strong&gt;中。&lt;br&gt;区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Redis" scheme="http://blog.sukiu.top/tags/Redis/"/>
    
  </entry>
  
</feed>
