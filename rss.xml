<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakurasou</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2021-12-02T13:52:45.207Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL</title>
    <link href="http://blog.sukiu.top/Language/SQL/"/>
    <id>http://blog.sukiu.top/Language/SQL/</id>
    <published>2021-12-02T12:58:04.000Z</published>
    <updated>2021-12-02T13:52:45.207Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 语句可分为以下几类：</p><ul><li>数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 <code>CREATE</code>，<code>DROP</code>，<code>ALTER</code></li><li>数据查询语言 DQL（Data Query Language）：即查询操作，以 <code>SELECT</code> 关键字为主</li><li>数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 <code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code></li><li>数据控制功能 DCL（Data Control Language）：即权限控制操作，如 <code>GRANT</code>，<code>REVOKE</code>，<code>COMMIT</code>，<code>ROLLBACK</code></li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxsgh2/">常用 SQL 语句 - LeetCode</a><br><a href="https://juejin.cn/post/6983974232656969742">SQL约束 - 掘金</a></p></blockquote><h2 id="1、键"><a href="#1、键" class="headerlink" title="1、键"></a>1、键</h2><ul><li><strong>超键</strong>：在关系中，能唯一标识元组的属性集称为关系模式的超键。</li></ul><blockquote><p>一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<br>超键包含候选键和主键。</p></blockquote><ul><li><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</li><li><strong>主键</strong>：数据库表中对储存数据对象予以 <strong>唯一和完整标识的数据列或属性的组合</strong>。</li></ul><blockquote><p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</p></blockquote><ul><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><blockquote><p>外键可以有重复的, 可以是空值。</p></blockquote><h2 id="2、约束"><a href="#2、约束" class="headerlink" title="2、约束"></a>2、约束</h2><p>约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p><ul><li><strong>非空约束（NOT NULL）</strong>：保证该字段值一定不为空；</li><li><strong>默认约束（DEFAULT）</strong>：保证字段有默认值；</li><li><strong>主键约束（PRIMARY KEY）</strong>：标志一列或者多列，并保证其值在表内的唯一性；</li><li><strong>外键约束（FOREIGN KEY）</strong>：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；</li><li><strong>唯一约束（UNIQUE）</strong>： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；</li><li><strong>检查约束（CHECK）</strong>：限制一列的可用值范围。</li></ul><h3 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h3><ol><li>创建表时，在字段描述处，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key, <span class="comment">-- 添加了主键约束</span></span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表时，在constraint约束区域，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">INT</span>,</span><br><span class="line">  lastname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  firstname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> pk_persons <span class="keyword">PRIMARY</span> KEY (lastname, firstname) <span class="comment">-- 添加主键约束, 多个字段, 我们称为联合主键。</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建表之后，通过修改表结构，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加联合主键约束</span></span><br><span class="line"><span class="comment">-- 其他约束类似</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">add</span> <span class="keyword">constraint</span> pk_persons <span class="keyword">primary</span> key (lastname, firstname); </span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除主键约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP PRIMARY KEY</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除非空约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons modify lastname <span class="type">varchar</span>(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP INDEX 名称</span></span><br><span class="line"><span class="comment">-- 有唯一约束名称, 使用约束名称删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index uni_persons_address; </span><br><span class="line"><span class="comment">-- 没有唯一约束名称, 使用字段名删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index address; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、SQL语句"><a href="#3、SQL语句" class="headerlink" title="3、SQL语句"></a>3、SQL语句</h2><p>参考w3cschool即可：</p><blockquote><p><a href="https://www.w3cschool.cn/sql/sql-sentence.html">详尽的SQL语句大全分类整理_w3cschool</a></p></blockquote><p>下面列出一些重点：</p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。</p><ul><li><p><strong>交叉连接（CROSS JOIN）</strong></p><p>  除了在 <code>FROM</code> 子句中使用 <strong>逗号间隔连接的表</strong> 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 <strong>笛卡尔积</strong>，返回到的数据行数等于第一个表中符合查询条件的数据行数 <strong>乘以</strong> 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 <code>CROSS JOIN</code> 关键字而不是逗号，即以下两个表达式等价：</p><p>  <code>SELECT  *  FROM  A, B</code><br>  <code>SELECT  *  FROM  A  CROSS JOIN  B</code></p></li><li><p><strong>内连接（INNER JOIN）</strong></p><p>  内连接分为三类，分别是 <strong>等值连接</strong>：<code>ON A.id = B.id</code>、<strong>不等值连接</strong>：<code>ON A.id &gt; B.id</code> 和 <strong>自连接</strong>：<code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid</code></p></li><li><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><p>  <strong>左外连接</strong>：以左表为主，先查询出左表，按照 <code>ON</code> 后的关联条件匹配右表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>LEFT JOIN</code></p><p>  <strong>右外连接</strong>：以右表为主，先查询出右表，按照 <code>ON</code> 后的关联条件匹配左表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>RIGHT JOIN</code></p></li><li><p><strong>联合查询（UNION 与 UNION ALL）</strong></p><p>  <code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></p><p>  联合查询就是把多个结果集集中在一起，<code>UNION</code> 前的结果为基准，需要注意的是联合查询的 <strong>列数要相等</strong>，相同的记录行会合并；</p><p>  如果使用 <code>UNION ALL</code>，不会合并重复的记录行，所以效率更高。</p></li><li><p><strong>全连接（FULL JOIN）</strong></p><p>  MySQL 本身不支持全连接，但可以通过联合使用 <code>LEFT JOIN</code>、<code>UNION</code> 和 <code>RIGHT JOIN</code> 来实现。</p><p>  <code>SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id</code></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。</p><p>子查询是一个 <code>SELECT</code> 语句，它嵌套在另一个 <code>SELECT</code>、<code>SELECT…INTO</code> 语句、<code>INSERT…INTO</code> 语句、<code>DELETE</code> 语句、 <code>UPDATE</code> 语句或嵌套在另一子查询中。</p><p>MySQL 的子查询是多表查询的一个重要组成部分，常常和 <strong>连接查询</strong> 一起使用，是多表查询的基础。</p><p>子查询分为以下四类：</p><ul><li><p><strong>标量子查询</strong></p><p>  查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。</p></li><li><p><strong>列子查询</strong></p><p>  子查询返回的结果集是 N 行一列，该结果通常来自对表的 <strong>某个字段</strong> 查询返回。</p></li><li><p><strong>行子查询</strong></p><p>  子查询返回的结果集是一行 N 列，该结果通常是对表的 <strong>某行数据</strong> 进行查询而返回的结果集</p></li><li><p><strong>表子查询</strong></p><p>  子查询返回的结果集是 N 行 N 列的一个表数据。</p></li></ul><h3 id="char-与-varchar-的区别"><a href="#char-与-varchar-的区别" class="headerlink" title="char 与 varchar 的区别"></a>char 与 varchar 的区别</h3><ul><li>char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；</li><li>使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；</li></ul><h3 id="DROP、DELETE-与-TRUNCATE-的区别"><a href="#DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="DROP、DELETE 与 TRUNCATE 的区别"></a>DROP、DELETE 与 TRUNCATE 的区别</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">DROP</th><th style="text-align:center">DELETE</th><th style="text-align:center">TRUNCATE</th></tr></thead><tbody><tr><td style="text-align:center">SQL 语句类型</td><td style="text-align:center">DDL</td><td style="text-align:center">DML</td><td style="text-align:center">DDL</td></tr><tr><td style="text-align:center">回滚</td><td style="text-align:center">不可回滚</td><td style="text-align:center">可回滚</td><td style="text-align:center">不可回滚</td></tr><tr><td style="text-align:center">删除内容</td><td style="text-align:center">从数据库中 <strong>删除表</strong>，所有的数据行，索引和权限也会被删除</td><td style="text-align:center">表结构还在，删除表的 <strong>全部或者一部分数据行</strong></td><td style="text-align:center">表结构还在，删除表中的 <strong>所有数据</strong></td></tr><tr><td style="text-align:center">删除速度</td><td style="text-align:center">删除速度最快</td><td style="text-align:center">删除速度慢，需要逐行删除</td><td style="text-align:center">删除速度快</td></tr></tbody></table><blockquote><p>在不再需要一张表的时候，采用 <code>DROP</code><br>在想删除部分数据行时候，用 <code>DELETE</code><br>在保留表而删除所有数据的时候用 <code>TRUNCATE</code></p></blockquote><h3 id="UNION-与-UNION-ALL-的区别"><a href="#UNION-与-UNION-ALL-的区别" class="headerlink" title="UNION 与 UNION ALL 的区别"></a>UNION 与 UNION ALL 的区别</h3><ul><li><code>UNION</code> 用于把来自多个 <code>SELECT</code> 语句的结果组合到一个结果集合中，MySQL 会把结果集中 <strong>重复的记录删掉</strong></li><li><code>UNION ALL</code>，MySQL 会把所有的记录返回，且效率高于 <code>UNION</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL 语句可分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 &lt;code&gt;CREATE&lt;/code&gt;，&lt;code&gt;DROP&lt;/code&gt;，&lt;code&gt;ALTER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据查询语言 DQL（Data Query Language）：即查询操作，以 &lt;code&gt;SELECT&lt;/code&gt; 关键字为主&lt;/li&gt;
&lt;li&gt;数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 &lt;code&gt;INSERT&lt;/code&gt;，&lt;code&gt;UPDATE&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据控制功能 DCL（Data Control Language）：即权限控制操作，如 &lt;code&gt;GRANT&lt;/code&gt;，&lt;code&gt;REVOKE&lt;/code&gt;，&lt;code&gt;COMMIT&lt;/code&gt;，&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
    <category term="SQL" scheme="http://blog.sukiu.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>B Tree</title>
    <link href="http://blog.sukiu.top/Data-structure/B-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/B-Tree/</id>
    <published>2021-11-29T11:07:44.000Z</published>
    <updated>2021-12-02T01:03:01.825Z</updated>
    
    <content type="html"><![CDATA[<p>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。</p><ul><li>特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；</li><li>把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。</li></ul><span id="more"></span><blockquote><p>转载：</p><p><a href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p></blockquote><h2 id="1、B-树-B-tree"><a href="#1、B-树-B-tree" class="headerlink" title="1、B 树(B-tree)"></a>1、B 树(B-tree)</h2><blockquote><p>注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树;</p></blockquote><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构</p><p><strong>规则：</strong></p><ul><li>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉）</li><li>（3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2)</li><li>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子</li></ul><p><strong>例子：</strong></p><p>来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_b.jpg"/></p><h3 id="2、B-树的查询"><a href="#2、B-树的查询" class="headerlink" title="2、B 树的查询"></a>2、B 树的查询</h3><p>如上图我要从上图中找到 E 字母，查找流程如下</p><ul><li>（1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>（2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点；</li><li>（3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；</li></ul><h3 id="3、B-树的插入"><a href="#3、B-树的插入" class="headerlink" title="3、B 树的插入"></a>3、B 树的插入</h3><p>定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来;</p><ul><li>（1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）；</li><li>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li></ul><ol><li>先插入 3、8、31、11 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-e1d65c9c6236d4768c89e8e103e12583_b.jpg"/></li><li>再插入 23、29 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-66cdb6187cbc5227fd8c4aabe7282e6c_b.jpg"/></li><li>再插入 50、28 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-3057eaab2b1764dd51c2a8658791cc98_b.jpg"/></li></ol><h3 id="3、B-树的删除"><a href="#3、B-树的删除" class="headerlink" title="3、B 树的删除"></a>3、B 树的删除</h3><ul><li>（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li><li>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</li><li>（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-a0f981fc847772cb28869927cd4fe66d_b.jpg"/><h2 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a>2、B+树</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p>B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询<u>速度</u>更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别</p><ul><li>（1）B+跟B树不同B+树的<b>非叶子</b>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<b>非叶子</b>节点所能保存的关键字大大增加；</li><li>（2）B+树<b>叶子</b>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）;</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-5f069fd820637db1b877fdd6799a2b67_b.jpg"/><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_b.jpg"/><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>1、B+<b>树的层级更少</b>：相较于 B 树 B+每个<b>非叶子</b>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<b>树查询速度更稳定</b>：B+所有关键字数据地址都存在<b>叶子</b>节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定;</p><p>3、B+<b>树天然具备排序功能：</b>B+树所有的<b>叶子</b>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。</p><p>4、B+<b>树全节点遍历更快：</b>B+树遍历整棵树只需要遍历所有的<b>叶子</b>节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 <b>B 树</b>相对于<b>B+树</b>的优点是，如果经常访问的数据离根节点很近，而<b>B 树</b>的<b>非叶子</b>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<b>B+树</b>快。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="1、相同思想和策略"><a href="#1、相同思想和策略" class="headerlink" title="1、相同思想和策略"></a>1、相同思想和策略</h3><p>从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><h3 id="2、不同的方式的磁盘空间利用"><a href="#2、不同的方式的磁盘空间利用" class="headerlink" title="2、不同的方式的磁盘空间利用"></a>2、不同的方式的磁盘空间利用</h3><p>不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；&lt;/li&gt;
&lt;li&gt;把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://blog.sukiu.top/Database/Database-Introduction/"/>
    <id>http://blog.sukiu.top/Database/Database-Introduction/</id>
    <published>2021-11-27T01:58:35.000Z</published>
    <updated>2021-12-02T01:04:07.423Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库（Database）</strong> 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 <strong>数据库管理系统（DataBase- Management System，DBMS）</strong> 创建和操纵的容器。</p><p><strong>DBMS</strong> 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxhvpv/">数据库知识手册</a></p></blockquote><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>数据库有两种类型，分别是 <strong>关系型数据库</strong> 和 <strong>非关系型数据库</strong>。</p><table><thead><tr><th>数据库类型</th><th>定义</th><th>优点</th><th>缺点</th><th>常见</th></tr></thead><tbody><tr><td>关系型数据库</td><td>建立在关系模型基础上，由多张能互相连接的 <strong>表</strong> 组成的数据库</td><td>    <ol>    <li>使用表结构，格式一致，易于维护；    <li>使用 SQL 语句，可用于复杂查询；    <li>数据存储在磁盘中，安全性高    </ol></td><td>    <ol>    <li>读写性能比较差；    <li>建立在关系模型上，不可避免空间浪费；    <li>固定的表结构，灵活度较低    </ol></td><td>MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等</td></tr><tr><td>非关系型数据库</td><td>非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 <strong>对象</strong> 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</td><td>    <ol>    <li>存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛；    <li>可轻松进行海量数据的维护和处理；    <li>具有可扩展、高并发、高稳定性、成本低的优势；    <li>可以实现数据的分布式处理    </ol></td><td>    <ol>        <li>不提供 SQL 支持；    <li>无事务处理，无法保证数据的完整性和安全性；    <li>功能没有关系型数据库完善    </ol></td><td>Neo4j，Redis，MongoDB 等</td></tr></tbody></table><blockquote><p><strong>SQL</strong> 是 <strong>结构化查询语言（Structured Query Language）</strong> 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。</p><p><strong>MySQL</strong> 是一个 <strong>关系数据库管理系统（RDBMS）</strong>，使用 SQL 执行所有数据库操作。</p></blockquote><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB</li><li>完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB</li><li>传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。</p><p>常用的数据库三大范式为：</p><ul><li><strong>第一范式（1NF）</strong>：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。<strong>关系模式的基本要求</strong></li><li><strong>第二范式（2NF）</strong>：在第一范式的基础上，一个表必须有一个主键，非主键列 <strong>完全依赖</strong> 于主键，而不能是依赖于主键的一部分。<strong>消除部分依赖</strong></li><li><strong>第三范式（3NF）</strong>：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。<strong>消除传递依赖</strong></li></ul><h2 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h2><p>索引是一种 <strong>数据结构</strong>。数据库索引是 DBMS 中一个 <strong>排序的数据结构</strong>，以 <strong>协助快速查询、更新</strong> 数据库表中数据。</p><p>索引的实现通常使用 <a href="https://blog.sukiu.top/Data-structure/B-Tree/">B 树以及变种 B+ 树</a>。</p><p>以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。</p><table><tr><td>优点</td><td>缺点</td></tr><tr><td><ul>    <li>通过创建 <strong>唯一性索引 </strong>，可以保证数据库表中每一行数据的唯一性；    <li> 可以加快数据的  <strong>检索速度 </strong>，这也是创建索引的主要原因；    <li>可以加速表和表之间的连接，特别是在实现  <strong>数据的参考完整性 </strong> 方面特别有意义；    <li>通过使用索引，可以在查询的过程中，使用  <strong>优化隐藏器 </strong>，提高系统性能。</ul></td><td><ul>    <li>时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；    <li>空间上，索引需要占  <strong>物理空间 </strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</ul></td></tr></table><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>数据库索引根据结构分类，主要有 <strong>B 树索引</strong>（使用最频繁）、<strong>Hash 索引</strong> 和 <strong>位图索引</strong> 三种。</p><blockquote><p>关于 B 树可以参考：<a href="https://blog.sukiu.top/Data-structure/B-Tree/">B Tree</a></p></blockquote><p><strong>使用 B+ 树的优点：</strong></p><ul><li>由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。</li><li>B+ 树的叶结点由一条链相连，因此当需要进行一次 <strong>全数据遍历</strong> 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 <strong>大于某个关键字或者小于某个关键字的数据</strong> 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。</li></ul><p><strong>Hash 索引和 B+ 树索引的区别：</strong></p><ul><li>Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；</li><li>Hash 索引不支持使用索引进行排序；</li><li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；</li><li>Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；</li><li>Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。</li></ul><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引指将 <strong>数据存储</strong> 和 <strong>索引</strong> 放到一起，找到索引也就找到了数据。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/1628676447-LHnlSz-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="聚簇索引" style="zoom: 50%;" /><h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>数据库的 <strong>事务</strong>（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p><blockquote><p>如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。</p></blockquote><p>因此，事务是保持 <strong>逻辑数据一致性</strong> 和 <strong>可恢复性</strong> 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>事务具有 4 个特性，通常简称为 ACID，<strong>关系型数据库</strong> 需要遵循 ACID 规则。</p><ul><li><p>原子性（Atomicity）</p><p>  事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</p><blockquote><p>以银行转账事务为例：</p><p>如果该事务提交了，则这两个账户的数据将会更新；</p><p>如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 <strong>撤销</strong> 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。</p></blockquote></li><li><p>一致性（Consistency）</p><p>  当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。</p><blockquote><p>以银行转账事务事务为例：</p><p>在事务开始之前，所有 <strong>账户余额的总额处于一致状态</strong>。</p><p>在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。</p><p>因此，所有账户余额的总额处于不一致状态。</p><p>但是当事务完成以后，账户余额的总额再次恢复到一致状态。</p></blockquote></li><li><p>隔离性（Isolation）</p><p>  <strong>并发访问数据库</strong> 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</p><blockquote><p>修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。</p></blockquote></li><li><p>持久性（Durability）</p><p>  一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>DBMS 采用 <strong>日志</strong> 来保证事务的 <strong>原子性</strong>、<strong>一致性</strong> 和 <strong>持久性</strong>。</p><blockquote><p>日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></blockquote><p>DBMS 采用 <strong>锁机制</strong> 来实现事务的隔离性。</p><blockquote><p>当多个事务同时更新数据库中相同的数据时，只允许 <strong>持有锁的事务</strong> 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></blockquote><p><strong>相应的原理</strong></p><ul><li>原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li><li>一致性：一般由代码层面来保证</li><li>隔离性：由MVCC来保证</li><li>持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul><li><p>脏读（Dirty Read）</p><p>  一个事务读取了另一个事务未提交的数据。</p></li><li><p>不可重复读（Non-repeatable Read）</p><p>  就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。</p></li><li><p>幻读（Phantom Read）</p><p>  幻读是指当事务 <strong>不是独立执行时</strong> 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 <strong>插入一行新数据</strong>。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p></li><li><p>丢失更新（Lost Update）</p><p>  两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 <strong>并发事务对同一资源的读取深度层次</strong>。</p><p>由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE）</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交(RU)</td><td>只能保证不读取物理上的损坏</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交(RC)</td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读(RR)</td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化(SR)</td><td>最高级别，事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>从数据库系统的角度，锁模式可分为以下6 种类型：</p><ul><li><p><strong>共享锁（S）</strong>：又叫 <strong>他读锁</strong>。</p><p>  可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。</p></li><li><p><strong>排它锁（X）</strong>：又叫 <strong>独占锁</strong>、<strong>写锁</strong>。</p><p>  对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。</p></li><li><p><strong>更新锁（U）</strong>：</p><p>  防止出现 <strong>死锁</strong> 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。</p><p>  资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。</p></li><li><p><strong>意向锁</strong>：</p><p>  表示 SQL Server 需要在 <strong>层次结构中的某些底层资源上</strong> 获取共享锁或排它锁。</p><p>  例如，放置在 <strong>表级</strong> 的 <strong>共享意向锁</strong> 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。</p><p>  意向锁可以提高性能，因为 SQL Server 仅在 <strong>表级</strong> 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。</p><p>  意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。</p></li><li><p><strong>架构锁</strong>：</p><p>  在执行 <strong>依赖于表架构的操作</strong> 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。</p></li><li><p><strong>大容量更新锁（BU）</strong>：</p><p>  向表中大容量复制数据并指定了 <code>TABLOCK</code> 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>在 <strong>读取未提交</strong> 隔离级别下，读取数据不需要加 <strong>共享锁</strong>，这样就不会跟被修改的数据上的 <strong>排他锁</strong> 冲突；</li><li>在 <strong>读取已提交</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在语句执行完以后释放共享锁；</li><li>在 <strong>可重复读</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</li><li><strong>可串行化</strong> 是限制性最强的隔离级别，因为该级别 <strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><ul><li>如果不同程序并发存取多个表，尽量约定 <strong>以相同的顺序访问表</strong>，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到 <strong>一次锁定所需要的所有资源</strong>，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用 <strong>升级锁定颗粒度</strong>，通过 <strong>表级锁</strong> 定来减少死锁产生的概率。</li></ul><h3 id="乐-悲观锁"><a href="#乐-悲观锁" class="headerlink" title="乐/悲观锁"></a>乐/悲观锁</h3><p>DBMS 中的 <strong>并发控制</strong> 的任务是确保在 <strong>多个事务同时存取数据库中同一数据</strong> 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 <strong>读多写少</strong> 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库（Database）&lt;/strong&gt; 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 &lt;strong&gt;数据库管理系统（DataBase- Management System，DBMS）&lt;/strong&gt; 创建和操纵的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DBMS&lt;/strong&gt; 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://blog.sukiu.top/Knowledge/Bit-Operation/"/>
    <id>http://blog.sukiu.top/Knowledge/Bit-Operation/</id>
    <published>2021-11-25T11:12:14.000Z</published>
    <updated>2021-12-02T01:31:31.549Z</updated>
    
    <content type="html"><![CDATA[<p>计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。</p><p>位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。</p><p>上述位运算中，只有取反是一元运算，其余的都是二元运算。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math/o2zy8j/">位运算符的概念和性质</a></p></blockquote><h2 id="1、与、或、异或和取反"><a href="#1、与、或、异或和取反" class="headerlink" title="1、与、或、异或和取反"></a>1、与、或、异或和取反</h2><ul><li>与运算的符号是 $\And$ ，运算规则是：全 1 为 1，有 0 为 0</li><li>或运算的符号是 $∣$ ，运算规则是：有 1 为 1，全 0 为 0</li><li>异或运算的符号是 $\oplus$（在代码中用 $\wedge$ 表示异或），运算规则是：相同为 0 ，不同为 1</li><li>取反运算的符号是 $\sim$，运算规则是：0 变 1， 1 变 0</li></ul><h2 id="2、移位运算"><a href="#2、移位运算" class="headerlink" title="2、移位运算"></a>2、移位运算</h2><p>移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。</p><ul><li><p>左移运算的符号是 $&lt;&lt;$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。</p></li><li><p>右移运算的符号是 $&gt;&gt;$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：</p><ul><li>算术右移时，高位补最高位；</li><li>逻辑右移时，高位补 0。</li></ul></li></ul><blockquote><p>C++ 中：<br>对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。<br>Java 中：<br>不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。<br>算术右移的符号是 $&gt;&gt;$，逻辑右移的符号是 $&gt;&gt;&gt;$<br>Go 中：<br>只有算数移位</p></blockquote><h2 id="3、位运算与乘除法"><a href="#3、位运算与乘除法" class="headerlink" title="3、位运算与乘除法"></a>3、位运算与乘除法</h2><p>使用移位运算实现乘除法的效率显著<strong>高</strong>于直接乘除法的效率。</p><ul><li><p>左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$</p><ul><li><p>例如，$29 &lt;&lt; 2 = 116$，等价于 $ 29 \times 4  $</p></li><li><p>当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和：</p><p>  例如，$a \times 6$ 等价于 $(a&lt;&lt;2)+(a&lt;&lt;1)$</p></li><li><p>对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。</p></li></ul></li><li><p>算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$</p><ul><li>例如，$50 &gt;&gt; 2  =  12$ ，等价于 $50 / 4$，结果向下取整</li><li>一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是<strong>不等价</strong>的（只对0和正数成立）</li></ul></li></ul><p>同时，位运算也能用来替代取模运算判断奇偶：</p><ul><li>奇数：$整数&amp;1==1$（二进制最低位是1，就是奇数</li><li>偶数：$整数&amp;1==0$（二进制最低位是0，就是偶数</li></ul><h2 id="4、位运算性质"><a href="#4、位运算性质" class="headerlink" title="4、位运算性质"></a>4、位运算性质</h2><p>此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。</p><ul><li>幂等律：$a \And a = a$ ，$a ∣ a=a$ （注意异或不满足幂等律）</li><li>交换律：$a \And b = b \And a$，$a ∣ b = b ∣ a$，$a \oplus b = b \oplus a$</li><li>结合律：$(a \And b) \And c = a \And (b \And c)$，$(a ∣ b) ∣ c = a ∣ (b ∣ c)$，$(a \oplus b) \oplus c = a \oplus (b \oplus c)$</li><li>分配律：$(a \And b) ∣ c = (a ∣ c) \And (b ∣ c)$，$(a ∣ b) \And c = (a \And c) ∣ (b \And c)$，$(a ⊕ b) \And c = (a \And c) ⊕ (b \And c)$</li><li>德·摩根律：$\sim (a \And b) = ( \sim a) ∣ (\sim b)$ ，$\sim(a ∣ b) = (\sim a) \And (\sim b)$</li><li>取反运算性质：$-1 = \sim 0，-a = \sim (a-1)$</li><li>与运算性质：$a \And 0 = 0$，$a \And (-1) = a$，$a \And (\sim a) = 0$</li><li>或运算性质：$a ∣ 0 = a$，$a ∣ (\sim a) = -1$</li><li>异或运算性质：$a \oplus 0 = a$，$a \oplus a = 0$</li><li>其他性质：<ul><li>$a \And (a-1)$ 的结果：将 a 的二进制表示的最后一个 1 变成 0</li><li>$a \And (-a)$（与 $a \And (\sim (a-1))$ 等价）的结果：只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。&lt;/p&gt;
&lt;p&gt;位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;上述位运算中，只有取反是一元运算，其余的都是二元运算。&lt;/p&gt;</summary>
    
    
    
    <category term="Knowledge" scheme="http://blog.sukiu.top/categories/Knowledge/"/>
    
    
    <category term="Bit Operation" scheme="http://blog.sukiu.top/tags/Bit-Operation/"/>
    
  </entry>
  
  <entry>
    <title>哈希内部</title>
    <link href="http://blog.sukiu.top/Data-structure/Hash-Insider/"/>
    <id>http://blog.sukiu.top/Data-structure/Hash-Insider/</id>
    <published>2021-11-21T08:35:42.000Z</published>
    <updated>2021-12-02T02:08:51.437Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。</p><span id="more"></span><h2 id="1、散列"><a href="#1、散列" class="headerlink" title="1、散列"></a>1、散列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>散列：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200145426.png" style="zoom: 50%;" ><p><strong>碰撞：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200248821.png" style="zoom:50%;" ><p><strong>散列函数：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200340573.png" style="zoom:50%;" ><p><strong>除余法：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200516454.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201009675.png" alt="例子"><br><img src="https://img-blog.csdnimg.cn/20200715200642965.png" alt="例子"></p><center>m=16*2=32<br>p=31<br>散列函数 h(key)=key%p</center> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200920178.png" style="zoom:50%;" ><h3 id="线性勘察法（开地址法处理碰撞）"><a href="#线性勘察法（开地址法处理碰撞）" class="headerlink" title="线性勘察法（开地址法处理碰撞）"></a>线性勘察法（开地址法处理碰撞）</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201346320.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201441361.png" alt="例子"> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201549656.png" style="zoom:50%;" ></p><p>已知n个关键码具有相同的散列值d，若采用<strong>线性探查法</strong>解决碰撞，则在散列这n个关键码的过程中，共将要发生<font color="red">n(n-1)/2</font>    次碰撞</p><h3 id="拉链法解决碰撞"><a href="#拉链法解决碰撞" class="headerlink" title="拉链法解决碰撞"></a>拉链法解决碰撞</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201943887.png" style="zoom:50%;" ><p>例子：</p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202142441.png" style="zoom:50%;" ><p>平均查找长度ASL：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202641565.png" style="zoom:50%;" ><h2 id="2、常见的三种哈希结构"><a href="#2、常见的三种哈希结构" class="headerlink" title="2、常见的三种哈希结构"></a>2、常见的三种哈希结构</h2><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a></p></blockquote><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li>std::unordered_set底层实现为哈希表</li><li>std::set 和std::multiset 的底层实现是红黑树</li></ul><blockquote><p>红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p></blockquote><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li><p>std::unordered_map 底层实现为哈希表</p></li><li><p>std::map 和std::multimap 的底层实现是红黑树</p></li></ul><p>使用时：</p><ul><li>解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的</li><li>如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</li></ul><p>map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><blockquote><p>java里的HashMap ，TreeMap 都是一样的原理。</p></blockquote><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20210104235134572.png" alt="哈希表" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Hash" scheme="http://blog.sukiu.top/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search 二分查找</title>
    <link href="http://blog.sukiu.top/Algorithm/Binary-Search/"/>
    <id>http://blog.sukiu.top/Algorithm/Binary-Search/</id>
    <published>2021-11-21T08:23:43.000Z</published>
    <updated>2021-12-02T01:03:05.232Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找也称折半查找，它是一种效率较高的查找方法。</p><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>数组为有序数组，数组中无重复元素。</p><p>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。</p><ul><li>到底是 while(left &lt; right) 还是 while(left &lt;= right)？</li><li>到底是right = middle呢，还是要right = middle - 1呢？</li></ul><p>区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><h3 id="1、左闭右闭"><a href="#1、左闭右闭" class="headerlink" title="1、左闭右闭"></a>1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，也就是[left, right]</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;  <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        middle := left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &gt; target &#123;</span><br><span class="line">            right = middle - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target &#123;</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、左闭右开"><a href="#2、左闭右开" class="headerlink" title="2、左闭右开"></a>2、左闭右开</h3><p>定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();  <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;    <span class="comment">// left == right在[left, right)是无效的空间</span></span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle;  <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;  <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// nums[middle] == target</span></span><br><span class="line">            <span class="keyword">return</span> middle;      <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找也称折半查找，它是一种效率较高的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Search" scheme="http://blog.sukiu.top/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>Thanox 情景模式</title>
    <link href="http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-17T02:04:33.000Z</published>
    <updated>2021-12-02T01:36:07.243Z</updated>
    
    <content type="html"><![CDATA[<p>情景模式简单理解：</p><blockquote><p>什么时候，干什么。</p></blockquote><ul><li><p>什么时候就是触发条件（condition）</p></li><li><p>干什么就是动作（actions）</p></li></ul><p>本文分享自用的情景模式，不定期更新~</p><span id="more"></span><blockquote><p>官方文档：</p><p><a href="https://tornaco.github.io/Thanox/6-Profile/">https://tornaco.github.io/Thanox/6-Profile/</a></p></blockquote><h2 id="1、GPS-相关"><a href="#1、GPS-相关" class="headerlink" title="1、GPS 相关"></a>1、GPS 相关</h2><h3 id="GPS自动开关"><a href="#GPS自动开关" class="headerlink" title="GPS自动开关"></a>GPS自动开关</h3><figure class="highlight yaml"><figcaption><span>GPS自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$gps.contains(to) &amp;&amp; !hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>GPS自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$gps.contains(pkgName) &amp;&amp; hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信小程序开关GPS"><a href="#微信小程序开关GPS" class="headerlink" title="微信小程序开关GPS"></a>微信小程序开关GPS</h3><figure class="highlight yaml"><figcaption><span>小程序自动打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>小程序自动关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; hw.isLocationEnabled() &amp;&amp; from == &quot;com.tencent.mm&quot;&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信网页开关GPS"><a href="#微信网页开关GPS" class="headerlink" title="微信网页开关GPS"></a>微信网页开关GPS</h3><figure class="highlight yaml"><figcaption><span>微信网页打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>微信网页关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; hw.isLocationEnabled() &amp;&amp; !componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2、NFC-相关"><a href="#2、NFC-相关" class="headerlink" title="2、NFC 相关"></a>2、NFC 相关</h2><h3 id="NFC自动开关"><a href="#NFC自动开关" class="headerlink" title="NFC自动开关"></a>NFC自动开关</h3><figure class="highlight yaml"><figcaption><span>NFC自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$nfc.contains(to) &amp;&amp; !hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>NFC自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$nfc.contains(pkgName) &amp;&amp; hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3、冻结相关"><a href="#3、冻结相关" class="headerlink" title="3、冻结相关"></a>3、冻结相关</h2><h3 id="蓝牙开关冻结"><a href="#蓝牙开关冻结" class="headerlink" title="蓝牙开关冻结"></a>蓝牙开关冻结</h3><figure class="highlight yaml"><figcaption><span>BT冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙关闭冻结指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOff&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (pkg.isApplicationEnabled(s)) pkg.disableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT冻结&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>BT解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙打开解冻指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOn&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (!pkg.isApplicationEnabled(s)) pkg.enableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT解冻&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="游戏开关冻结"><a href="#游戏开关冻结" class="headerlink" title="游戏开关冻结"></a>游戏开关冻结</h3><blockquote><p>自行修改以下 com.oneplus.gamespace 包名</p></blockquote><figure class="highlight yaml"><figcaption><span>Game冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;关闭游戏冻结游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;taskRemoved &amp;&amp; globalVarOf$game.contains(pkgName) &amp;&amp; pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.disableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉冻结游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>Game解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开游戏解冻游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; globalVarOf$game.contains(to) &amp;&amp; !pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.enableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉解冻游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4、应用相关"><a href="#4、应用相关" class="headerlink" title="4、应用相关"></a>4、应用相关</h2><h3 id="APP保活"><a href="#APP保活" class="headerlink" title="APP保活"></a>APP保活</h3><blockquote><p>推荐用乖巧模式的规则来 KEEP 想保持的服务</p><p>以下貌似没用，可以开启电池不优化试试</p></blockquote><figure class="highlight yaml"><figcaption><span>APP保活 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP保活&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;应用停止运行时重启应用进程，全局变量 apps&quot;</span></span><br><span class="line"><span class="comment">#  APP 后台不优化</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$apps.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.launchProcessForPackage(pkgName)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉保活app&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="APP休眠"><a href="#APP休眠" class="headerlink" title="APP休眠"></a>APP休眠</h3><figure class="highlight yaml"><figcaption><span>APP休眠 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP休眠&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;后台应用休眠，全局变量 idle&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$idle.contains(from)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.setInactive(from)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、Data-相关"><a href="#5、Data-相关" class="headerlink" title="5、Data 相关"></a>5、Data 相关</h2><h3 id="Data自动开启"><a href="#Data自动开启" class="headerlink" title="Data自动开启"></a>Data自动开启</h3><figure class="highlight yaml"><figcaption><span>Data自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Data自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开移动数据，全局变量 data&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$data.contains(to) &amp;&amp; !hw.isWifiEnabled() &amp;&amp; !data.isDataEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;data.setDataEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开移动数据&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6、亮度相关"><a href="#6、亮度相关" class="headerlink" title="6、亮度相关"></a>6、亮度相关</h2><h3 id="自动亮度关闭"><a href="#自动亮度关闭" class="headerlink" title="自动亮度关闭"></a>自动亮度关闭</h3><figure class="highlight yaml"><figcaption><span>自动亮度关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用关闭自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bright.contains(to) &amp;&amp; power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(false)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭自动亮度&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="自动亮度开启"><a href="#自动亮度开启" class="headerlink" title="自动亮度开启"></a>自动亮度开启</h3><figure class="highlight yaml"><figcaption><span>自动亮度开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用打开自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bright.contains(pkgName) &amp;&amp; !power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setBrightness(power.getBrightness())&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉开启自动亮度&quot;)&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、状态栏图标相关"><a href="#7、状态栏图标相关" class="headerlink" title="7、状态栏图标相关"></a>7、状态栏图标相关</h2><blockquote><p>隐藏状态栏图标的 shell 命令：</p><p>settings put secure icon_blacklist 「args」</p><p>自行修改 「args」 参数</p></blockquote><h3 id="状态栏图标隐藏"><a href="#状态栏图标隐藏" class="headerlink" title="状态栏图标隐藏"></a>状态栏图标隐藏</h3><figure class="highlight yaml"><figcaption><span>状态栏图标隐藏 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标隐藏&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用隐藏状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bar.contains(to)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,clock,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉隐藏状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="状态栏图标显示"><a href="#状态栏图标显示" class="headerlink" title="状态栏图标显示"></a>状态栏图标显示</h3><figure class="highlight yaml"><figcaption><span>状态栏图标显示 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标显示&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用显示状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bar.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉显示状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;情景模式简单理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候，干什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么时候就是触发条件（condition）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;干什么就是动作（actions）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文分享自用的情景模式，不定期更新~&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="Thanox" scheme="http://blog.sukiu.top/tags/Thanox/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://blog.sukiu.top/Language/Go-Module/"/>
    <id>http://blog.sukiu.top/Language/Go-Module/</id>
    <published>2021-11-17T00:54:42.000Z</published>
    <updated>2021-12-02T01:04:13.524Z</updated>
    
    <content type="html"><![CDATA[<p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。</p><p>一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://time.geekbang.org/column/article/429941">06｜构建模式：Go是怎么解决包依赖管理问题的？ (geekbang.org)</a></p></blockquote><h2 id="1、Go-Module-构建模式"><a href="#1、Go-Module-构建模式" class="headerlink" title="1、Go Module 构建模式"></a>1、Go Module 构建模式</h2><h3 id="语义导入版本机制"><a href="#语义导入版本机制" class="headerlink" title="语义导入版本机制"></a>语义导入版本机制</h3><p>在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/468323b3294cce2ea7f4c1da3699c5a2.png" alt="语义版本号规范" style="zoom: 50%;" /><p>按照语义版本规范，</p><ul><li><strong>主版本号不同</strong>的两个版本是相互<strong>不兼容</strong>的；</li><li>在主版本号相同的情况下，次版本号大都是<strong>向后兼容</strong>次版本号小的版本；</li><li>补丁版本号也不影响兼容性。</li></ul><p>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本</span></span><br><span class="line"><span class="comment">// 假如这是 v1.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus&quot;</span> </span><br><span class="line"><span class="comment">// 如果要导入 v2.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line"><span class="comment">// 甚至可以同时依赖一个包的两个不兼容版本</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">    logv2 <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径</p></blockquote><h3 id="最小版本选择原则"><a href="#最小版本选择原则" class="headerlink" title="最小版本选择原则"></a>最小版本选择原则</h3><p>依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/49eb7aa0458d8ec6131d9e5661155f1b.jpeg" alt="复杂情况" style="zoom: 33%;" /><p>当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 <code>v1.7.0</code>。</p><p>不过，Go 会在该项目依赖项的所有版本中，选出<strong>符合项目整体要求</strong>的“最小版本”</p><p>这个例子中，<code>C v1.3.0</code> 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 <code>C v1.3.0</code>，而不是最新最大的 <code>C v1.7.0</code>。</p><h2 id="2、Go-module-版本管理"><a href="#2、Go-module-版本管理" class="headerlink" title="2、Go module 版本管理"></a>2、Go module 版本管理</h2><h3 id="（1）Go-Module-创建"><a href="#（1）Go-Module-创建" class="headerlink" title="（1）Go Module 创建"></a>（1）Go Module 创建</h3><p>创建一个 Go Module，通常有如下几个步骤：</p><ol><li><p>通过 <code>go mod init</code> 创建 go.mod 文件，将当前项目变为一个 Go Module；</p></li><li><p>通过 <code>go mod tidy</code> 命令自动更新当前 module 的依赖信息；</p></li><li><p>执行 <code>go build</code>，执行新 module 的构建。</p></li></ol><h3 id="（2）为当前-module-添加一个依赖"><a href="#（2）为当前-module-添加一个依赖" class="headerlink" title="（2）为当前 module 添加一个依赖"></a>（2）为当前 module 添加一个依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/google/uuid</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go mod tidy</span></span><br></pre></td></tr></table></figure><h3 id="（3）升级-降级依赖的版本"><a href="#（3）升级-降级依赖的版本" class="headerlink" title="（3）升级 / 降级依赖的版本"></a>（3）升级 / 降级依赖的版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选定指定版本即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">go get github.com/sirupsen/logrus@v1.7.0</span></span><br></pre></td></tr></table></figure><h3 id="（4）移除一个依赖"><a href="#（4）移除一个依赖" class="headerlink" title="（4）移除一个依赖"></a>（4）移除一个依赖</h3><p>仅从源码中删除对依赖项的导入语句还不够，还得用 <code>go mod tidy</code> 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。</p><p><code>go mod tidy</code> 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。</p><h3 id="（5）vendor"><a href="#（5）vendor" class="headerlink" title="（5）vendor"></a>（5）vendor</h3><p>vendor 机制可以对 vendor 目录下缓存的依赖包进行自动管理。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非 go build 传入 <code>-mod=mod</code> 的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">go mod vendor</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tree -LF 2 vendor</span></span><br><span class="line">vendor</span><br><span class="line">├── github.com/</span><br><span class="line">│   ├── google/</span><br><span class="line">│   ├── magefile/</span><br><span class="line">│   └── sirupsen/</span><br><span class="line">├── golang.org/</span><br><span class="line">│   └── x/</span><br><span class="line">└── modules.txt</span><br></pre></td></tr></table></figure><h3 id="3、空导入"><a href="#3、空导入" class="headerlink" title="3、空导入"></a>3、空导入</h3><p>像下面代码这样的包导入方式被称为“空导入”：<code>import _ &quot;foo&quot;</code></p><p>空导入也是导入，意味着我们将依赖foo这个路径下的包。</p><p>由于是空导入，我们并没有显式使用这个包中的任何语法元素。</p><p>通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。&lt;/p&gt;
&lt;p&gt;在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。&lt;/p&gt;
&lt;p&gt;一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。&lt;/p&gt;
&lt;p&gt;go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>主流开源协议</title>
    <link href="http://blog.sukiu.top/Mixed/Open-Source-License/"/>
    <id>http://blog.sukiu.top/Mixed/Open-Source-License/</id>
    <published>2021-11-12T10:49:27.000Z</published>
    <updated>2021-12-02T01:05:05.675Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：</p><ul><li>宽松自由软件许可协议 <em>Permissive free software licence</em></li><li>著佐权许可证 <em>copyleft license</em></li></ul><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/19568896">主流开源协议之间有何异同？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p></blockquote><h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><ul><li><p>Permissive free software licence ：</p><p>  一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。</p></li><li><p>Copyleft License ：</p><p>  在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。</p></li></ul><p>两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。</p><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><h2 id="2、常见开源许可证"><a href="#2、常见开源许可证" class="headerlink" title="2、常见开源许可证"></a>2、常见开源许可证</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free_software_licenses.png" alt="常见许可证" style="zoom:50%;" /><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p><em>Berkeley Software Distribution license</em></p><p>BSD 许可证与 MIT 差不多。</p><p>事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。</p><p>可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。</p><p>Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。</p><p>Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。</p><p>由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/7149baf878e23293b9bd57df076b6e41_r.jpg" alt="简明对比"></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>更宽松的GPL协议。</p><p>与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。</p><p>调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宽松自由软件许可协议 &lt;em&gt;Permissive free software licence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;著佐权许可证 &lt;em&gt;copyleft license&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="License" scheme="http://blog.sukiu.top/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree 二叉搜索树</title>
    <link href="http://blog.sukiu.top/Data-structure/Binary-Search-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/Binary-Search-Tree/</id>
    <published>2021-11-12T02:42:46.000Z</published>
    <updated>2021-12-02T01:03:10.264Z</updated>
    
    <content type="html"><![CDATA[<p>简称 BST，也称二叉排序树或二叉查找树。</p><p>特点：</p><ul><li>任一结点 &gt; 其左子树的所有结点，<br>  并且&lt; 其右子树的所有结点；</li><li>结点的左、右子树，也是二叉排序树；</li><li>每个结点键值唯一（不能重复）</li></ul><p>重要性质：</p><ul><li><strong>中序遍历二叉排序树得到递增序列</strong></li></ul><p>所以判断 1 棵二叉树是否是二叉排序树？<br>只要中序遍历，得到递增序列才是。</p><span id="more"></span><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li>若当前树为空，则新结点为根</li><li>若当前树不空，<br>  将待插入 x 与根比较；<ul><li>若 x 等于根，不用插入</li><li>若 x 大于根，则去右子树(找位置)；</li><li>若 x 小于根，则去左子树(找位置)；</li></ul></li></ul><p>可以总结为：</p><p>插入之前，先查找：</p><ul><li>若找到，不用插入</li><li>若找不到，则在到达的空位置处，放入 x；</li></ul><p>所以最新插入的结点，一定是叶子；</p><img src="https://img-blog.csdnimg.cn/20200512170217478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" width="50%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>从根结点开始，如果树为空，则返回 NULL</p></li><li><p>如果非空，从根结点开始，比较待检索的键值</p><ul><li><p>若相等，则成功；</p></li><li><p>若小于根，<br>  则去根的左子树；</p></li><li><p>若大于根，<br>  则去根的右子树，</p></li></ul></li></ul><figure class="highlight go"><figcaption><span>迭代</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>考虑三种情况：</p><ul><li>① 要删除叶子结点<br>  直接删除，并将父结点指针置为 NULL</li></ul><img src="https://img-blog.csdnimg.cn/20200512170832794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="40%"><ul><li>② 删除只有 1 个孩子的结点<br>  将父结点指针指向要删除结点的孩子结点</li></ul><img src="https://img-blog.csdnimg.cn/20200512170956215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><ul><li>③ 删除有左右子树的结点<br>  用另一个结点替代删除的结点：<ul><li>右子树的最小元素 或者 左子树的最大元素</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200512171205732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">        root.Left = deleteNode(root.Left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">        root.Right = deleteNode(root.Right, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 1 : 以下两个 if 已经处理</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 左</span></span><br><span class="line">        <span class="keyword">return</span> root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 右</span></span><br><span class="line">        <span class="keyword">return</span> root.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 3 ： 使用右子树最小元素</span></span><br><span class="line">    minNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> minNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        minNode = minNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    root.Val = minNode.Val</span><br><span class="line">    root.Right = deleteNode(root.Right, minNode.Val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平均检索长度-ASL"><a href="#平均检索长度-ASL" class="headerlink" title="平均检索长度 ASL"></a>平均检索长度 ASL</h2><p>比较次数：不大于树的深度</p><p>最坏平均查找长度 ASL：(n+1)/2</p><p>最好 ASL：$log2(n)$ (参考二分查找)</p><p><strong>所有操作的复杂度都是 $O(logn)$</strong></p><img src="https://img-blog.csdnimg.cn/2020051217150614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" >]]></content>
    
    
    <summary type="html">&lt;p&gt;简称 BST，也称二叉排序树或二叉查找树。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任一结点 &amp;gt; 其左子树的所有结点，&lt;br&gt;  并且&amp;lt; 其右子树的所有结点；&lt;/li&gt;
&lt;li&gt;结点的左、右子树，也是二叉排序树；&lt;/li&gt;
&lt;li&gt;每个结点键值唯一（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中序遍历二叉排序树得到递增序列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以判断 1 棵二叉树是否是二叉排序树？&lt;br&gt;只要中序遍历，得到递增序列才是。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——系统管理</title>
    <link href="http://blog.sukiu.top/Linux/Linux-System-Management/"/>
    <id>http://blog.sukiu.top/Linux/Linux-System-Management/</id>
    <published>2021-11-07T14:50:41.000Z</published>
    <updated>2021-12-02T01:04:59.216Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中常用的系统工作命令以及系统状态检测命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、常用系统工作命令"><a href="#1、常用系统工作命令" class="headerlink" title="1、常用系统工作命令"></a>1、常用系统工作命令</h2><h3 id="echo-：在终端输出字符串或变量提取后的值"><a href="#echo-：在终端输出字符串或变量提取后的值" class="headerlink" title="echo ：在终端输出字符串或变量提取后的值"></a>echo ：在终端输出字符串或变量提取后的值</h3><p>命令描述：echo命令用于在终端输出字符串或变量提取后的值。</p><p>命令格式：<code>echo [字符串 | $变量]</code></p><p>命令用法示例：</p><p><strong>显示普通字符串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p><strong>显示变量</strong><br>首先在shell环境中定义一个临时变量name，<br>使用echo命令将变量name的值显示到终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> name=<span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure><p><strong>显示结果定向至文件</strong><br>以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test text.&quot;</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。</p><p><strong>显示命令执行结果</strong><br>以下命令将会在终端显示当前的工作路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure><p>注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。<br>使用<code>$(command)</code>形式可以达到相同效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h3 id="date-：显示和设置系统的时间和日期"><a href="#date-：显示和设置系统的时间和日期" class="headerlink" title="date ：显示和设置系统的时间和日期"></a>date ：显示和设置系统的时间和日期</h3><p>命令描述：date命令用于显示和设置系统的时间和日期。</p><p>命令格式：<code>date [选项] [+格式]</code></p><p>其中，时间格式的部分控制字符解释如下：</p><table class=""><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.25da70089Mos0m">字符</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.25da70089Mos0m">%a</td><td>当地时间的星期名缩写（例如： 日，代表星期日）</td></tr><tr><td>%A</td><td>当地时间的星期名全称 （例如：星期日）</td></tr><tr><td>%b</td><td>当地时间的月名缩写 （例如：一，代表一月）</td></tr><tr><td>%B</td><td>当地时间的月名全称 （例如：一月）</td></tr><tr><td>%c</td><td>当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）</td></tr><tr><td>%C</td><td>世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）</td></tr><tr><td>%d</td><td>按月计的日期（例如：01）</td></tr><tr><td>%D</td><td>按月计的日期；等于%m/%d/%y</td></tr><tr><td>%F</td><td>完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td>%j</td><td>按年计的日期（001-366）</td></tr><tr><td>%p</td><td>按年计的日期（001-366）</td></tr><tr><td>%r</td><td>当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）</td></tr><tr><td>%R</td><td>24 小时时间的时和分，等价于 %H:%M</td></tr><tr><td>%s</td><td>自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</td></tr><tr><td>%T</td><td>时间，等于%H:%M:%S</td></tr><tr><td>%U</td><td>一年中的第几周，以周日为每星期第一天（00-53）</td></tr><tr><td>%x</td><td>当地时间下的日期描述 （例如：12/31/99）</td></tr><tr><td>%X</td><td>当地时间下的时间描述 （例如：23:13:48）</td></tr><tr><td>%w</td><td>一星期中的第几日（0-6），0 代表周一</td></tr><tr><td>%W</td><td>一年中的第几周，以周一为每星期第一天（00-53）</td></tr></tbody></table><p>命令用法示例：</p><p><strong>按照默认格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p><strong>按照指定格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>查看今天是当年中的第几天</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%j&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>将系统的当前时间设置为2020年02月20日20点20分20秒</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="string">&quot;20200220 20:20:20&quot;</span></span><br></pre></td></tr></table></figure><p>​<br><strong>校正系统时间，与网络时间同步</strong><br>​    a. 安装ntp校时工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure><p>b. 用ntpdate从时间服务器更新时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><h3 id="wget-：在终端中下载文件"><a href="#wget-：在终端中下载文件" class="headerlink" title="wget ：在终端中下载文件"></a>wget ：在终端中下载文件</h3><p>命令描述：在终端中下载文件。</p><p>命令格式：<code>wget [参数] 下载地址</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i24.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大重试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><p>命令使用示例：</p><p><strong>下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png</span><br></pre></td></tr></table></figure><h3 id="ps-：查看系统中的进程状态"><a href="#ps-：查看系统中的进程状态" class="headerlink" title="ps ：查看系统中的进程状态"></a>ps ：查看系统中的进程状态</h3><p>命令描述：ps命令用于查看系统中的进程状态。</p><p>命令格式：<code>ps [参数]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i27.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i26.25da70089Mos0m">-u</td><td>以用户为主的格式来显示程序状况</td></tr><tr><td>-x</td><td>显示没有控制终端的进程，同时显示各个命令的具体路径</td></tr><tr><td>-e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示当前所有的进程</td></tr><tr><td>-t</td><td>指定终端机编号，并列出属于该终端机的程序的状况</td></tr></tbody></table><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure><h3 id="top-：动态地监视进程活动与系统负载等信息"><a href="#top-：动态地监视进程活动与系统负载等信息" class="headerlink" title="top ：动态地监视进程活动与系统负载等信息"></a>top ：动态地监视进程活动与系统负载等信息</h3><p>命令描述：top命令动态地监视进程活动与系统负载等信息。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/top.png" alt="top"><br>命令输出参数解释：</p><p>以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。</p><ul><li><p>统计信息区</p><ul><li>第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li><li>第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li><li>第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li><li>第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</li><li>第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。</li></ul></li><li><p>进程信息区</p>  <table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i35.25da70089Mos0m">列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程ID</td></tr><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>PR</td><td>进程优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb</td></tr><tr><td>SHR</td><td data-spm-anchor-id="a2c6h.13858378.0.i34.25da70089Mos0m">共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态<ul><li>D：不可中断的睡眠状态</li><li>R：正在运行</li><li>S：睡眠</li><li>T：停止</li><li>Z：僵尸进程</li></ul></td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>命令名</td></tr></tbody></table>   按 q 键退出监控页面。</li></ul><h3 id="pidof-：查询指定服务进程的PID值"><a href="#pidof-：查询指定服务进程的PID值" class="headerlink" title="pidof ：查询指定服务进程的PID值"></a>pidof ：查询指定服务进程的PID值</h3><p>命令描述：pidof命令用于查询指定服务进程的PID值。</p><p>命令格式：<code>pidof [服务名称]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>仅返回一个进程号</td></tr><tr><td>-c</td><td>只显示运行在root目录下的进程，这个选项只对root用户有效</td></tr><tr><td>-o</td><td>忽略指定进程号的进程</td></tr><tr><td>-x</td><td>显示由脚本开启的进程</td></tr></tbody></table><p>命令使用示例：</p><p><strong>查询出crond服务下的所有进程ID。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof crond</span><br></pre></td></tr></table></figure><h3 id="kill-：终止指定PID的服务进程"><a href="#kill-：终止指定PID的服务进程" class="headerlink" title="kill ：终止指定PID的服务进程"></a>kill ：终止指定PID的服务进程</h3><p>命令描述：kill命令用于终止指定PID的服务进程。</p><p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。</p><p>命令格式：<code>kill [参数] [进程PID]</code></p><p>命令使用示例：</p><p><strong>删除pid为1247的进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 1247</span><br></pre></td></tr></table></figure><h3 id="killall-：终止指定名称的服务对应的全部进程"><a href="#killall-：终止指定名称的服务对应的全部进程" class="headerlink" title="killall ：终止指定名称的服务对应的全部进程"></a>killall ：终止指定名称的服务对应的全部进程</h3><p>命令描述：killall命令用于终止指定名称的服务对应的全部进程。</p><p>命令格式：<code>killall [进程名称]</code></p><p>命令使用示例：</p><p><strong>删除crond服务下的所有进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall crond</span><br></pre></td></tr></table></figure><h3 id="reboot-：重启系统"><a href="#reboot-：重启系统" class="headerlink" title="reboot ：重启系统"></a>reboot ：重启系统</h3><p>命令描述：reboot命令用来重启系统。</p><p>命令格式：<code>reboot [-n] [-w] [-d] [-f] [-i]</code></p><p>命令参数说明：</p><ul><li>-n：保存数据后再重新启动系统。</li><li>-w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。</li><li>-d：重新启动时不把数据写入记录文件/var/tmp/wtmp。</li><li>-f：强制重新开机，不调用shutdown指令的功能。</li><li>-i：关闭网络设置之后再重新启动系统。</li></ul><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="poweroff-：关闭系统"><a href="#poweroff-：关闭系统" class="headerlink" title="poweroff ：关闭系统"></a>poweroff ：关闭系统</h3><p>命令描述：poweroff命令用来关闭系统。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><h2 id="2、系统状态检测命令"><a href="#2、系统状态检测命令" class="headerlink" title="2、系统状态检测命令"></a>2、系统状态检测命令</h2><h3 id="ifconfig-：获取网卡配置与网络状态等信息"><a href="#ifconfig-：获取网卡配置与网络状态等信息" class="headerlink" title="ifconfig ：获取网卡配置与网络状态等信息"></a>ifconfig ：获取网卡配置与网络状态等信息</h3><p>命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。</p><p>命令示例：</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/ifconfig.png" alt="ifconfig"><br>命令输出说明：</p><ul><li>第一部分的第一行显示网卡状态信息。<ul><li>eth0表示第一块网卡。</li><li>UP代表网卡开启状态。</li><li>RUNNING代表网卡的网线被接上。</li><li>MULTICAST表示支持组播。</li></ul></li><li>第二行显示网卡的网络信息。<ul><li>inet（IP地址）：172.16.132.195。</li><li>broadcast（广播地址）：172.16.143.255。</li><li>netmask（掩码地址）：255.255.240.0。</li><li>RX表示接收数据包的情况，TX表示发送数据包的情况。</li><li>lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。</li></ul></li></ul><h3 id="uname-：查看系统内核与系统版本等信息"><a href="#uname-：查看系统内核与系统版本等信息" class="headerlink" title="uname ：查看系统内核与系统版本等信息"></a>uname ：查看系统内核与系统版本等信息</h3><p>命令描述：uname命令用于查看系统内核与系统版本等信息。</p><p>命令语法：<code>uname [-amnrsv][--help][--version]</code></p><p>命令使用示例：</p><p><strong>显示系统信息。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>显示当前系统的硬件架构。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -i</span><br></pre></td></tr></table></figure><p><strong>显示操作系统发行编号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><strong>显示操作系统名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -s</span><br></pre></td></tr></table></figure><p><strong>显示主机名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -n</span><br></pre></td></tr></table></figure><h3 id="uptime-：查看系统的负载信息"><a href="#uptime-：查看系统的负载信息" class="headerlink" title="uptime ：查看系统的负载信息"></a>uptime ：查看系统的负载信息</h3><p>命令描述：uptime 用于查看系统的负载信息。</p><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/uptime.png" alt="uptime"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i55.25da70089Mos0m">负载信息</th><th data-spm-anchor-id="a2c6h.13858378.0.i54.25da70089Mos0m">命令输出值</th></tr></thead><tbody><tr><td>当前服务器时间</td><td>14:20:27</td></tr><tr><td>当前服务器运行时长</td><td>2 min</td></tr><tr><td>当前用户数</td><td>2 users</td></tr><tr><td>当前负载情况</td><td><code>load average: 0.03, 0.04, 0.02</code>（分别取1min，5min，15min的均值）</td></tr></tbody></table><h3 id="free-：显示当前系统中内存的使用量信息"><a href="#free-：显示当前系统中内存的使用量信息" class="headerlink" title="free ：显示当前系统中内存的使用量信息"></a>free ：显示当前系统中内存的使用量信息</h3><p>命令描述：free用于显示当前系统中内存的使用量信息。</p><p>命令语法：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i59.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以Byte为单位显示内存使用情况</td></tr><tr><td>-k</td><td>以KB为单位显示内存使用情况</td></tr><tr><td>-m</td><td>以MB为单位显示内存使用情况</td></tr><tr><td>-h</td><td>以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</td></tr></tbody></table><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free.png" alt="free"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i64.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i63.25da70089Mos0m">total</td><td>物理内存总数</td></tr><tr><td>used</td><td>已经使用的内存数</td></tr><tr><td>free</td><td>空间的内存数</td></tr><tr><td>share</td><td>多个进程共享的内存总额</td></tr><tr><td>buff/cache</td><td>应用使用内存数</td></tr><tr><td>available</td><td>可用的内存数</td></tr><tr><td>Swap</td><td>虚拟内存（阿里云ECS服务器默认不开启虚拟内存）</td></tr></tbody></table><h3 id="who-：显示关于当前在本地系统上的所有用户的信息"><a href="#who-：显示关于当前在本地系统上的所有用户的信息" class="headerlink" title="who ：显示关于当前在本地系统上的所有用户的信息"></a>who ：显示关于当前在本地系统上的所有用户的信息</h3><p>命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。</p><p>命令使用示例：</p><p><strong>显示当前登录系统的用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure><p><strong>显示用户登录来源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -l -H</span><br></pre></td></tr></table></figure><p><strong>只显示当前用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -m -H</span><br></pre></td></tr></table></figure><p><strong>精简模式显示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -q</span><br></pre></td></tr></table></figure><h3 id="last-：显示用户最近登录信息"><a href="#last-：显示用户最近登录信息" class="headerlink" title="last ：显示用户最近登录信息"></a>last ：显示用户最近登录信息</h3><p>命令描述： last 命令用于显示用户最近登录信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><h3 id="history-：显示历史执行过的命令"><a href="#history-：显示历史执行过的命令" class="headerlink" title="history ：显示历史执行过的命令"></a>history ：显示历史执行过的命令</h3><p>命令描述：history命令用于显示历史执行过的命令。</p><p>bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。</p><p>命令使用示例：</p><p><strong>显示最新10条执行过的命令。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> 10</span><br></pre></td></tr></table></figure><p><strong>清除历史记录。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux中常用的系统工作命令以及系统状态检测命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文本处理</title>
    <link href="http://blog.sukiu.top/Linux/Linux-Text-Processing/"/>
    <id>http://blog.sukiu.top/Linux/Linux-Text-Processing/</id>
    <published>2021-11-07T14:38:28.000Z</published>
    <updated>2021-12-02T02:14:23.381Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文本编辑工具Vim"><a href="#1、文本编辑工具Vim" class="headerlink" title="1、文本编辑工具Vim"></a>1、文本编辑工具Vim</h2><p>vim的三种操作模式：</p><ul><li>命令模式（Command mode）</li><li>输入模式（Insert mode）</li><li>底线命令模式（Last line mode）。</li></ul><p>三种模式切换快捷键：</p><table><thead><tr><th>模式</th><th>快捷键</th></tr></thead><tbody><tr><td>命令模式</td><td>ESC</td></tr><tr><td>输入模式</td><td>i或a</td></tr><tr><td>底线命令模式</td><td><strong>:</strong></td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。</p><p>使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p><p>以下是在命令模式中常用的快捷操作：</p><table class="" style="width: 100%;" data-spm-anchor-id="a2c6h.13858378.0.i12.31941d111Dv71Z"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i11.31941d111Dv71Z">操作</th><th>快捷键</th></tr></thead><tbody><tr><td>光标左移</td><td>h</td></tr><tr><td>光标右移</td><td>l（小写L）</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i13.31941d111Dv71Z">光标上移</td><td>k</td></tr><tr><td>光标下移</td><td>j</td></tr><tr><td>光标移动到下一个单词</td><td>w</td></tr><tr><td>光标移动到上一个单词</td><td>b</td></tr><tr><td>移动游标到第n行</td><td>nG</td></tr><tr><td>移动游标到第一行</td><td>gg</td></tr><tr><td>移动游标到最后一行</td><td>G</td></tr><tr><td>快速回到上一次光标所在位置</td><td>Ctrl+o</td></tr><tr><td>删除当前字符</td><td>x</td></tr><tr><td>删除前一个字符</td><td>X</td></tr><tr><td>删除整行</td><td>dd</td></tr><tr><td>删除一个单词</td><td>dw或daw</td></tr><tr><td>删除至行尾</td><td>d$或D</td></tr><tr><td>删除至行首</td><td>d^</td></tr><tr><td>删除到文档末尾</td><td>dG</td></tr><tr><td>删除至文档首部</td><td>d1G</td></tr><tr><td>删除n行</td><td>ndd</td></tr><tr><td>删除n个连续字符</td><td>nx</td></tr><tr><td>将光标所在位置字母变成大写或小写</td><td>~</td></tr><tr><td>复制游标所在的整行</td><td>yy（3yy表示复制3行）</td></tr><tr><td>粘贴至光标后（下）</td><td>p</td></tr><tr><td>粘贴至光标前（上）</td><td>P</td></tr><tr><td>剪切</td><td>dd</td></tr><tr><td>交换上下行</td><td>ddp</td></tr><tr><td>替换整行，即删除游标所在行并进入插入模式</td><td>cc</td></tr><tr><td>撤销一次或n次操作</td><td>u{n}</td></tr><tr><td>撤销当前行的所有修改</td><td>U</td></tr><tr><td>恢复撤销操作</td><td>Ctrl+r</td></tr><tr><td>整行将向右缩进</td><td>&gt;&gt;</td></tr><tr><td>整行将向左退回</td><td>&lt;&lt;</td></tr><tr><td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td><td>ZZ</td></tr></tbody></table><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p><p>以下是底线命令模式中常用的快捷操作：</p><table class="" style="width: 100%;"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.31941d111Dv71Z">操作</th><th>命令</th></tr></thead><tbody><tr><td>保存</td><td>:w</td></tr><tr><td>退出</td><td>:q</td></tr><tr><td>保存并退出</td><td>:wq（<code>:wq!</code>表示强制保存退出）</td></tr><tr><td>将文件另存为其他文件名</td><td>:w new_filename</td></tr><tr><td>显示行号</td><td>:set nu</td></tr><tr><td>取消行号</td><td>:set nonu</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.31941d111Dv71Z">使本行内容居中</td><td>:ce</td></tr><tr><td>使本行文本靠右</td><td>:ri</td></tr><tr><td>使本行内容靠左</td><td>:le</td></tr><tr><td>向光标之下寻找一个名称为word的字符串</td><td>:/word</td></tr><tr><td>向光标之上寻找一个字符串名称为word的字符串</td><td>:?word</td></tr><tr><td>重复前一个搜寻的动作</td><td>:n</td></tr><tr><td>从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td><td><code>:1,$s/word1/word2/g</code> 或 <code><span>&nbsp;</span>:%s/word1/word2/g</code></td></tr></tbody></table><h2 id="2、文本文件查看命令"><a href="#2、文本文件查看命令" class="headerlink" title="2、文本文件查看命令"></a>2、文本文件查看命令</h2><h3 id="cat-：查看内容较少的纯文本文件"><a href="#cat-：查看内容较少的纯文本文件" class="headerlink" title="cat ：查看内容较少的纯文本文件"></a>cat ：查看内容较少的纯文本文件</h3><p>命令描述：cat命令用于查看内容较少的纯文本文件。</p><p>命令格式：<code>cat [选项] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i26.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n或--number</td><td>显示行号</td></tr><tr><td>-b或--number-nonblank</td><td>显示行号，但是不对空白行进行编号</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i25.31941d111Dv71Z">-s或--squeeze-blank</td><td>当遇到有连续两行以上的空白行，只显示一行的空白行</td></tr></tbody></table><h3 id="more-：从前向后分页显示文件内容"><a href="#more-：从前向后分页显示文件内容" class="headerlink" title="more ：从前向后分页显示文件内容"></a>more ：从前向后分页显示文件内容</h3><p>命令描述：more命令从前向后分页显示文件内容。</p><p>常用操作命令：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i31.31941d111Dv71Z">操作</th><th>作用</th></tr></thead><tbody><tr><td>Enter</td><td>向下n行，n需要定义，默认为1行</td></tr><tr><td>Ctrl+F或空格键（Space）</td><td>向下滚动一页</td></tr><tr><td>Ctrl+B</td><td>向上滚动一页</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>!命令</td><td>调用Shell执行命令</td></tr><tr><td>q</td><td>退出more</td></tr></tbody></table><h3 id="less-：对文件或其它输出进行分页显示"><a href="#less-：对文件或其它输出进行分页显示" class="headerlink" title="less ：对文件或其它输出进行分页显示"></a>less ：对文件或其它输出进行分页显示</h3><p>命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。</p><p>命令格式：<code>less [参数] 文件</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i33.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e</td><td>当文件显示结束后，自动离开</td></tr><tr><td>-m</td><td data-spm-anchor-id="a2c6h.13858378.0.i32.31941d111Dv71Z">显示类似more命令的百分比</td></tr><tr><td>-N</td><td>显示每行的行号</td></tr><tr><td>-s</td><td>显示连续空行为一行</td></tr></tbody></table><p>命令常用操作：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i34.31941d111Dv71Z">/字符串</td><td>向下搜索字符串</td></tr><tr><td>?字符串</td><td>向上搜索字符串</td></tr><tr><td>n</td><td>重复前一个搜索</td></tr><tr><td>N</td><td>反向重复前一个搜索</td></tr><tr><td>b或<code>pageup</code>键</td><td>向上翻一页</td></tr><tr><td>空格键或<code>pagedown</code>键</td><td>向下翻一页</td></tr><tr><td>u</td><td>向前翻半页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>y</td><td>向前滚动一行</td></tr><tr><td>回车键</td><td>向后滚动一行</td></tr><tr><td>q</td><td>退出less命令</td></tr></tbody></table><p>命令使用示例：</p><p>查看命令历史使用记录并通过less分页显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure><h3 id="head-：查看文件开头指定行数的内容"><a href="#head-：查看文件开头指定行数的内容" class="headerlink" title="head ：查看文件开头指定行数的内容"></a>head ：查看文件开头指定行数的内容</h3><p>命令描述：head命令用于查看文件开头指定行数的内容。</p><p>命令格式：<code>head [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n [行数]</td><td>显示开头指定行的文件内容，默认为10</td></tr><tr><td>-c [字符数]</td><td>显示开头指定个数的字符数</td></tr><tr><td>-q</td><td>不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名</td></tr></tbody></table><p>命令使用示例：</p><p>查看/etc/passwd文件的前5行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -5 /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="tail-：查看文档的后N行或持续刷新内容"><a href="#tail-：查看文档的后N行或持续刷新内容" class="headerlink" title="tail ：查看文档的后N行或持续刷新内容"></a>tail ：查看文档的后N行或持续刷新内容</h3><p>命令描述：tail命令用于查看文档的后N行或持续刷新内容。</p><p>命令格式：<code>tail [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i41.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>显示文件最新追加的内容</td></tr><tr><td>-q</td><td>当有多个文件参数时，不输出各个文件名</td></tr><tr><td>-v</td><td>当有多个文件参数时，总是输出各个文件名</td></tr><tr><td>-c [字节数]</td><td>显示文件的尾部n个字节内容</td></tr><tr><td>-n [行数]</td><td>显示文件的尾部n行内容</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f -n 10 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="stat-：显示文件的详细信息"><a href="#stat-：显示文件的详细信息" class="headerlink" title="stat ：显示文件的详细信息"></a>stat ：显示文件的详细信息</h3><p>命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。</p><p>命令使用示例：</p><p>查看/etc/passwd文件的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="wc-：统计指定文本的行数、字数、字节数"><a href="#wc-：统计指定文本的行数、字数、字节数" class="headerlink" title="wc ：统计指定文本的行数、字数、字节数"></a>wc ：统计指定文本的行数、字数、字节数</h3><p>命令描述：wc命令用于统计指定文本的行数、字数、字节数。</p><p>命令格式：<code>wc [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i46.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><p>命令使用示例：</p><p>统计/etc/passwd文件的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="file-：辨识文件类型"><a href="#file-：辨识文件类型" class="headerlink" title="file ：辨识文件类型"></a>file ：辨识文件类型</h3><p>命令描述： file命令用于辨识文件类型。</p><p>命令格式：<code>file [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i48.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i47.31941d111Dv71Z">-b</td><td>列出辨识结果时，不显示文件名称</td></tr><tr><td>-c</td><td>详细显示指令执行过程，便于排错或分析程序执行的情形</td></tr><tr><td>-f [文件]</td><td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</td></tr><tr><td>-L</td><td>直接显示符号连接所指向的文件类别</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages文件的文件类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="diff-：比较文件的差异"><a href="#diff-：比较文件的差异" class="headerlink" title="diff ：比较文件的差异"></a>diff ：比较文件的差异</h3><p>命令描述：diff命令用于比较文件的差异。</p><p>命令格式：<code>diff [文件] [文件]</code></p><h2 id="3、文本处理命令"><a href="#3、文本处理命令" class="headerlink" title="3、文本处理命令"></a>3、文本处理命令</h2><h3 id="grep-：查找文件里符合条件的字符串"><a href="#grep-：查找文件里符合条件的字符串" class="headerlink" title="grep ：查找文件里符合条件的字符串"></a>grep ：查找文件里符合条件的字符串</h3><p>命令描述：grep命令用于查找文件里符合条件的字符串。</p><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>在Shell脚本中，grep通过返回一个状态值来表示搜索的状态：</p><ul><li>0：匹配成功。</li><li>1：匹配失败。</li><li>2：搜索的文件不存在。</li></ul><p>命令格式：<code>grep [参数] [正则表达式] [文件]</code></p><p>命令常用参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i54.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c或--count</td><td>计算符合样式的列数</td></tr><tr><td>-d recurse或-r</td><td>指定要查找的是目录而非文件</td></tr><tr><td>-e [范本样式]</td><td>指定字符串做为查找文件内容的样式</td></tr><tr><td>-E 或 --extended-regexp</td><td>将样式为延伸的正则表达式来使用</td></tr><tr><td>-F 或 --fixed-regexp</td><td>将样式视为固定字符串的列表</td></tr><tr><td>-G 或 --basic-regexp</td><td>将样式视为普通的表示法来使用</td></tr><tr><td>-i 或 --ignore-case</td><td>忽略字符大小写的差别</td></tr><tr><td>-n 或 --line-number</td><td>在显示符合样式的那一行之前，标示出该行的列数编号</td></tr><tr><td>-v 或 --revert-match</td><td>显示不包含匹配文本的所有行</td></tr></tbody></table><p>命令使用示例：</p><p>查看sshd服务配置文件中监听端口配置所在行编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n Port /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure><p>查询字符串在文本中出现的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c localhost /etc/hosts</span><br></pre></td></tr></table></figure><p>反向查找，不显示符合条件的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br><span class="line">ps -ef | grep -v grep | grep sshd</span><br></pre></td></tr></table></figure><p>以递归的方式查找目录下含有关键字的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r *.sh /etc</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;ntp[0-9].aliyun.com&#x27;</span> /etc/ntp.conf</span><br></pre></td></tr></table></figure><h3 id="sed-：文本处理"><a href="#sed-：文本处理" class="headerlink" title="sed ：文本处理"></a>sed ：文本处理</h3><p>命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。</p><ol><li>处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。</li><li>接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</li><li>接着处理下一行，这样不断重复，直到文件末尾。</li></ol><p>注意：</p><p>sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。<br>如果要改变源文件，需要使用-i选项。<br>命令格式：<code>sed [参数] [动作] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i63.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e [script]</td><td>执行多个script</td></tr><tr><td>-f [script文件]</td><td>执行指定script文件</td></tr><tr><td>-n</td><td>仅显示script处理后的结果</td></tr><tr><td>-i</td><td>输出到原文件，静默执行（修改原文件）</td></tr></tbody></table><p>动作说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i65.31941d111Dv71Z">动作</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在行后面增加内容</td></tr><tr><td>c</td><td>替换行</td></tr><tr><td>d</td><td>删除行</td></tr><tr><td>i</td><td>在行前面插入</td></tr><tr><td>p</td><td>打印相关的行</td></tr><tr><td>s</td><td>替换内容</td></tr></tbody></table><p>命令使用示例：</p><p>删除第3行到最后一行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在最后一行新增行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;$a admin:x:1000:1000:admin:/home/admin:/bin/bash&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>替换内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/SELINUX=disabled/SELINUX=enforcing/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>替换行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;1c abcdefg&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="awk-：文本处理"><a href="#awk-：文本处理" class="headerlink" title="awk ：文本处理"></a>awk ：文本处理</h3><p>命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><p>命令格式：<code>awk [参数] [脚本] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i72.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-F fs</td><td>指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i71.31941d111Dv71Z">-f file</td><td>读取awk脚本</td></tr><tr><td>-v val=val</td><td>在执行处理过程之前，设置一个变量var，并给其设置初始值为val</td></tr></tbody></table><p>内置变量：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i74.31941d111Dv71Z">变量</th><th>用途</th></tr></thead><tbody><tr><td>FS</td><td>字段分隔符</td></tr><tr><td>$n</td><td>指定分隔的第n个字段，如$1、$3分别表示第1、第三列</td></tr><tr><td>$0</td><td>当前读入的整行文本内容</td></tr><tr><td>NF</td><td>记录当前处理行的字段个数（列数）</td></tr><tr><td>NR</td><td>记录当前已读入的行数</td></tr><tr><td>FNR</td><td>当前行在源文件中的行号</td></tr></tbody></table><p>awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。</p><p>和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。</p><p>命令使用示例：</p><p>查看本机IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 |awk <span class="string">&#x27;/inet/&#123;print $2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看本机剩余磁盘容量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h |awk <span class="string">&#x27;/\/$/&#123;print $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>统计系统用户个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$3&lt;1000&#123;x++&#125; END&#123;print x&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$7!~/nologin$/&#123;print $1,$7&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出/etc/passwd文件中前三行记录的用户名和用户uid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -3 /etc/passwd | awk  <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;;print &quot;name\tuid&quot;&#125;&#123;print $1,&quot;\t&quot;$3&#125;END&#123;print &quot;sum lines &quot;NR&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看tcp连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>关闭指定服务的所有的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | awk &#123;<span class="string">&#x27;print $2&#x27;</span>&#125; | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h3 id="cut-：切割字符串"><a href="#cut-：切割字符串" class="headerlink" title="cut ：切割字符串"></a>cut ：切割字符串</h3><p>命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。</p><p>命令格式：<code>cut [参数] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i81.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以字节为单位进行分割</td></tr><tr><td>-c</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><h3 id="tr-：对来自标准输入的字符进行替换、压缩和删除"><a href="#tr-：对来自标准输入的字符进行替换、压缩和删除" class="headerlink" title="tr ：对来自标准输入的字符进行替换、压缩和删除"></a>tr ：对来自标准输入的字符进行替换、压缩和删除</h3><p>命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。</p><p>命令格式：<code>tr [参数] [文本]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i84.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>反选指定字符</td></tr><tr><td>-d</td><td>删除指定字符</td></tr><tr><td>-s</td><td>将重复的字符缩减成一个字符</td></tr><tr><td>-t [第一字符集] [第二字符集]</td><td>删除第一字符集较第二字符集多出的字符，使两个字符集长度相等</td></tr></tbody></table><p>命令使用示例：</p><p>将输入字符由大写转换为小写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;HELLO WORLD&quot;</span> | tr <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p>删除字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello 123 world 456&quot;</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p>压缩字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;thissss is      a text linnnnnnne.&quot;</span> | tr -s <span class="string">&#x27; sn&#x27;</span></span><br></pre></td></tr></table></figure><p>产生随机密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文件与权限</title>
    <link href="http://blog.sukiu.top/Linux/Linux-Files-And-Permissions/"/>
    <id>http://blog.sukiu.top/Linux/Linux-Files-And-Permissions/</id>
    <published>2021-11-07T08:47:19.000Z</published>
    <updated>2021-12-02T01:26:19.798Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中常用的文件目录管理和文件权限管理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文件目录管理命令"><a href="#1、文件目录管理命令" class="headerlink" title="1、文件目录管理命令"></a>1、文件目录管理命令</h2><h3 id="tree-：以树状图列出目录的内容"><a href="#tree-：以树状图列出目录的内容" class="headerlink" title="tree ：以树状图列出目录的内容"></a>tree ：以树状图列出目录的内容</h3><p>命令描述：tree命令用于以树状图列出目录的内容。</p><p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /usr/share/wallpapers/</span><br></pre></td></tr></table></figure><h3 id="ls-：显示指定工作目录下的内容"><a href="#ls-：显示指定工作目录下的内容" class="headerlink" title="ls ：显示指定工作目录下的内容"></a>ls ：显示指定工作目录下的内容</h3><p>注意是 L 的小写，不是大写 I</p><p>命令描述： ls命令用于显示指定工作目录下的内容。</p><p>命令格式：ls [参数] [目录名]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件及目录（包括隐藏文件）</td></tr><tr><td>-l</td><td>将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l）</td></tr><tr><td>-r</td><td>将文件反序列出（默认按英文字母正序）</td></tr><tr><td>-t</td><td>将文件按创建时间正序列出</td></tr><tr><td>-R</td><td>递归遍历目录下文件</td></tr></tbody></table><h3 id="pwd-：获取当前工作目录的绝对路径"><a href="#pwd-：获取当前工作目录的绝对路径" class="headerlink" title="pwd ：获取当前工作目录的绝对路径"></a>pwd ：获取当前工作目录的绝对路径</h3><p>命令描述：获取当前工作目录的绝对路径。</p><p>命令使用：<code>pwd</code></p><h3 id="cd-：切换工作目录"><a href="#cd-：切换工作目录" class="headerlink" title="cd ：切换工作目录"></a>cd ：切换工作目录</h3><p>命令描述：cd命令用于切换工作目录。</p><p>在路径表示中：</p><ul><li>一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。</li><li>两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。</li></ul><p>cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。</p><h3 id="touch-：修改文件或者目录的时间属性"><a href="#touch-：修改文件或者目录的时间属性" class="headerlink" title="touch ：修改文件或者目录的时间属性"></a>touch ：修改文件或者目录的时间属性</h3><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>命令格式：touch [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>如果指定文件不存在，不会建立新文件</td></tr><tr><td>-r</td><td>使用参考文件的时间记录</td></tr><tr><td>-t</td><td>设置文件的时间记录</td></tr></tbody></table><h3 id="mkdir-：新建子目录"><a href="#mkdir-：新建子目录" class="headerlink" title="mkdir ：新建子目录"></a>mkdir ：新建子目录</h3><p>命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p a/b/c</span><br></pre></td></tr></table></figure><h3 id="rm-：删除一个文件或者目录"><a href="#rm-：删除一个文件或者目录" class="headerlink" title="rm ：删除一个文件或者目录"></a>rm ：删除一个文件或者目录</h3><p>命令描述：rm命令用于删除一个文件或者目录。</p><p>命令格式：rm [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>删除前逐一询问确认</td></tr><tr><td>-f</td><td>无需确认，直接删除</td></tr><tr><td>-r</td><td>删除目录下所有文件</td></tr></tbody></table><h3 id="cp-：复制文件或目录"><a href="#cp-：复制文件或目录" class="headerlink" title="cp ：复制文件或目录"></a>cp ：复制文件或目录</h3><p>命令描述： cp命令主要用于复制文件或目录。</p><p>命令格式：cp [参数] [源文件] [目标文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>复制时保留链接</td></tr><tr><td>-f</td><td>覆盖已经存在的目标文件而不给出提示</td></tr><tr><td>-i</td><td>覆盖前询问</td></tr><tr><td>-p</td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td>-r</td><td>复制目录及目录内的所有项目</td></tr></tbody></table><h3 id="mv-：为文件或目录改名-将文件或目录移入其它位置"><a href="#mv-：为文件或目录改名-将文件或目录移入其它位置" class="headerlink" title="mv ：为文件或目录改名 / 将文件或目录移入其它位置"></a>mv ：为文件或目录改名 / 将文件或目录移入其它位置</h3><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>命令格式：mv [参数] [源文件] [目标文件]</p><p>参数说明：</p><p>参数    说明<br>-i    若指定目录已有同名文件，则先询问是否覆盖旧文件<br>-f    如果目标文件已经存在，不会询问而直接覆盖</p><h3 id="rename-：批量改变文件名"><a href="#rename-：批量改变文件名" class="headerlink" title="rename ：批量改变文件名"></a>rename ：批量改变文件名</h3><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p><p>命令格式：rename [原值] [替换值]</p><h2 id="2、文件权限管理"><a href="#2、文件权限管理" class="headerlink" title="2、文件权限管理"></a>2、文件权限管理</h2><p>ls命令可以查看Linux系统上的文件、目录和设备的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /boot/</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuYWxpY2RuLmNvbS90ZnMvVEIxMmdYY0hORDFnSzBqU1pGS1hYY0pyVlhhLTg2OS00MjAucG5n?x-oss-process=image/format,png#pic_center" alt="ls"><br>上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p><ul><li>第1位表示存档类型，d表示目录，-表示一般文件。</li><li>第2~4位表示当前用户的权限（属主权限）。</li><li>第5~7位表示同用户组的用户权限（属组权限）。</li><li>第8~10位表示不同用户组的用户权限（其他用户权限）。</li><li>第11位是一个半角句号.，表示SELinux安全标签。</li></ul><p>用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。</p><p>例如efi目录的root用户权限为drwxr-xr-x.。</p><ul><li>该目录对root用户具有读写和执行所有权限。</li><li>该目录对root组其他用户有读和执行权限。</li><li>该目录对其他用户有读和执行权限。</li></ul><p>所以该权限表示对应八进制权限表示为：</p><ul><li>属主权限：4+2+1=7。</li><li>属组权限：4+1=5。</li><li>其他用户权限：4+1=5。</li></ul><p>即755。</p><h3 id="chmod-：修改文件权限"><a href="#chmod-：修改文件权限" class="headerlink" title="chmod ：修改文件权限"></a>chmod ：修改文件权限</h3><p>chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。</p><p>将hello.sh文件增加属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件撤销属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件权限修改为八进制表示的744权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 hello.sh</span><br></pre></td></tr></table></figure><p><strong>u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。</strong></p><h3 id="chown-：修改文件的属主和属组"><a href="#chown-：修改文件的属主和属组" class="headerlink" title="chown ：修改文件的属主和属组"></a>chown ：修改文件的属主和属组</h3><p>chown命令修改文件的属主和属组</p><ul><li>-R参数以递归方式对子目录和文件进行修改</li><li>ls -l命令显示的第三列和第四列就是文件的属主和属组信息。</li></ul><p>修改test.txt文件的属主用户为test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="built_in">test</span> test.txt</span><br></pre></td></tr></table></figure><p>修改test.txt文件的属主和属组为admin。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown admin:admin test.txt</span><br></pre></td></tr></table></figure><h3 id="chgrp-：修改文件的属组"><a href="#chgrp-：修改文件的属组" class="headerlink" title="chgrp ：修改文件的属组"></a>chgrp ：修改文件的属组</h3><p>chgrp命令用于修改文件的属组。</p><p>命令使用示例：</p><p>将test.txt文件的属组改为root。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp root test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux系统中常用的文件目录管理和文件权限管理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://blog.sukiu.top/Algorithm/Binary-Tree-Traversal/"/>
    <id>http://blog.sukiu.top/Algorithm/Binary-Tree-Traversal/</id>
    <published>2021-11-03T00:47:26.000Z</published>
    <updated>2021-12-02T01:03:37.563Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树遍历主要包括：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><span id="more"></span><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、递归遍历"><a href="#1、递归遍历" class="headerlink" title="1、递归遍历"></a>1、递归遍历</h2><p><strong>递归三要素：</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>即 根-左-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> preOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    preOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        preOrder(root.Left)</span><br><span class="line">        preOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>即 左-根-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.Left)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        inOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>即 左-右-根</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    postorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.Left)</span><br><span class="line">        postorder(root.Right)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、迭代遍历"><a href="#2、迭代遍历" class="headerlink" title="2、迭代遍历"></a>2、迭代遍历</h2><p><strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 通过这种标记法实现二叉树的统一迭代遍历。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif" alt="中序遍历"></p><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123; </span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; </span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、层序遍历"><a href="#3、层序遍历" class="headerlink" title="3、层序遍历"></a>3、层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := list.New()</span><br><span class="line">    queue.PushBack(root)</span><br><span class="line">    t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        l := queue.Len()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">            node := queue.Remove(queue.Front()).(*TreeNode)</span><br><span class="line">            t = <span class="built_in">append</span>(t, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        t = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树遍历主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先遍历&lt;ul&gt;
&lt;li&gt;前序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;中序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;后序遍历（递归法，迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广度优先遍历&lt;ul&gt;
&lt;li&gt;层次遍历（迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>常见容器底层</title>
    <link href="http://blog.sukiu.top/Data-structure/Common-Container/"/>
    <id>http://blog.sukiu.top/Data-structure/Common-Container/</id>
    <published>2021-11-02T01:10:23.000Z</published>
    <updated>2021-12-02T01:04:01.705Z</updated>
    
    <content type="html"><![CDATA[<p>各种语言下，常见容器底层整理。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/834cc223bb57">C++ STL容器底层数据结构总结 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/359878588">C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1、C"><a href="#1、C" class="headerlink" title="1、C++"></a>1、C++</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>其底层数据结构是<strong>数组</strong>，由于能动态扩容，所以也称<strong>动态数组</strong></p><p><strong>特点：</strong></p><ul><li><p>随机访问：$O(1)$</p></li><li><p>随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删</p></li><li><p>扩容规则：</p><ul><li>新建时初始化一片空间</li><li>插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据</li><li>释放原来空间</li></ul></li><li><p>在进行迭代器相关的修改操作时（包括扩容），<strong>所有迭代器和指针引用都会失效</strong></p></li></ul><h3 id="map-amp-multimap-amp-set-amp-multiset"><a href="#map-amp-multimap-amp-set-amp-multiset" class="headerlink" title="map &amp; multimap &amp; set &amp; multiset"></a>map &amp; multimap &amp; set &amp; multiset</h3><p>map提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。</p><p>与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。</p><p>底层数据结构均为<strong>红黑树</strong>，可以参考[教你透彻了解红黑树](<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com)</a>)。</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(logn)$</li></ul><h3 id="unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset"><a href="#unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset" class="headerlink" title="unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset"></a>unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset</h3><p>顾名思义，以上容器是无序的，所以底层实现为<strong>哈希表</strong>，因此其查找时间复杂度理论上达到了<strong>O(n)</strong></p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题</li></ul><h2 id="2、Go"><a href="#2、Go" class="headerlink" title="2、Go"></a>2、Go</h2><p>Go 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>底层数据结构是哈希表</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;各种语言下，常见容器底层整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Container" scheme="http://blog.sukiu.top/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>Priority Queue Go 优先队列</title>
    <link href="http://blog.sukiu.top/Data-structure/Priority-Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Priority-Queue/</id>
    <published>2021-11-01T14:13:03.000Z</published>
    <updated>2021-12-02T01:05:16.887Z</updated>
    
    <content type="html"><![CDATA[<p><em>论如何在 Go 语言中使用优先队列。</em></p><span id="more"></span><blockquote><p>参考：</p><p><a href="http://cngolib.com/container-heap.html">Go标准库中文文档 (cngolib.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Go 提供了 <a href="https://golang.org/pkg/container/heap/">container/heap</a> 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 <code>index = 0</code> 的值是最小的，即最小堆。</p><p>堆也是实现优先队列 Priority Queue 的常用方式。</p><p>堆中元素的类型需要实现 <code>heap.Interface</code> 这个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <a href="https://golang.org/pkg/sort/#Interface">sort.Interface</a> 包括 <code>Len()</code>, <code>Less</code>, <code>Swap</code> 方法。</p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap [][<span class="number">2</span>]<span class="keyword">int</span> <span class="comment">// 0 key 1 value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i][<span class="number">1</span>] &lt; h[j][<span class="number">1</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.([<span class="number">2</span>]<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 347. 前 K 个高频元素</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/top-k-frequent-elements/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        m[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">        heap.Push(h, [<span class="number">2</span>]<span class="keyword">int</span>&#123;key, value&#125;)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        k--</span><br><span class="line">        ans[k] = heap.Pop(h).([<span class="number">2</span>]<span class="keyword">int</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;论如何在 Go 语言中使用优先队列。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Monotone Queue 单调队列</title>
    <link href="http://blog.sukiu.top/Data-structure/Monotone-Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Monotone-Queue/</id>
    <published>2021-11-01T13:19:06.000Z</published>
    <updated>2021-12-02T01:05:13.584Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>“如果一个选手比你小还比你强，你就可以退役了。”</strong>——单调队列的原理</em></p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素<strong>可能</strong>成为某个区间最值时才保留它。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="单调队列如何维护队列里的元素"></p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><p>以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><blockquote><p>保证队列里单调递减或递增的原则，所以叫做单调队列。</p></blockquote><p>以下不是固定写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MonotoneQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MonotoneQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MonotoneQueue&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Front</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.queue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Back</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.queue[<span class="built_in">len</span>(this.queue)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.queue) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> !this.Empty() &amp;&amp; x &gt; this.Back() &#123;</span><br><span class="line">        this.queue = this.queue[:<span class="built_in">len</span>(this.queue)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue = <span class="built_in">append</span>(this.queue, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MonotoneQueue)</span> <span class="title">Pop</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !this.Empty() &amp;&amp; this.Front() == x &#123;</span><br><span class="line">        this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;“如果一个选手比你小还比你强，你就可以退役了。”&lt;/strong&gt;——单调队列的原理&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://blog.sukiu.top/Data-structure/Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Queue/</id>
    <published>2021-10-28T07:00:39.000Z</published>
    <updated>2021-12-02T01:05:19.962Z</updated>
    
    <content type="html"><![CDATA[<p>与栈类似，队列是一种<strong>先进先出</strong>的容器适配器。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/queue-stack/k6zxm/">队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p></blockquote><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/14/screen-shot-2018-05-03-at-151021.png" alt="先入先出的数据结构" style="zoom:50%;" /><p>在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。</p><p>如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/%E5%87%BA%E5%85%A5%E9%98%9F.gif" alt="入队与出队" style="zoom:50%;" /><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><p>为了实现队列，我们可以使用动态数组和指向队列头部的索引。</p><p><strong>简单的参考实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// store elements</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">        <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyQueue</span>() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。</p><p>所以应该规定数组的长度，一组一组队列的进行使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与栈类似，队列是一种&lt;strong&gt;先进先出&lt;/strong&gt;的容器适配器。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://blog.sukiu.top/Data-structure/Stack/"/>
    <id>http://blog.sukiu.top/Data-structure/Stack/</id>
    <published>2021-10-28T06:32:13.000Z</published>
    <updated>2021-12-02T01:05:23.272Z</updated>
    
    <content type="html"><![CDATA[<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。</p><p>STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/queue-stack/gxtls/">队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。</p><p>与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。</p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png" alt="后入先出的数据结构" style="zoom: 50%;" /><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/%E5%87%BA%E5%85%A5%E6%A0%88.gif" alt="入栈与出栈" style="zoom:50%;" /><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p><img src="https://img-blog.csdnimg.cn/20210104235459376.png" alt="栈与队列理论3" style="zoom:50%;" /><p><strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line">std::queue&lt;<span class="keyword">int</span>, std::list&lt;<span class="keyword">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><p><strong>动态数组实现参考：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;               <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/** Insert an element into the stack. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Get the top item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStack s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (s.<span class="built_in">pop</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（即可以控制使用哪种容器来实现栈的功能）。&lt;/p&gt;
&lt;p&gt;STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Stack" scheme="http://blog.sukiu.top/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://blog.sukiu.top/Algorithm/String-KMP/"/>
    <id>http://blog.sukiu.top/Algorithm/String-KMP/</id>
    <published>2021-10-19T11:56:00.000Z</published>
    <updated>2021-12-02T01:04:45.764Z</updated>
    
    <content type="html"><![CDATA[<p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>借用了<a href="https://www.cnblogs.com/dusf/p/kmp.html">这篇博客</a>的一些插图和理解</p><p>next数组就是一个前缀表（prefix table）：<strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p>假设 匹配串 S， 模式串 T</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4MzkxMi00OTM2NWI3ZTY3Y2Q0ODc3YjJmNTAxMDc0ZGFlNjhkMi5wbmc?x-oss-process=image/format,png" alt="初始状态"></p><ul><li><strong>最长公共前后缀</strong> ：<br>  ABCAB 公共前后缀 是 AB<br>  ABABA 公共前后缀 是 ABA<br>  ABCABC 公共前后缀 是 ABC</li></ul><p>如图，S[3]!=T[3]（i=3，j=3），但前面的 ABA 有公共前后缀 A (最长公共前后缀不能等于前面的串长)，长度为 1，所以把 j 移到 1（前缀移到后缀处）， 如下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4MzkyOS1hOWNjZmIwODgzM2U0Y2YxYTQyYzMwZjA1NjA4ZjhmNS5wbmc?x-oss-process=image/format,png" alt="不匹配"></p><p>又比如 下图中，S[5]!=T[5]（i=5，j=5），有公共前后缀 AB，长度 2</p><p>将 j 移到 2 （i=5，j=2）</p><table><tr><th><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDAzMC04MmU0YjcxYjg1YTQ0MGM1YTYzNmQ1NzUwMzkzMTQxNS5wbmc?x-oss-process=image/format,png"></th><th><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDAzNy1jYzNjMzQyMDA4MDk0MTRlOTQyMWMzMTZjZWJhMmNkYS5wbmc?x-oss-process=image/format,png"></tr></table><p>所以，重点要求 next 数组：</p><p><strong>next[i] : 满足 x[i-k…i-1]=x[0…k-1] 的最大 k 值</strong><br>（最长公共前后缀的长度）</p><p>考虑四种情况：</p><ul><li>① j = 0 ， 如果不匹配，j 已经在最左边，无法回退，所以要右移，即初始化 next [ 0 ] = -1</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDI1OC1lZmQyZTk1ZDM2NDQ0MjdlYmMwMzA0ZWQzZDdhZGVmYi5wbmc?x-oss-process=image/format,png" alt="j=0"></p><ul><li>② j = 1 , 如果不匹配，只能左移到 0 ，所以 next [ 1 ] = 0<br>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDMxMC0yOWY5ZjhkYmI2MDM0MTUxYTM4M2U3Y2NmNmY1NTgzZS5wbmc?x-oss-process=image/format,png" alt="j=1"></li><li>③ X [ k ] = X [ j ]<br>  匹配到这个位置说明失配位置前 公共前后缀相等，即<br>  X [ 0…k-1 ] = X [ j-k…j-1] （k 为公共前后缀长度）<br>  那么，X [ 0…k ] = X [ j-k…j ]<br>  所以，next [ j+1 ] = k+1 (数组下标从 0 开始，长度为 k+1)<br>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDMyNy04YTNjZGZhYjAzMDk0YmZhOWU1Y2FjZTI2Nzk2Y2FlNS5wbmc?x-oss-process=image/format,png" alt="匹配"></li><li>④ X [ k ] != X [ j ]<br>  next[i] : 满足 x[j-k…i-1]=x[0…j-1] 的最大 k 值(k 为最长公共前后缀)<br>  此时，<strong>将前缀移到后缀位置</strong>，即指针前移到最长公共前后缀的长度位置，可以得出：<br>  k = next [ k ]<br>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzEyMjM1OC1mZDdlNTJkZDM4MmM0MjY4YThmZjUyYjg1YmZmNDY1ZC5wbmc?x-oss-process=image/format,png" alt="不匹配"></li></ul><p>不过，这样求得的 next 数组还有缺陷：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDcxMi1mMGQ2OTk4OTM4NzY0YjMwOWY2MTkyMzQ1MmEyYjIwZi5wbmc?x-oss-process=image/format,png" alt="缺陷"></p><p>按照前述，j 移到 最长公共前后缀长度 1 的位置：</p><p>这一步是完全没有意义的。因为后面的 B 已经不匹配了，那前面的 B 也一定是不匹配的，即 <strong>X[ j ] = X[ next[ j ] ] 的情况没有意义</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDE2MDEwLzIwMTMwOC8xNzA4NDcyNi03OTBmYzFiMmM0OGM0MTFiODAxMWVhYjlkZTY5MmY2ZC5wbmc?x-oss-process=image/format,png" alt="重复"></p><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md">代码随想录动图示例：</a></p><img src="https://camo.githubusercontent.com/49f9392ca7baccbfbaec6823dbad095a6a582a7d1a101b4f37e2fa3eb5003061/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f4b4d50254537254232254245254538254145254232332e676966"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(next []<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    next[<span class="number">0</span>] = j</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">for</span> j !=<span class="number">-1</span> &amp;&amp; s[i] != s[j] &#123; <span class="comment">// 前后缀不同，向前回退</span></span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(s) || j &gt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j] &#123; <span class="comment">// 优化去重</span></span><br><span class="line">            next[i] = next[j]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i] = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(needle))</span><br><span class="line">    getNext(next, needle)</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(haystack) &amp;&amp; j &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">for</span> j !=<span class="number">-1</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nx[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnx</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    j=nx[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">-1</span>!=j &amp;&amp; x[i]!=x[j]) j=nx[j];</span><br><span class="line">        <span class="keyword">if</span> (x[++i]==x[++j]) nx[i]=nx[j];</span><br><span class="line">        <span class="keyword">else</span> nx[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123; <span class="comment">//s为匹配串，t为模式串</span></span><br><span class="line">    <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getnx</span>(t);</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">-1</span>!=j &amp;&amp; s[i]!=t[j]) j=nx[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j==m)</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p>即<strong>最小的循环节</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(next []<span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// 计算后缀，不需要去重</span></span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">    next[<span class="number">0</span>] = j</span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != s[j] &#123; <span class="comment">// 前后缀不同，向前回退</span></span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>) <span class="comment">// 多+1 计算末位最长前后缀</span></span><br><span class="line">    getNext(next, s)</span><br><span class="line">    l := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> next[l] != <span class="number">0</span> &amp;&amp; l%(l-next[l]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;KMP主要应用在字符串匹配上。&lt;/p&gt;
&lt;p&gt;KMP的主要思想是&lt;strong&gt;当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="String" scheme="http://blog.sukiu.top/tags/String/"/>
    
  </entry>
  
</feed>
