<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千反田</title>
  
  <subtitle>Kanna</subtitle>
  <link href="http://blog.sukiu.top/rss.xml" rel="self"/>
  
  <link href="http://blog.sukiu.top/"/>
  <updated>2021-12-21T13:35:27.151Z</updated>
  <id>http://blog.sukiu.top/</id>
  
  <author>
    <name>SukiEva</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>传输层</title>
    <link href="http://blog.sukiu.top/Computer-network/Transport-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Transport-Layer/</id>
    <published>2021-12-21T11:17:05.000Z</published>
    <updated>2021-12-21T13:35:27.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层</strong>（<strong>Transport Layer</strong>）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。</p><p>功能：使用网络层服务，为应用层提供服务</p><ul><li>提供进程和进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li></ul><p>传输层的重要协议：</p><ul><li>TCP（Transmission Control Protocol）传输控制协议</li><li>UDP（User Datagram Protocol）用户数据报协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/">力扣</a><br>王道考研</p></blockquote><h2 id="1、TCP"><a href="#1、TCP" class="headerlink" title="1、TCP"></a>1、TCP</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212129515.png" style="zoom:33%;" /><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211934483.png" style="zoom: 40%;" /><blockquote><p>标志位：SYN（Synchronize）、ACK（ACKnowledge Character）<br>序号：seq<br>确认号：ack</p><p>第 2 次握手为什么还要传回 SYN：</p><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了把自己的初始序列号（seq）同步给客户端。</p></blockquote><h4 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h4><p>三次握手保证两点：</p><ul><li>保证双方都是双工通信：<ul><li>第一次握手，服务端确定客户端的发送正常</li><li>第二次握手，客户端确认服务端的收发正常</li><li>第三次握手，服务端确定客服端接收正常</li></ul></li><li>如果只有第二次握手，服务端发给客服端的包丢了之后：<ul><li>服务端直接建立了连接，端口就会一直开着</li><li>等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接</li><li>端口越来越多，造成服务器开销的浪费</li></ul></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211949356.png" alt="image-20211221194951070" style="zoom: 33%;" /><h4 id="握手异常"><a href="#握手异常" class="headerlink" title="握手异常"></a>握手异常</h4><table><thead><tr><th>异常</th><th>如何处理</th><th>备注</th></tr></thead><tbody><tr><td>第一次握手 SYN 包丢失</td><td><strong>服务端</strong>不会进行任何相应的动作<br><strong>客户端</strong>在一段时间内没有收到服务器发来的确认报文， 会等待一段时间后重新发送 SYN 同步报文，<br>若仍没有回应，则重复上述直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1</td><td>客户端超时重传最大次数：<code>tcp_syn_retries</code>，默认5次（Linux 3.7 后为6次）</td></tr><tr><td>第二次握手 SYN、ACK 包丢失</td><td><strong>客户端</strong>会采取第一次握手失败时的动作（超时重传）<br><strong>服务端</strong>此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文（同样超时重传）</td><td>服务端超时重传最大次数：<code>tcp_synack_retries</code>，默认5次</td></tr><tr><td>第三次握手 ACK 包丢失</td><td>两次握手成功，<strong>客户端</strong>进入<code>ESTABLISHED</code>状态，<strong>服务端</strong>进入<code>SYN_REC</code>状态<br><strong>服务端</strong>收不到 ACK，就一直重传 SYN、ACK 包，直到超过最大次数，断开TCP连接<br><strong>客户端</strong>认为自己连接成功，开始向服务器端发送数据，服务端收到来自客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态</td><td></td></tr></tbody></table><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112211951252.png" style="zoom: 40%;" /><blockquote><p>标志位：Fin（Finish）<br>阶段：FIN-WAIT（半关闭）</p><p>CLOSE-WAIT：是服务端发出第一次挥手（整体第二次）进入的状态</p><p>表示“我准备关闭了，但是还有自己的事情处理一下，你等我处理完”<br>等服务器处理好自己的数据业务，则表示“我准备好了”，再发送 FIN 包</p><p>TIME-WAIT：是第四次挥手后，客户端进入的状态，是客户端必要的等待时间。</p><p>目的是：等待服务端的对应端口关闭与客户端发送到服务端的数据到达（可能出现延迟）</p><p>如果不存在这个步骤就会导致两个问题:</p><ul><li><p>客户端立即关闭后，立即又用同样的端口握手并建立通信，此时上次的连接残留的数据包会被误认为是本次的，造成数据异常</p></li><li><p>客户端直接关闭后，若服务端重新发送 FIN 包，客户端就会回应 RST，会报异常，但是实际没有问题的</p></li></ul><p>MSL（Maximum Segment Lifetime）：指一段 TCP 报文在传输过程中的最大生命周期</p><p>2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长，为的是确认服务器能否接收到客户端发出的 ACK 确认报文</p></blockquote><h4 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h4><p>简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。</p><p>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的：</p><ul><li>当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文</li><li>当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212000734.png" style="zoom:33%;" /><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP 如何保证可靠传输：</p><ul><li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li><li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li><li><strong>流量控制</strong>：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li><li><strong>拥塞控制</strong>：当网络某个节点发生拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li></ul><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p>在已发送但未确认的报文被确认之前，发送方的滑动窗口将不会滑动（类比滑动窗口算法）</p><h4 id="最大连接数限制"><a href="#最大连接数限制" class="headerlink" title="最大连接数限制"></a>最大连接数限制</h4><ul><li><strong>Client 最大 TCP 连接数</strong>：TCP 端口的数据类型是 unsigned short（$2^{16}$），可用端口最多有 65535 个（除端口0）</li><li><strong>Server最大 TCP 连接数</strong>：客户端 IP 数 × 客户端 port 数（理论）</li></ul><blockquote><p>对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 $2^{32}$（IP 数）× $2^{16}$（port 数），即约为$2^{48}$</p></blockquote><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212120334.png" style="zoom: 33%;" /><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><p>常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212127381.png" style="zoom: 40%;" /><blockquote><p><strong>拥塞控制和流量控制的区别：</strong><br>拥塞控制往往是一种全局的控制，防止过多的数据注入到网络之中<br>流量控制往往指点对点通信量的控制，是端到端的问题（TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处）</p></blockquote><h2 id="2、UDP"><a href="#2、UDP" class="headerlink" title="2、UDP"></a>2、UDP</h2><h3 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h3><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212131402.png" style="zoom: 33%;" /><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20~60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8个字节</td></tr></tbody></table><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112212058636.png" style="zoom: 50%;" /><h3 id="不可靠传输"><a href="#不可靠传输" class="headerlink" title="不可靠传输"></a>不可靠传输</h3><ul><li>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，当对方接收缓冲区满了后就会丢弃，因此 UDP 不能保证数据能够到达目的地</li><li>UDP 没有流量控制和重传机制</li><li>UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号</li></ul><blockquote><p>调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。<br>调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。<br>当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p></blockquote><h2 id="3、More"><a href="#3、More" class="headerlink" title="3、More"></a>3、More</h2><h3 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。<br>通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;（&lt;strong&gt;Transport Layer&lt;/strong&gt;）位于 OSI 模型第四层。该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。&lt;/p&gt;
&lt;p&gt;功能：使用网络层服务，为应用层提供服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供进程和进程之间的逻辑通信&lt;/li&gt;
&lt;li&gt;复用和分用&lt;/li&gt;
&lt;li&gt;传输层对收到的报文进行差错检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP（Transmission Control Protocol）传输控制协议&lt;/li&gt;
&lt;li&gt;UDP（User Datagram Protocol）用户数据报协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://blog.sukiu.top/Computer-network/Application-Layer/"/>
    <id>http://blog.sukiu.top/Computer-network/Application-Layer/</id>
    <published>2021-12-12T07:28:27.000Z</published>
    <updated>2021-12-16T10:52:17.609Z</updated>
    
    <content type="html"><![CDATA[<p><strong>应用层</strong>（<strong>Application layer</strong>）位于 <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" title="OSI模型">OSI模型</a>的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。</p><p>应用层的功能：</p><ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>应用层的重要协议：</p><ul><li>HTTP（HyperText Transfer Protocol）超文本传输协议</li><li>FTP（File Transfer Protocol）文件传输协议<ul><li>TFTP（Trivial File Transfer Protocol）简单文件传输协议</li></ul></li><li>DNS（Domain Name System）域名系统</li><li>SMTP（Simple Mail Transfer Protocol）简单邮件传输协议<ul><li>POP3（Post Office Protocol - Version 3）邮局协议</li></ul></li><li>DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议</li><li>SNMP（Simple Network Management Protocol）简单网络管理协议</li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eksi0s/">力扣</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP Headers - HTTP | MDN</a></p></blockquote><h2 id="1、HTTP"><a href="#1、HTTP" class="headerlink" title="1、HTTP"></a>1、HTTP</h2><h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(General Header Fields)</li><li>请求头字段(Request Header Fields)</li><li>响应头字段(Response Header Fields)</li><li>实体头字段(Entity Header Fields)</li></ul><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h4><p>同时适用于请求和响应消息（客户端和服务器都可以使用），但与最终消息主体中传输的数据无关的消息头。</p><p>可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中是否使用缓存机制</td><td>Cache-Control: no-store</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td>Connection: keep-alive (Upgrade)</td></tr><tr><td>Date</td><td>报文创建时间</td><td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td></tr><tr><td>Trailer</td><td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td><td>Trailer: Expiress</td></tr><tr><td>Transfer-Encoding</td><td>用来改变报文格式</td><td>Transfer-Encoding: chunked</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容中可能存在错误</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h4><p>包含更多有关要获取的资源或客户端本身信息的消息头，如Accept头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器自己允许哪些媒体类型</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>浏览器申明可接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己接收的编码方法</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的响应内容语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于表示 HTTP 协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号</td><td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td></tr><tr><td>If-XXX</td><td>条件请求</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数</td><td>Max-Forwards: 10</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以 0 开始</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td><td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td>User-Agent: Mozilla/……</td></tr></tbody></table><h4 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h4><p>包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头，如Server头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>字段的值表示可用于定义范围的单位</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>创建响应的时间</td><td>Age：5744337</td></tr><tr><td>ETag</td><td>唯一标识分配的资源</td><td>Etag：W/"585cd998-7c0f"</td></tr><tr><td>Location</td><td>表示重定向后的 URL</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>告知客户端多久后再发送请求</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>告知客户端服务器信息</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Vary</td><td>缓存控制</td><td>Vary: Origin</td></tr></tbody></table><h4 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h4><p>请求/响应报文中实体部分的首部，包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型，如Content-Type头部。</p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p><strong>非Keep-alive</strong>：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。<br><strong>Keep-alive</strong>：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。</p><h5 id="长连接-or-短链接"><a href="#长连接-or-短链接" class="headerlink" title="长连接 or 短链接"></a>长连接 or 短链接</h5><p><a href="https://blog.csdn.net/luzhensmart/article/details/87186401">http的长连接和短连接（史上最通俗！）以及应用场景_luzhensmart的专栏-CSDN博客_长连接和短连接的使用场景</a></p><p><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接</strong>：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h4 id="报文长度"><a href="#报文长度" class="headerlink" title="报文长度"></a>报文长度</h4><p>长度在响应报文中有两种表现形式。</p><ol><li>对于小点的文件，直接给出 content-length，也就是本次返回的数据长度</li><li>对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分块传输，这也是订好了协议，客户端收到了会进行组装，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</li></ol><p>曾经用 py 写过下载脚本，就利用了分块传输的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_size = <span class="built_in">int</span>(r.headers[<span class="string">&#x27;content-length&#x27;</span>])</span><br><span class="line"><span class="keyword">with</span> tqdm(total=file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, unit_divisor=<span class="number">1024</span>, <span class="built_in">ascii</span>=<span class="literal">True</span>,desc=filename) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            fp.write(chunk)</span><br><span class="line">            bar.update(<span class="built_in">len</span>(chunk))</span><br></pre></td></tr></table></figure><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>HTTP/1.0 定义了三种请求方法：<code>GET</code>, <code>POST</code> 和 <code>HEAD</code> 方法。</p><p>HTTP/1.1 增加了六种请求方法：<code>OPTIONS</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code> 方法。</p><p><del>感觉实际生产中很少会用那6种方法，极大的复杂化了api</del></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h4 id="GET-or-POST"><a href="#GET-or-POST" class="headerlink" title="GET or POST"></a>GET or POST</h4><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）</li></ul><blockquote><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。<br>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p></blockquote><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限制</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP包头<br>如果数据是中文或其它字符，则进行BASE64编码。</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><p><strong>长度限制：</strong></p><ul><li>GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</li><li>POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</li></ul><h3 id="HTTP-状态"><a href="#HTTP-状态" class="headerlink" title="HTTP 状态"></a>HTTP 状态</h3><p>HTTP 协议是<strong>无连接无状态</strong>的，并不保存关于客户端的任何信息。<br>通常有两种方法保持会话：</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。</p><blockquote><p>优点：安全性高，因为状态信息保存在服务器端。<br>缺点：由于大型网站往往采用的是分布式服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。<br>【解决方法】：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息</p></blockquote><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。<br>客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。</p><blockquote><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。<br>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据；每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p></blockquote><h4 id="Cookie-被禁用"><a href="#Cookie-被禁用" class="headerlink" title="Cookie 被禁用"></a>Cookie 被禁用</h4><p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。</p><p>HTTP 状态码共有 5 种类型：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1XX</td><td>指示信息--表示请求正在处理</td></tr><tr><td>2XX</td><td>成功--表示请求已被成功处理完毕</td></tr><tr><td>3XX</td><td>重定向--要完成的请求需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器端错误--服务器处理请求出现错误</td></tr></tbody></table><p>常见的状态码有如下几种：</p><ul><li><code>200 OK</code> 客户端请求成功</li><li><code>301 Moved Permanently</code> 请求永久重定向</li><li><code>302 Moved Temporarily</code> 请求临时重定向</li><li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li><li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li><li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li><li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><blockquote><p>更多可见 <a href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 状态码_w3cschool</a></p></blockquote><h4 id="面试对状态码常见问法"><a href="#面试对状态码常见问法" class="headerlink" title="面试对状态码常见问法"></a>面试对状态码常见问法</h4><h5 id="状态码-301-和-302-的区别"><a href="#状态码-301-和-302-的区别" class="headerlink" title="状态码 301 和 302 的区别"></a>状态码 301 和 302 的区别</h5><ul><li>301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</li><li>302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</li></ul><h5 id="HTTP-异常状态码"><a href="#HTTP-异常状态码" class="headerlink" title="HTTP 异常状态码"></a>HTTP 异常状态码</h5><p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p><h2 id="2、HTTPS"><a href="#2、HTTPS" class="headerlink" title="2、HTTPS"></a>2、HTTPS</h2><p>HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式：<br>首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性。<br>通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><table>    <tr>    <td>协议</td>    <td>特点</td>    <td>工作方式</td>    </tr>    <tr>        <td>HTTP</td>        <td>        <li>明文传输，数据未加密，安全性较差        <li>默认 80 端口        <li>3 次握手建立连接        </td>        <td>        <ol>        <li>客户端请求服务器 80 端口，建立 TCP 连接        <li>客户端从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文        <li>服务端从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文        <li>通信结束，客户端与服务器关闭连接        </ol>        </td>    </tr>    <tr>        <td>HTTPS</td>        <td>        <li>加密，安全性较好        <li>默认 443 端口        <li>需数字认证机构（Certificate Authority, CA）的证书        <li>除 TCP 的 3 次握手，还需要 SSL 协商        </td>         <td>        <ol>        <li>客户端请求服务器 443 端口，建立 TCP 连接（包括支持算法，密钥长度等）        <li>服务端从双方共同支持的加密算法列表中选择一种返回给客户端（包括密钥组件）        <li>服务器返回自身 CA 证书的报文（包含证书的颁发机构、过期时间、服务端的公钥等信息）        <li>服务端发送一个完成报文通知客户端 SSL 的第一阶段已经<b>协商完成</b>        <li>客户端用本地证书库的根证书校验CA证书，生成随机密码串，用公钥加密发送给服务器，即回应报文        <li>紧接着客户端会发送一个报文提示服务端在此之后的报文是采用密码串加密的        <li>客户端发送一个 finish 报文（包含第一次握手至今所有报文的整体校验值）        <li>服务端同样发送与第 6 步中相同作用的报文，最后发送 finish 报文告诉客户端自己能够正确解密报文        <li>SSL 连接建立        </ol>        </td>    </tr></table><blockquote><p>CA 证书防止的方式：（为什么可以信任 CA 证书）<br>篡改：加密签名与原文签名对比<br>调包：请求域名与证书域名对比</p></blockquote><p>另附 HTTP 版本演变：</p><blockquote><p>直接造访 <a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez4zv6/">HTTP x.x</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161819417.png" style="zoom:67%;" /><h2 id="3、DNS"><a href="#3、DNS" class="headerlink" title="3、DNS"></a>3、DNS</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，提供了主机名和 IP 地址之间相互转换的服务。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161824712.png" style="zoom:80%;" /><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><ul><li><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。<strong>帮你查</strong></li><li><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询。<strong>自己查</strong></li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。</p><p>大多数情况下 DNS 使用 UDP 进行传输，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><p>在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据</li></ul><blockquote><p>因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p></blockquote><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。</p><p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。</p><h4 id="预防手段"><a href="#预防手段" class="headerlink" title="预防手段"></a>预防手段</h4><ul><li>直接使用IP访问</li><li>直接指定DNS服务器（如谷歌的 8.8.8.8）</li></ul><h2 id="4、More"><a href="#4、More" class="headerlink" title="4、More"></a>4、More</h2><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><blockquote><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p></blockquote><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。<br>例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><ul><li>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li><li>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</li><li>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li></ul><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><ul><li>URL，即统一资源定位符 ( <em>Uniform Resource Locator</em> )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</li><li>URI，即统一资源标识符（ <em>Uniform Resource Identifier</em> ），只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL</li></ul><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul><li>其实就是将抓包工具视为中间人，其对于本地而言相当于服务端；而对于真正的服务端而言则相当于客户端；</li><li>抓包工具分别和本地以及服务器都进行TLS握手协商；</li><li>这就需要本地能够信任抓包工具提供的证书（也就是需要额外安装一个证书）</li></ul><h3 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程"></a>网页解析全过程</h3><blockquote><p>这部分可以看看：<a href="https://github.com/skyline75489/what-happens-when-zh_CN"> 当···时发生了什么？what-happens-when</a></p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112161850389.png" style="zoom:67%;" /><ol><li><strong>DNS 解析</strong>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。</li><li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了</li><li><strong>发送 HTTP 请求</strong>：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</li></ol><blockquote><p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。<br>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p></blockquote><ol start="4"><li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li><li><strong>浏览器渲染</strong>：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li><strong>断开连接</strong>：客户端和服务器通过四次挥手终止 TCP 连接。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;（&lt;strong&gt;Application layer&lt;/strong&gt;）位于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B&quot; title=&quot;OSI模型&quot;&gt;OSI模型&lt;/a&gt;的第七层。应用层直接和应用程序接口结合，并提供常见的网络应用服务。&lt;/p&gt;
&lt;p&gt;应用层的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件传输、访问和管理&lt;/li&gt;
&lt;li&gt;电子邮件&lt;/li&gt;
&lt;li&gt;虚拟终端&lt;/li&gt;
&lt;li&gt;查询服务和远程作业登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层的重要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP（HyperText Transfer Protocol）超文本传输协议&lt;/li&gt;
&lt;li&gt;FTP（File Transfer Protocol）文件传输协议&lt;ul&gt;
&lt;li&gt;TFTP（Trivial File Transfer Protocol）简单文件传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS（Domain Name System）域名系统&lt;/li&gt;
&lt;li&gt;SMTP（Simple Mail Transfer Protocol）简单邮件传输协议&lt;ul&gt;
&lt;li&gt;POP3（Post Office Protocol - Version 3）邮局协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DHCP ( Dynamic Host Configuration Protocol）动态主机设置协议&lt;/li&gt;
&lt;li&gt;SNMP（Simple Network Management Protocol）简单网络管理协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络模型与协议</title>
    <link href="http://blog.sukiu.top/Computer-network/Models-And-Protocols/"/>
    <id>http://blog.sukiu.top/Computer-network/Models-And-Protocols/</id>
    <published>2021-12-09T01:17:18.000Z</published>
    <updated>2021-12-09T09:08:35.635Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络主要有3种模型：</p><ul><li>ISO/OSI参考模型 7层</li><li>TCP/IP参考模型 5层</li><li><strong>TCP/IP参考模型 4层</strong></li></ul><p><strong>OSI</strong>是一种理论下的<strong>模型</strong>，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekz8lr/">力扣</a><br>王道考研</p></blockquote><h2 id="1、参考模型"><a href="#1、参考模型" class="headerlink" title="1、参考模型"></a>1、参考模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。<br>OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112090939525.png" style="zoom:67%;" /><ul><li><strong>应用层</strong>：用户与网络的界面，通过应用程序间的交互来完成特定的网络应用</li></ul><blockquote><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。<br>例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。<br>在应用层交互的数据单元为报文。</p></blockquote><ul><li><strong>表示层</strong>：使通信的应用程序能够解释交换数据的含义<ul><li>数据格式变换 翻译官 <strong>数据描述</strong></li><li>数据加密解密 <strong>数据加密</strong></li><li>数据压缩和恢复 <strong>数据压缩</strong></li></ul></li></ul><blockquote><p>这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p></blockquote><ul><li><strong>会话层</strong>：负责建立、管理和终止表示层实体之间的通信会话。</li></ul><blockquote><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法（类似断点续传）。</p></blockquote><ul><li><p><strong>传输层</strong>：负责主机中两个进程的通信，即端到端通信。<font color="red">传输单位是报文段或用户数据报</font></p><ul><li><em>可</em> 靠传输、不可靠传输</li><li><em>差</em> 错控制</li><li><em>流</em> 量控制</li><li><em>复</em> 用分用（记忆：可差的也能流用？）<ul><li>复用：多个应用层进程可同时使用下面传输层的服务</li><li>分用：传输层把收到的信息分别交付给上面应用层相应的进程</li></ul></li></ul></li><li><p><strong>网络层</strong>：选择合适的网间路由和交换节点，确保数据按时成功传送。<font color="red">传输单位是数据报</font></p><ul><li><p>路由选择与分组转发 <strong>最佳路径</strong></p><blockquote><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。</p></blockquote></li><li><p>流量控制 <strong>发送速度</strong></p></li><li><p>差错控制</p></li><li><p>拥塞控制 <strong>总体速度</strong></p></li></ul></li><li><p><strong>数据链路层</strong>：把网络层传下来的数据报组装成帧。<font color="red">传输单位是帧</font></p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制 <strong>帧错+位错</strong></li><li>流量控制</li><li>访问（接入）控制 <strong>控制对信道的访问</strong></li></ul></li><li><p><strong>物理层</strong>：在物理媒体上实现比特流的透明传输。<font color="red">传输单位是比特</font></p><blockquote><p>尽可能屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么</p></blockquote><ul><li>定义接口特性（机械特性、电气特性、功能特性，过程特性）</li><li>定义传输模式 （单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ul></li></ul><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><blockquote><p>由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的。<br>三层都在应用程序内实现，程序间无法共享，合三为一就形成了 TCP/IP 模型。</p></blockquote><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091411643.png" style="zoom: 33%;" /><ul><li><p><strong>应用层</strong><br>  TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。</p><p>  例如：FTP、Telnet、DNS、SMTP 等。</p></li><li><p><strong>传输层</strong></p><p>  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。</p><p>  传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。</p><p>  其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p></li><li><p><strong>网际互联层</strong></p><p>  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。</p><p>  在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。</p><p>  根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。</p><p>  除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p></li><li><p><strong>网络接口层</strong></p><p>  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</p><p>  事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p></li></ul><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091513659.png" style="zoom: 67%;" /><h2 id="2、模型异同"><a href="#2、模型异同" class="headerlink" title="2、模型异同"></a>2、模型异同</h2><p><strong>相同点</strong></p><ul><li><p>OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p></li><li><p>都能够提供面向连接和无连接两种通信服务机制。</p></li></ul><p><strong>不同点</strong></p><ul><li><p>OSI 采用的七层模型； TCP/IP 是四层结构。</p></li><li><p>TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p></li><li><p>OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p></li><li><p>TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p></li><li><p>OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p></li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112091512496.png" alt="image-20211209151215402" style="zoom:50%;" /><h2 id="3、各层协议"><a href="#3、各层协议" class="headerlink" title="3、各层协议"></a>3、各层协议</h2><table>    <tbody><tr><th>OSI 七层网络模型</th><th>TCP/IP 四层概念模型</th><th>对应的网络协议</th>    </tr>    <tr><td>应用层（Application）</td><td rowspan="3">应用层</td>        <td><b>HTTP, FTP, DNS</b>, SMTP,TFTP,NFS, WAIS, Telnet, SNMP</td>    </tr>    <tr><td>表示层（Presentation）</td><td>TIFF, GIF, JPEG, PICT</td>    </tr>    <tr><td>会话层（Session）</td><td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>    </tr>    <tr><td>传输层（Transport）</td><td>传输层</td>        <td><b>TCP, UDP</b></td>    </tr>    <tr><td>网络层（Network）</td><td>网际层</td>        <td><b>IP</b>, ICMP, ARP, RARP, RIP, IPX</td>    </tr>    <tr><td>数据链路层（Data Link）</td><td rowspan="2">网络接口层</td><td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>    </tr>    <tr><td>物理层（Physical）</td><td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>    </tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络主要有3种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO/OSI参考模型 7层&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型 5层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP/IP参考模型 4层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;是一种理论下的&lt;strong&gt;模型&lt;/strong&gt;，而TCP/IP（4层）已被广泛使用，成为网络互联事实上的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Computer network" scheme="http://blog.sukiu.top/categories/Computer-network/"/>
    
    
    <category term="Network" scheme="http://blog.sukiu.top/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://blog.sukiu.top/Database/Redis/"/>
    <id>http://blog.sukiu.top/Database/Redis/</id>
    <published>2021-12-07T01:22:55.000Z</published>
    <updated>2021-12-07T09:08:13.722Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis (Remote Dictionary Server ) 远程字典服务</strong>，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。</p><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。</p><p>和Memcached类似，它支持存储的value类型相对更多，包括：</p><ul><li>string（字符串）</li><li>list（链表）</li><li>set（集合）</li><li>zset（sorted set 有序集合）</li><li>hash（哈希类型）</li></ul><p>与 memcached 一样，为了保证效率，数据都是缓存在<strong>内存</strong>中。<br>区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://www.w3cschool.cn/redis/">Redis 教程_w3cschool</a><br><a href="https://juejin.cn/post/6909672227734552583">Redis使用教程 - 掘金</a></p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库，它可以用作数据库、缓存和消息中间件。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高 </li></ul><blockquote><p>Redis能读的速度是110000次/s,写的速度是81000次/s 。</p></blockquote><ul><li>丰富的数据类型</li></ul><blockquote><p>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p></blockquote><ul><li>原子</li></ul><blockquote><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p></blockquote><ul><li>丰富的特性</li></ul><blockquote><p>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p></blockquote><h4 id="Redis-与其他-key-value-存储的区别"><a href="#Redis-与其他-key-value-存储的区别" class="headerlink" title="Redis 与其他 key-value 存储的区别"></a>Redis 与其他 key-value 存储的区别</h4><ul><li>Redis 运行在内存中但是可以 <strong>持久化到磁盘</strong>，重启的时候可以再次加载进行使用。</li><li>Redis 不仅仅支持简单的 Key-Value 类型的数据，同时还提供 List，Set，Sorted set，hash 等数据结构的存储。</li><li>Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。</li></ul><h4 id="Redis-和-MongoDB-的区别"><a href="#Redis-和-MongoDB-的区别" class="headerlink" title="Redis 和 MongoDB 的区别"></a>Redis 和 MongoDB 的区别</h4><p>更多可见：<a href="https://zhuanlan.zhihu.com/p/86777551">NoSQL，浅谈redis与mongoDB的区别 - 知乎</a></p><ul><li><strong>性能方面</strong>，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB；</li><li><strong>可操作性上</strong>，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 <strong>丰富的查询语言</strong>，操作比 Redis 更为便利；</li><li><strong>内存及存储方面</strong>，MongoDB 适合 <strong>大数据量存储</strong>，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加 <strong>虚拟内存特性</strong>，突破物理内存限制，数据可以设置时效性；</li><li><strong>对于数据持久化和数据恢复</strong>，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能；</li><li><strong>在数据一致性上</strong>，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行；</li><li><strong>数据分析上</strong>，MongoDB 内置 <strong>数据分析功能（mapreduce）</strong>，而 Redis 不支持数据分析；</li><li><strong>应用场景不同</strong>，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Redis</code>支持五种数据类型：</p><ul><li><code>string（字符串）</code></li><li><code>hash（哈希）</code></li><li><code>list（列表）</code></li><li><code>set（集合）</code></li><li><code>zset(sorted set：有序集合)</code></li></ul><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>最基本的类型，一个<code>key</code>对应一个<code>value</code>。<br><code>string</code>类型是二进制安全的，即<code>redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</p><blockquote><p>一个键最大能存储512MB。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sukiu.top&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-strings.html">Redis 字符串(String)_w3cschool</a></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p><code>Redis hash</code> 是一个键值 <code>(key=&gt;value)</code> 对集合。<br><code>Redis hash</code> 是一个 <code>string</code> 类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象。</p><blockquote><p>每个 <code>hash</code> 可以存储 232 - 1键值对（40多亿）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; hmset user:1 username sukiu.top password sukiu.top points 200</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">3) <span class="string">&quot;password&quot;</span></span><br><span class="line">4) <span class="string">&quot;sukiu.top&quot;</span></span><br><span class="line">5) <span class="string">&quot;points&quot;</span></span><br><span class="line">6) <span class="string">&quot;200&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;password&quot;</span></span><br><span class="line">3) <span class="string">&quot;points&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-hashes.html">Redis 哈希(Hash)_w3cschool</a></p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>Redis</code> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><blockquote><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush <span class="built_in">test</span> rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange <span class="built_in">test</span> 0 10</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-lists.html">Redis 列表(List)_w3cschool</a></p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>Redis</code> 的 <code>Set</code>是 <code>string</code> 类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><blockquote><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd t1 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd t1 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers t1</span><br><span class="line">1) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">2) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sets.html">Redis 集合(Set)_w3cschool</a></p><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>和 <code>set</code> 不同的是每个元素都会关联一个 <code>double</code> 类型的分数。<code>redis</code> 正是通过分数来为集合中的成员进行从小到大的排序。</p><p><code>zset</code> 的成员是唯一的,但分数<code>(score)</code>却可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd t2 0 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd t2 0 rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore t2 0 1000</span><br><span class="line">1) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line">2) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line">3) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3cschool.cn/redis/redis-sorted-sets.html">Redis 有序集合(sorted set)_w3cschool</a></p><h2 id="2、高级"><a href="#2、高级" class="headerlink" title="2、高级"></a>2、高级</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><blockquote><p>更多：<br><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理 - SegmentFault 思否</a></p></blockquote><p>Redis是内存数据库,如果不将内存中的数据库状态保存到磁盘,那么一旦服务器进程退出,服务器中的数据库状态也会消失。<br>Redis支持两种方式的持久化：RDB快照和AOF。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的时间点快照（point-to-time snapshot）。<br>它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。<br>到目前为止，仍是官方的默认支持方案。</p><p><strong>原理：</strong> Redis会单独创建( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><blockquote><p>整个过程中，主进程是不进行任何I0操作的，确保了极高的性能。</p></blockquote><p><strong>优点</strong>:</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要不高</li></ol><p><strong>缺点</strong>：</p><ol><li>需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改数据就没有的了</li><li>fork进程的时候，会占用一定的内容空间</li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File），它是Redis的完全持久化策略。</p><p><strong>原理：</strong> 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录) ，只许追加文件但不可以改写文件,，redis启动之初会读取该文件重新构建数据。<br>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no-关闭，yes-开启，默认no</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename <span class="string">&quot;appendonTy.aof&quot;</span> <span class="comment">#持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always #每次修改都会sync,消耗性能 </span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒执行一次sync,可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no #不执行sync,这个时候操作系统自己同步数据,速度最快!</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>每一次修改都同步，文件的完整会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong>：</p><ol><li>相对于数据文件来说, aof远远大于rdb，修复的速度也比rdb慢</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从复制：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><ul><li>前者称为主节点(master/leader)</li><li>后者称为从节点(slavel/follower)</li><li>数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</li></ul><blockquote><p>默认情况下，每台Redis服务器都是主节点<br>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</p></blockquote><p>主从复制的作用主要包括:</p><ul><li>数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点) ，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><blockquote><p>更多：<br><a href="https://xie.infoq.cn/article/6c3500c66c3cdee3d72b88780">redis系列之——高可用（主从、哨兵、集群）</a></p></blockquote><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><p>原理同上方的主从复制，系统的高可用都是通过部署多台机器实现的。<br>redis 为了避免单点故障，也需要部署多台机器。<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071701844.png" alt="主从"></p><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。<br>实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master，即 <del>自动选取老大的模式</del></p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071704740.png" alt="哨兵" style="zoom:50%;" /><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。<br>在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/202112071707386.png" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Redis (Remote Dictionary Server ) 远程字典服务&lt;/strong&gt;，是当下最热门的NoSQL技术之一，也被人们称为结构化数据库。&lt;/p&gt;
&lt;p&gt;Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库,并提供多种语言的APl。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string（字符串）&lt;/li&gt;
&lt;li&gt;list（链表）&lt;/li&gt;
&lt;li&gt;set（集合）&lt;/li&gt;
&lt;li&gt;zset（sorted set 有序集合）&lt;/li&gt;
&lt;li&gt;hash（哈希类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 memcached 一样，为了保证效率，数据都是缓存在&lt;strong&gt;内存&lt;/strong&gt;中。&lt;br&gt;区别的是 redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Redis" scheme="http://blog.sukiu.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://blog.sukiu.top/Language/SQL/"/>
    <id>http://blog.sukiu.top/Language/SQL/</id>
    <published>2021-12-02T12:58:04.000Z</published>
    <updated>2021-12-02T13:52:45.207Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 语句可分为以下几类：</p><ul><li>数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 <code>CREATE</code>，<code>DROP</code>，<code>ALTER</code></li><li>数据查询语言 DQL（Data Query Language）：即查询操作，以 <code>SELECT</code> 关键字为主</li><li>数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 <code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code></li><li>数据控制功能 DCL（Data Control Language）：即权限控制操作，如 <code>GRANT</code>，<code>REVOKE</code>，<code>COMMIT</code>，<code>ROLLBACK</code></li></ul><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxsgh2/">常用 SQL 语句 - LeetCode</a><br><a href="https://juejin.cn/post/6983974232656969742">SQL约束 - 掘金</a></p></blockquote><h2 id="1、键"><a href="#1、键" class="headerlink" title="1、键"></a>1、键</h2><ul><li><strong>超键</strong>：在关系中，能唯一标识元组的属性集称为关系模式的超键。</li></ul><blockquote><p>一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<br>超键包含候选键和主键。</p></blockquote><ul><li><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</li><li><strong>主键</strong>：数据库表中对储存数据对象予以 <strong>唯一和完整标识的数据列或属性的组合</strong>。</li></ul><blockquote><p>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</p></blockquote><ul><li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li></ul><blockquote><p>外键可以有重复的, 可以是空值。</p></blockquote><h2 id="2、约束"><a href="#2、约束" class="headerlink" title="2、约束"></a>2、约束</h2><p>约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p><ul><li><strong>非空约束（NOT NULL）</strong>：保证该字段值一定不为空；</li><li><strong>默认约束（DEFAULT）</strong>：保证字段有默认值；</li><li><strong>主键约束（PRIMARY KEY）</strong>：标志一列或者多列，并保证其值在表内的唯一性；</li><li><strong>外键约束（FOREIGN KEY）</strong>：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；</li><li><strong>唯一约束（UNIQUE）</strong>： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；</li><li><strong>检查约束（CHECK）</strong>：限制一列的可用值范围。</li></ul><h3 id="创建约束"><a href="#创建约束" class="headerlink" title="创建约束"></a>创建约束</h3><ol><li>创建表时，在字段描述处，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key, <span class="comment">-- 添加了主键约束</span></span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建表时，在constraint约束区域，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> persons (</span><br><span class="line">  pid <span class="type">INT</span>,</span><br><span class="line">  lastname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  firstname <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> pk_persons <span class="keyword">PRIMARY</span> KEY (lastname, firstname) <span class="comment">-- 添加主键约束, 多个字段, 我们称为联合主键。</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- pk_persons 是约束名，在数据库中应是惟一的。如果不指定，则系统会自动生成一个约束名。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建表之后，通过修改表结构，声明指定字段为主键：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加联合主键约束</span></span><br><span class="line"><span class="comment">-- 其他约束类似</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">add</span> <span class="keyword">constraint</span> pk_persons <span class="keyword">primary</span> key (lastname, firstname); </span><br></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除主键约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP PRIMARY KEY</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除非空约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 MODIFY 字段名 数据类型[长度]</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons modify lastname <span class="type">varchar</span>(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一约束</span></span><br><span class="line"><span class="comment">-- ALTER TABLE 表名 DROP INDEX 名称</span></span><br><span class="line"><span class="comment">-- 有唯一约束名称, 使用约束名称删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index uni_persons_address; </span><br><span class="line"><span class="comment">-- 没有唯一约束名称, 使用字段名删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons <span class="keyword">drop</span> index address; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、SQL语句"><a href="#3、SQL语句" class="headerlink" title="3、SQL语句"></a>3、SQL语句</h2><p>参考w3cschool即可：</p><blockquote><p><a href="https://www.w3cschool.cn/sql/sql-sentence.html">详尽的SQL语句大全分类整理_w3cschool</a></p></blockquote><p>下面列出一些重点：</p><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。</p><ul><li><p><strong>交叉连接（CROSS JOIN）</strong></p><p>  除了在 <code>FROM</code> 子句中使用 <strong>逗号间隔连接的表</strong> 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 <strong>笛卡尔积</strong>，返回到的数据行数等于第一个表中符合查询条件的数据行数 <strong>乘以</strong> 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 <code>CROSS JOIN</code> 关键字而不是逗号，即以下两个表达式等价：</p><p>  <code>SELECT  *  FROM  A, B</code><br>  <code>SELECT  *  FROM  A  CROSS JOIN  B</code></p></li><li><p><strong>内连接（INNER JOIN）</strong></p><p>  内连接分为三类，分别是 <strong>等值连接</strong>：<code>ON A.id = B.id</code>、<strong>不等值连接</strong>：<code>ON A.id &gt; B.id</code> 和 <strong>自连接</strong>：<code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid</code></p></li><li><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><p>  <strong>左外连接</strong>：以左表为主，先查询出左表，按照 <code>ON</code> 后的关联条件匹配右表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>LEFT JOIN</code></p><p>  <strong>右外连接</strong>：以右表为主，先查询出右表，按照 <code>ON</code> 后的关联条件匹配左表，没有匹配到的用 <code>NULL</code> 填充，可以简写成 <code>RIGHT JOIN</code></p></li><li><p><strong>联合查询（UNION 与 UNION ALL）</strong></p><p>  <code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></p><p>  联合查询就是把多个结果集集中在一起，<code>UNION</code> 前的结果为基准，需要注意的是联合查询的 <strong>列数要相等</strong>，相同的记录行会合并；</p><p>  如果使用 <code>UNION ALL</code>，不会合并重复的记录行，所以效率更高。</p></li><li><p><strong>全连接（FULL JOIN）</strong></p><p>  MySQL 本身不支持全连接，但可以通过联合使用 <code>LEFT JOIN</code>、<code>UNION</code> 和 <code>RIGHT JOIN</code> 来实现。</p><p>  <code>SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id</code></p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。</p><p>子查询是一个 <code>SELECT</code> 语句，它嵌套在另一个 <code>SELECT</code>、<code>SELECT…INTO</code> 语句、<code>INSERT…INTO</code> 语句、<code>DELETE</code> 语句、 <code>UPDATE</code> 语句或嵌套在另一子查询中。</p><p>MySQL 的子查询是多表查询的一个重要组成部分，常常和 <strong>连接查询</strong> 一起使用，是多表查询的基础。</p><p>子查询分为以下四类：</p><ul><li><p><strong>标量子查询</strong></p><p>  查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。</p></li><li><p><strong>列子查询</strong></p><p>  子查询返回的结果集是 N 行一列，该结果通常来自对表的 <strong>某个字段</strong> 查询返回。</p></li><li><p><strong>行子查询</strong></p><p>  子查询返回的结果集是一行 N 列，该结果通常是对表的 <strong>某行数据</strong> 进行查询而返回的结果集</p></li><li><p><strong>表子查询</strong></p><p>  子查询返回的结果集是 N 行 N 列的一个表数据。</p></li></ul><h3 id="char-与-varchar-的区别"><a href="#char-与-varchar-的区别" class="headerlink" title="char 与 varchar 的区别"></a>char 与 varchar 的区别</h3><ul><li>char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；</li><li>使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；</li></ul><h3 id="DROP、DELETE-与-TRUNCATE-的区别"><a href="#DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="DROP、DELETE 与 TRUNCATE 的区别"></a>DROP、DELETE 与 TRUNCATE 的区别</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">DROP</th><th style="text-align:center">DELETE</th><th style="text-align:center">TRUNCATE</th></tr></thead><tbody><tr><td style="text-align:center">SQL 语句类型</td><td style="text-align:center">DDL</td><td style="text-align:center">DML</td><td style="text-align:center">DDL</td></tr><tr><td style="text-align:center">回滚</td><td style="text-align:center">不可回滚</td><td style="text-align:center">可回滚</td><td style="text-align:center">不可回滚</td></tr><tr><td style="text-align:center">删除内容</td><td style="text-align:center">从数据库中 <strong>删除表</strong>，所有的数据行，索引和权限也会被删除</td><td style="text-align:center">表结构还在，删除表的 <strong>全部或者一部分数据行</strong></td><td style="text-align:center">表结构还在，删除表中的 <strong>所有数据</strong></td></tr><tr><td style="text-align:center">删除速度</td><td style="text-align:center">删除速度最快</td><td style="text-align:center">删除速度慢，需要逐行删除</td><td style="text-align:center">删除速度快</td></tr></tbody></table><blockquote><p>在不再需要一张表的时候，采用 <code>DROP</code><br>在想删除部分数据行时候，用 <code>DELETE</code><br>在保留表而删除所有数据的时候用 <code>TRUNCATE</code></p></blockquote><h3 id="UNION-与-UNION-ALL-的区别"><a href="#UNION-与-UNION-ALL-的区别" class="headerlink" title="UNION 与 UNION ALL 的区别"></a>UNION 与 UNION ALL 的区别</h3><ul><li><code>UNION</code> 用于把来自多个 <code>SELECT</code> 语句的结果组合到一个结果集合中，MySQL 会把结果集中 <strong>重复的记录删掉</strong></li><li><code>UNION ALL</code>，MySQL 会把所有的记录返回，且效率高于 <code>UNION</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL 语句可分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言 DDL（Data Ddefinition Language）：即逻辑操作，如 &lt;code&gt;CREATE&lt;/code&gt;，&lt;code&gt;DROP&lt;/code&gt;，&lt;code&gt;ALTER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据查询语言 DQL（Data Query Language）：即查询操作，以 &lt;code&gt;SELECT&lt;/code&gt; 关键字为主&lt;/li&gt;
&lt;li&gt;数据操纵语言 DML（Data Manipulation Language）：即增删改操作，如 &lt;code&gt;INSERT&lt;/code&gt;，&lt;code&gt;UPDATE&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据控制功能 DCL（Data Control Language）：即权限控制操作，如 &lt;code&gt;GRANT&lt;/code&gt;，&lt;code&gt;REVOKE&lt;/code&gt;，&lt;code&gt;COMMIT&lt;/code&gt;，&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
    <category term="SQL" scheme="http://blog.sukiu.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>B Tree</title>
    <link href="http://blog.sukiu.top/Data-structure/B-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/B-Tree/</id>
    <published>2021-11-29T11:07:44.000Z</published>
    <updated>2021-12-02T01:03:01.825Z</updated>
    
    <content type="html"><![CDATA[<p>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。</p><ul><li>特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；</li><li>把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。</li></ul><span id="more"></span><blockquote><p>转载：</p><p><a href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p></blockquote><h2 id="1、B-树-B-tree"><a href="#1、B-树-B-tree" class="headerlink" title="1、B 树(B-tree)"></a>1、B 树(B-tree)</h2><blockquote><p>注意:之前有看到有很多文章把 B 树和 B-tree 理解成了两种不同类别的树，其实这两个是同一种树;</p></blockquote><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+树的数据结构</p><p><strong>规则：</strong></p><ul><li>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且 M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2 则是 2 叉树,M=3 则是 3 叉）</li><li>（3）关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2)</li><li>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子</li></ul><p><strong>例子：</strong></p><p>来理解 B 树（为了理解方便直接用实际字母的大小来排列 C&gt;B&gt;A） <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_b.jpg"/></p><h3 id="2、B-树的查询"><a href="#2、B-树的查询" class="headerlink" title="2、B 树的查询"></a>2、B 树的查询</h3><p>如上图我要从上图中找到 E 字母，查找流程如下</p><ul><li>（1）获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26 个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li><li>（2）拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点；</li><li>（3）拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；</li></ul><h3 id="3、B-树的插入"><a href="#3、B-树的插入" class="headerlink" title="3、B 树的插入"></a>3、B 树的插入</h3><p>定义一个 5 阶树（平衡 5 路查找树;），现在我们要把 3、8、31、11、23、29、50、28 这些数字构建出一个 5 阶树出来;</p><ul><li>（1）节点拆分规则：当前是要组成一个 5 路查找树，那么此时 m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4 就要进行节点拆分）；</li><li>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li></ul><ol><li>先插入 3、8、31、11 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-e1d65c9c6236d4768c89e8e103e12583_b.jpg"/></li><li>再插入 23、29 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-66cdb6187cbc5227fd8c4aabe7282e6c_b.jpg"/></li><li>再插入 50、28 <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-3057eaab2b1764dd51c2a8658791cc98_b.jpg"/></li></ol><h3 id="3、B-树的删除"><a href="#3、B-树的删除" class="headerlink" title="3、B 树的删除"></a>3、B 树的删除</h3><ul><li>（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li><li>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</li><li>（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-a0f981fc847772cb28869927cd4fe66d_b.jpg"/><h2 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a>2、B+树</h2><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p>B+树是 B 树的一个升级版，相对于 B 树来说 B+树更充分的利用了节点的空间，让查询<u>速度</u>更加稳定，其速度完全接近于二分法查找。为什么说 B+树查找的效率要比 B 树更高、更稳定；我们先看看两者的区别</p><ul><li>（1）B+跟B树不同B+树的<b>非叶子</b>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<b>非叶子</b>节点所能保存的关键字大大增加；</li><li>（2）B+树<b>叶子</b>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql的B+树是用第一种方式实现）;</li></ul><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-5f069fd820637db1b877fdd6799a2b67_b.jpg"/><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_b.jpg"/><h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>1、B+<b>树的层级更少</b>：相较于 B 树 B+每个<b>非叶子</b>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<b>树查询速度更稳定</b>：B+所有关键字数据地址都存在<b>叶子</b>节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定;</p><p>3、B+<b>树天然具备排序功能：</b>B+树所有的<b>叶子</b>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。</p><p>4、B+<b>树全节点遍历更快：</b>B+树遍历整棵树只需要遍历所有的<b>叶子</b>节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 <b>B 树</b>相对于<b>B+树</b>的优点是，如果经常访问的数据离根节点很近，而<b>B 树</b>的<b>非叶子</b>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<b>B+树</b>快。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="1、相同思想和策略"><a href="#1、相同思想和策略" class="headerlink" title="1、相同思想和策略"></a>1、相同思想和策略</h3><p>从平衡二叉树、B 树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><h3 id="2、不同的方式的磁盘空间利用"><a href="#2、不同的方式的磁盘空间利用" class="headerlink" title="2、不同的方式的磁盘空间利用"></a>2、不同的方式的磁盘空间利用</h3><p>不同点是他们一个一个在演变的过程中通过 IO 从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；&lt;/li&gt;
&lt;li&gt;把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://blog.sukiu.top/Database/Database-Introduction/"/>
    <id>http://blog.sukiu.top/Database/Database-Introduction/</id>
    <published>2021-11-27T01:58:35.000Z</published>
    <updated>2021-12-02T01:04:07.423Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库（Database）</strong> 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 <strong>数据库管理系统（DataBase- Management System，DBMS）</strong> 创建和操纵的容器。</p><p><strong>DBMS</strong> 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://leetcode-cn.com/leetbook/read/database-handbook/pxhvpv/">数据库知识手册</a></p></blockquote><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>数据库有两种类型，分别是 <strong>关系型数据库</strong> 和 <strong>非关系型数据库</strong>。</p><table><thead><tr><th>数据库类型</th><th>定义</th><th>优点</th><th>缺点</th><th>常见</th></tr></thead><tbody><tr><td>关系型数据库</td><td>建立在关系模型基础上，由多张能互相连接的 <strong>表</strong> 组成的数据库</td><td>    <ol>    <li>使用表结构，格式一致，易于维护；    <li>使用 SQL 语句，可用于复杂查询；    <li>数据存储在磁盘中，安全性高    </ol></td><td>    <ol>    <li>读写性能比较差；    <li>建立在关系模型上，不可避免空间浪费；    <li>固定的表结构，灵活度较低    </ol></td><td>MySQL，Microsoft SQL Server，Oracle，PostgreSQL 等</td></tr><tr><td>非关系型数据库</td><td>非关系型数据库又被称为 NoSQL（Not Only SQL )，通常指数据以 <strong>对象</strong> 的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</td><td>    <ol>    <li>存储数据的格式可以是 key-value 、文档、图片等形式，应用场景更广泛；    <li>可轻松进行海量数据的维护和处理；    <li>具有可扩展、高并发、高稳定性、成本低的优势；    <li>可以实现数据的分布式处理    </ol></td><td>    <ol>        <li>不提供 SQL 支持；    <li>无事务处理，无法保证数据的完整性和安全性；    <li>功能没有关系型数据库完善    </ol></td><td>Neo4j，Redis，MongoDB 等</td></tr></tbody></table><blockquote><p><strong>SQL</strong> 是 <strong>结构化查询语言（Structured Query Language）</strong> 的缩写，是一种数据库查询语言，用于存取数据、查询、更新和管理关系数据库系统。</p><p><strong>MySQL</strong> 是一个 <strong>关系数据库管理系统（RDBMS）</strong>，使用 SQL 执行所有数据库操作。</p></blockquote><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>部分依赖：AB=&gt;C，A=&gt;C，B=&gt;C，那么 C 部分依赖于 AB</li><li>完全依赖：AB=&gt;C，A、B不能单独=&gt;C，那么 C 完全依赖于 AB</li><li>传递依赖：A=&gt;B，B=&gt;C，那么 C 传递依赖于 A</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>数据库范式是设计数据库时，需要遵循的一些规范。各种范式是条件递增的联系，越高的范式数据库冗余越小。</p><p>常用的数据库三大范式为：</p><ul><li><strong>第一范式（1NF）</strong>：每个列（属性）都不可以再拆分，强调的是列的原子性（不可分割）（属性不能有多个值或者不能有重复的属性）。简而言之，第一范式就是无重复的列。<strong>关系模式的基本要求</strong></li><li><strong>第二范式（2NF）</strong>：在第一范式的基础上，一个表必须有一个主键，非主键列 <strong>完全依赖</strong> 于主键，而不能是依赖于主键的一部分。<strong>消除部分依赖</strong></li><li><strong>第三范式（3NF）</strong>：在第二范式的基础上，非主键列只依赖（直接依赖，即不存在传递依赖）于主键，不依赖于其他非主键。<strong>消除传递依赖</strong></li></ul><h2 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h2><p>索引是一种 <strong>数据结构</strong>。数据库索引是 DBMS 中一个 <strong>排序的数据结构</strong>，以 <strong>协助快速查询、更新</strong> 数据库表中数据。</p><p>索引的实现通常使用 <a href="https://blog.sukiu.top/Data-structure/B-Tree/">B 树以及变种 B+ 树</a>。</p><p>以操作系统的观点，索引就相当于目录，是为了方便数据内容查找，本身也占用物理空间。</p><table><tr><td>优点</td><td>缺点</td></tr><tr><td><ul>    <li>通过创建 <strong>唯一性索引 </strong>，可以保证数据库表中每一行数据的唯一性；    <li> 可以加快数据的  <strong>检索速度 </strong>，这也是创建索引的主要原因；    <li>可以加速表和表之间的连接，特别是在实现  <strong>数据的参考完整性 </strong> 方面特别有意义；    <li>通过使用索引，可以在查询的过程中，使用  <strong>优化隐藏器 </strong>，提高系统性能。</ul></td><td><ul>    <li>时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；    <li>空间上，索引需要占  <strong>物理空间 </strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</ul></td></tr></table><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>数据库索引根据结构分类，主要有 <strong>B 树索引</strong>（使用最频繁）、<strong>Hash 索引</strong> 和 <strong>位图索引</strong> 三种。</p><blockquote><p>关于 B 树可以参考：<a href="https://blog.sukiu.top/Data-structure/B-Tree/">B Tree</a></p></blockquote><p><strong>使用 B+ 树的优点：</strong></p><ul><li>由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。</li><li>B+ 树的叶结点由一条链相连，因此当需要进行一次 <strong>全数据遍历</strong> 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 <strong>大于某个关键字或者小于某个关键字的数据</strong> 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。</li></ul><p><strong>Hash 索引和 B+ 树索引的区别：</strong></p><ul><li>Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；</li><li>Hash 索引不支持使用索引进行排序；</li><li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；</li><li>Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；</li><li>Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定，对于所有的查询都是从根结点到叶子结点，且树的高度较低。</li></ul><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引指将 <strong>数据存储</strong> 和 <strong>索引</strong> 放到一起，找到索引也就找到了数据。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/1628676447-LHnlSz-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="聚簇索引" style="zoom: 50%;" /><h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>数据库的 <strong>事务</strong>（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p><blockquote><p>如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。</p></blockquote><p>因此，事务是保持 <strong>逻辑数据一致性</strong> 和 <strong>可恢复性</strong> 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>事务具有 4 个特性，通常简称为 ACID，<strong>关系型数据库</strong> 需要遵循 ACID 规则。</p><ul><li><p>原子性（Atomicity）</p><p>  事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</p><blockquote><p>以银行转账事务为例：</p><p>如果该事务提交了，则这两个账户的数据将会更新；</p><p>如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 <strong>撤销</strong> 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。</p></blockquote></li><li><p>一致性（Consistency）</p><p>  当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。</p><blockquote><p>以银行转账事务事务为例：</p><p>在事务开始之前，所有 <strong>账户余额的总额处于一致状态</strong>。</p><p>在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。</p><p>因此，所有账户余额的总额处于不一致状态。</p><p>但是当事务完成以后，账户余额的总额再次恢复到一致状态。</p></blockquote></li><li><p>隔离性（Isolation）</p><p>  <strong>并发访问数据库</strong> 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</p><blockquote><p>修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。</p></blockquote></li><li><p>持久性（Durability）</p><p>  一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>DBMS 采用 <strong>日志</strong> 来保证事务的 <strong>原子性</strong>、<strong>一致性</strong> 和 <strong>持久性</strong>。</p><blockquote><p>日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></blockquote><p>DBMS 采用 <strong>锁机制</strong> 来实现事务的隔离性。</p><blockquote><p>当多个事务同时更新数据库中相同的数据时，只允许 <strong>持有锁的事务</strong> 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></blockquote><p><strong>相应的原理</strong></p><ul><li>原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li><li>一致性：一般由代码层面来保证</li><li>隔离性：由MVCC来保证</li><li>持久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul><li><p>脏读（Dirty Read）</p><p>  一个事务读取了另一个事务未提交的数据。</p></li><li><p>不可重复读（Non-repeatable Read）</p><p>  就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。</p></li><li><p>幻读（Phantom Read）</p><p>  幻读是指当事务 <strong>不是独立执行时</strong> 发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中 <strong>插入一行新数据</strong>。那么，第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p></li><li><p>丢失更新（Lost Update）</p><p>  两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），即 <strong>并发事务对同一资源的读取深度层次</strong>。</p><p>由低到高依次是 读取未提交（READ-UNCOMMITTED）、读取已提交（READ-COMMITTED）、可重复读（REPEATABLE-READ）、可串行化（SERIALIZABLE）</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交(RU)</td><td>只能保证不读取物理上的损坏</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交(RC)</td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读(RR)</td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化(SR)</td><td>最高级别，事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>从数据库系统的角度，锁模式可分为以下6 种类型：</p><ul><li><p><strong>共享锁（S）</strong>：又叫 <strong>他读锁</strong>。</p><p>  可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。</p></li><li><p><strong>排它锁（X）</strong>：又叫 <strong>独占锁</strong>、<strong>写锁</strong>。</p><p>  对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放，从而防止同时对同一资源进行多重操作。</p></li><li><p><strong>更新锁（U）</strong>：</p><p>  防止出现 <strong>死锁</strong> 的锁模式，两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。</p><p>  资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。</p></li><li><p><strong>意向锁</strong>：</p><p>  表示 SQL Server 需要在 <strong>层次结构中的某些底层资源上</strong> 获取共享锁或排它锁。</p><p>  例如，放置在 <strong>表级</strong> 的 <strong>共享意向锁</strong> 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。</p><p>  意向锁可以提高性能，因为 SQL Server 仅在 <strong>表级</strong> 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。</p><p>  意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。</p></li><li><p><strong>架构锁</strong>：</p><p>  在执行 <strong>依赖于表架构的操作</strong> 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。</p></li><li><p><strong>大容量更新锁（BU）</strong>：</p><p>  向表中大容量复制数据并指定了 <code>TABLOCK</code> 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>在 <strong>读取未提交</strong> 隔离级别下，读取数据不需要加 <strong>共享锁</strong>，这样就不会跟被修改的数据上的 <strong>排他锁</strong> 冲突；</li><li>在 <strong>读取已提交</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在语句执行完以后释放共享锁；</li><li>在 <strong>可重复读</strong> 隔离级别下，读操作需要加 <strong>共享锁</strong>，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</li><li><strong>可串行化</strong> 是限制性最强的隔离级别，因为该级别 <strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><ul><li>如果不同程序并发存取多个表，尽量约定 <strong>以相同的顺序访问表</strong>，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到 <strong>一次锁定所需要的所有资源</strong>，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用 <strong>升级锁定颗粒度</strong>，通过 <strong>表级锁</strong> 定来减少死锁产生的概率。</li></ul><h3 id="乐-悲观锁"><a href="#乐-悲观锁" class="headerlink" title="乐/悲观锁"></a>乐/悲观锁</h3><p>DBMS 中的 <strong>并发控制</strong> 的任务是确保在 <strong>多个事务同时存取数据库中同一数据</strong> 时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 <strong>读多写少</strong> 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库（Database）&lt;/strong&gt; 是保存有组织的数据的容器（通常是一个文件或一组文件），是通过 &lt;strong&gt;数据库管理系统（DataBase- Management System，DBMS）&lt;/strong&gt; 创建和操纵的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DBMS&lt;/strong&gt; 的主要目标是提供一种可以方便、高效地存取数据库信息的途径。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="http://blog.sukiu.top/categories/Database/"/>
    
    
    <category term="Database" scheme="http://blog.sukiu.top/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://blog.sukiu.top/Knowledge/Bit-Operation/"/>
    <id>http://blog.sukiu.top/Knowledge/Bit-Operation/</id>
    <published>2021-11-25T11:12:14.000Z</published>
    <updated>2021-12-02T01:31:31.549Z</updated>
    
    <content type="html"><![CDATA[<p>计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。</p><p>位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。</p><p>上述位运算中，只有取反是一元运算，其余的都是二元运算。</p><span id="more"></span><blockquote><p>参考：<br><a href="https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math/o2zy8j/">位运算符的概念和性质</a></p></blockquote><h2 id="1、与、或、异或和取反"><a href="#1、与、或、异或和取反" class="headerlink" title="1、与、或、异或和取反"></a>1、与、或、异或和取反</h2><ul><li>与运算的符号是 $\And$ ，运算规则是：全 1 为 1，有 0 为 0</li><li>或运算的符号是 $∣$ ，运算规则是：有 1 为 1，全 0 为 0</li><li>异或运算的符号是 $\oplus$（在代码中用 $\wedge$ 表示异或），运算规则是：相同为 0 ，不同为 1</li><li>取反运算的符号是 $\sim$，运算规则是：0 变 1， 1 变 0</li></ul><h2 id="2、移位运算"><a href="#2、移位运算" class="headerlink" title="2、移位运算"></a>2、移位运算</h2><p>移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。</p><ul><li><p>左移运算的符号是 $&lt;&lt;$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。</p></li><li><p>右移运算的符号是 $&gt;&gt;$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：</p><ul><li>算术右移时，高位补最高位；</li><li>逻辑右移时，高位补 0。</li></ul></li></ul><blockquote><p>C++ 中：<br>对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。<br>Java 中：<br>不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。<br>算术右移的符号是 $&gt;&gt;$，逻辑右移的符号是 $&gt;&gt;&gt;$<br>Go 中：<br>只有算数移位</p></blockquote><h2 id="3、位运算与乘除法"><a href="#3、位运算与乘除法" class="headerlink" title="3、位运算与乘除法"></a>3、位运算与乘除法</h2><p>使用移位运算实现乘除法的效率显著<strong>高</strong>于直接乘除法的效率。</p><ul><li><p>左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$</p><ul><li><p>例如，$29 &lt;&lt; 2 = 116$，等价于 $ 29 \times 4  $</p></li><li><p>当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和：</p><p>  例如，$a \times 6$ 等价于 $(a&lt;&lt;2)+(a&lt;&lt;1)$</p></li><li><p>对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。</p></li></ul></li><li><p>算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$</p><ul><li>例如，$50 &gt;&gt; 2  =  12$ ，等价于 $50 / 4$，结果向下取整</li><li>一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是<strong>不等价</strong>的（只对0和正数成立）</li></ul></li></ul><p>同时，位运算也能用来替代取模运算判断奇偶：</p><ul><li>奇数：$整数&amp;1==1$（二进制最低位是1，就是奇数</li><li>偶数：$整数&amp;1==0$（二进制最低位是0，就是偶数</li></ul><h2 id="4、位运算性质"><a href="#4、位运算性质" class="headerlink" title="4、位运算性质"></a>4、位运算性质</h2><p>此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。</p><ul><li>幂等律：$a \And a = a$ ，$a ∣ a=a$ （注意异或不满足幂等律）</li><li>交换律：$a \And b = b \And a$，$a ∣ b = b ∣ a$，$a \oplus b = b \oplus a$</li><li>结合律：$(a \And b) \And c = a \And (b \And c)$，$(a ∣ b) ∣ c = a ∣ (b ∣ c)$，$(a \oplus b) \oplus c = a \oplus (b \oplus c)$</li><li>分配律：$(a \And b) ∣ c = (a ∣ c) \And (b ∣ c)$，$(a ∣ b) \And c = (a \And c) ∣ (b \And c)$，$(a ⊕ b) \And c = (a \And c) ⊕ (b \And c)$</li><li>德·摩根律：$\sim (a \And b) = ( \sim a) ∣ (\sim b)$ ，$\sim(a ∣ b) = (\sim a) \And (\sim b)$</li><li>取反运算性质：$-1 = \sim 0，-a = \sim (a-1)$</li><li>与运算性质：$a \And 0 = 0$，$a \And (-1) = a$，$a \And (\sim a) = 0$</li><li>或运算性质：$a ∣ 0 = a$，$a ∣ (\sim a) = -1$</li><li>异或运算性质：$a \oplus 0 = a$，$a \oplus a = 0$</li><li>其他性质：<ul><li>$a \And (a-1)$ 的结果：将 a 的二进制表示的最后一个 1 变成 0</li><li>$a \And (-a)$（与 $a \And (\sim (a-1))$ 等价）的结果：只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。&lt;/p&gt;
&lt;p&gt;位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。&lt;/p&gt;
&lt;p&gt;上述位运算中，只有取反是一元运算，其余的都是二元运算。&lt;/p&gt;</summary>
    
    
    
    <category term="Knowledge" scheme="http://blog.sukiu.top/categories/Knowledge/"/>
    
    
    <category term="Bit Operation" scheme="http://blog.sukiu.top/tags/Bit-Operation/"/>
    
  </entry>
  
  <entry>
    <title>哈希内部</title>
    <link href="http://blog.sukiu.top/Data-structure/Hash-Insider/"/>
    <id>http://blog.sukiu.top/Data-structure/Hash-Insider/</id>
    <published>2021-11-21T08:35:42.000Z</published>
    <updated>2021-12-02T02:08:51.437Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。</p><span id="more"></span><h2 id="1、散列"><a href="#1、散列" class="headerlink" title="1、散列"></a>1、散列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>散列：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200145426.png" style="zoom: 50%;" ><p><strong>碰撞：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200248821.png" style="zoom:50%;" ><p><strong>散列函数：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200340573.png" style="zoom:50%;" ><p><strong>除余法：</strong></p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200516454.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201009675.png" alt="例子"><br><img src="https://img-blog.csdnimg.cn/20200715200642965.png" alt="例子"></p><center>m=16*2=32<br>p=31<br>散列函数 h(key)=key%p</center> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715200920178.png" style="zoom:50%;" ><h3 id="线性勘察法（开地址法处理碰撞）"><a href="#线性勘察法（开地址法处理碰撞）" class="headerlink" title="线性勘察法（开地址法处理碰撞）"></a>线性勘察法（开地址法处理碰撞）</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201346320.png" style="zoom:50%;" ><p>例子：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201441361.png" alt="例子"> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201549656.png" style="zoom:50%;" ></p><p>已知n个关键码具有相同的散列值d，若采用<strong>线性探查法</strong>解决碰撞，则在散列这n个关键码的过程中，共将要发生<font color="red">n(n-1)/2</font>    次碰撞</p><h3 id="拉链法解决碰撞"><a href="#拉链法解决碰撞" class="headerlink" title="拉链法解决碰撞"></a>拉链法解决碰撞</h3> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715201943887.png" style="zoom:50%;" ><p>例子：</p> <img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202142441.png" style="zoom:50%;" ><p>平均查找长度ASL：</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20200715202641565.png" style="zoom:50%;" ><h2 id="2、常见的三种哈希结构"><a href="#2、常见的三种哈希结构" class="headerlink" title="2、常见的三种哈希结构"></a>2、常见的三种哈希结构</h2><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">哈希表理论基础</a></p></blockquote><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li>std::unordered_set底层实现为哈希表</li><li>std::set 和std::multiset 的底层实现是红黑树</li></ul><blockquote><p>红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p></blockquote><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><ul><li><p>std::unordered_map 底层实现为哈希表</p></li><li><p>std::map 和std::multimap 的底层实现是红黑树</p></li></ul><p>使用时：</p><ul><li>解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的</li><li>如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</li></ul><p>map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><blockquote><p>java里的HashMap ，TreeMap 都是一样的原理。</p></blockquote><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/20210104235134572.png" alt="哈希表" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Hash" scheme="http://blog.sukiu.top/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search 二分查找</title>
    <link href="http://blog.sukiu.top/Algorithm/Binary-Search/"/>
    <id>http://blog.sukiu.top/Algorithm/Binary-Search/</id>
    <published>2021-11-21T08:23:43.000Z</published>
    <updated>2021-12-02T01:03:05.232Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找也称折半查找，它是一种效率较高的查找方法。</p><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>数组为有序数组，数组中无重复元素。</p><p>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。</p><ul><li>到底是 while(left &lt; right) 还是 while(left &lt;= right)？</li><li>到底是right = middle呢，还是要right = middle - 1呢？</li></ul><p>区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><h3 id="1、左闭右闭"><a href="#1、左闭右闭" class="headerlink" title="1、左闭右闭"></a>1、左闭右闭</h3><p>定义 target 是在一个在左闭右闭的区间里，也就是[left, right]</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;  <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        middle := left + (right-left)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &gt; target &#123;</span><br><span class="line">            right = middle - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target &#123;</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、左闭右开"><a href="#2、左闭右开" class="headerlink" title="2、左闭右开"></a>2、左闭右开</h3><p>定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();  <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;    <span class="comment">// left == right在[left, right)是无效的空间</span></span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle;  <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;  <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// nums[middle] == target</span></span><br><span class="line">            <span class="keyword">return</span> middle;      <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找也称折半查找，它是一种效率较高的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Search" scheme="http://blog.sukiu.top/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>Thanox 情景模式</title>
    <link href="http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.sukiu.top/Mixed/Thanox%20%E6%83%85%E6%99%AF%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-17T02:04:33.000Z</published>
    <updated>2021-12-02T01:36:07.243Z</updated>
    
    <content type="html"><![CDATA[<p>情景模式简单理解：</p><blockquote><p>什么时候，干什么。</p></blockquote><ul><li><p>什么时候就是触发条件（condition）</p></li><li><p>干什么就是动作（actions）</p></li></ul><p>本文分享自用的情景模式，不定期更新~</p><span id="more"></span><blockquote><p>官方文档：</p><p><a href="https://tornaco.github.io/Thanox/6-Profile/">https://tornaco.github.io/Thanox/6-Profile/</a></p></blockquote><h2 id="1、GPS-相关"><a href="#1、GPS-相关" class="headerlink" title="1、GPS 相关"></a>1、GPS 相关</h2><h3 id="GPS自动开关"><a href="#GPS自动开关" class="headerlink" title="GPS自动开关"></a>GPS自动开关</h3><figure class="highlight yaml"><figcaption><span>GPS自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$gps.contains(to) &amp;&amp; !hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>GPS自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;GPS自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭GPS，全局变量 gps&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$gps.contains(pkgName) &amp;&amp; hw.isLocationEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信小程序开关GPS"><a href="#微信小程序开关GPS" class="headerlink" title="微信小程序开关GPS"></a>微信小程序开关GPS</h3><figure class="highlight yaml"><figcaption><span>小程序自动打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>小程序自动关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;小程序自动关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; hw.isLocationEnabled() &amp;&amp; from == &quot;com.tencent.mm&quot;&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="微信网页开关GPS"><a href="#微信网页开关GPS" class="headerlink" title="微信网页开关GPS"></a>微信网页开关GPS</h3><figure class="highlight yaml"><figcaption><span>微信网页打开GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页打开GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; !hw.isLocationEnabled() &amp;&amp; componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>微信网页关闭GPS >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;微信网页关闭GPS&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;顾名思义&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;(activityResumed || frontPkgChanged) &amp;&amp; hw.isLocationEnabled() &amp;&amp; !componentNameAsString.contains(&quot;com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableLocation()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭GPS&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2、NFC-相关"><a href="#2、NFC-相关" class="headerlink" title="2、NFC 相关"></a>2、NFC 相关</h2><h3 id="NFC自动开关"><a href="#NFC自动开关" class="headerlink" title="NFC自动开关"></a>NFC自动开关</h3><figure class="highlight yaml"><figcaption><span>NFC自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$nfc.contains(to) &amp;&amp; !hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.enableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>NFC自动关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;NFC自动关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用关闭NFC，全局变量 nfc&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$nfc.contains(pkgName) &amp;&amp; hw.isNfcEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;hw.disableNfc()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭NFC&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3、冻结相关"><a href="#3、冻结相关" class="headerlink" title="3、冻结相关"></a>3、冻结相关</h2><h3 id="蓝牙开关冻结"><a href="#蓝牙开关冻结" class="headerlink" title="蓝牙开关冻结"></a>蓝牙开关冻结</h3><figure class="highlight yaml"><figcaption><span>BT冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙关闭冻结指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOff&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (pkg.isApplicationEnabled(s)) pkg.disableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT冻结&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>BT解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;BT解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;蓝牙打开解冻指定应用，全局变量 btkill&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;btStateChanged &amp;&amp; btStateOn&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;for (String s : globalVarOf$btkill) &#123; if (!pkg.isApplicationEnabled(s)) pkg.enableApplication(s) &#125;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉BT解冻&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="游戏开关冻结"><a href="#游戏开关冻结" class="headerlink" title="游戏开关冻结"></a>游戏开关冻结</h3><blockquote><p>自行修改以下 com.oneplus.gamespace 包名</p></blockquote><figure class="highlight yaml"><figcaption><span>Game冻结 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game冻结&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;关闭游戏冻结游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;taskRemoved &amp;&amp; globalVarOf$game.contains(pkgName) &amp;&amp; pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.disableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉冻结游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><figcaption><span>Game解冻 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Game解冻&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开游戏解冻游戏空间，全局变量 game&quot;</span></span><br><span class="line"><span class="comment"># 一加专属</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&#x27;frontPkgChanged &amp;&amp; globalVarOf$game.contains(to) &amp;&amp; !pkg.isApplicationEnabled(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;pkg.enableApplication(&quot;com.oneplus.gamespace&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉解冻游戏空间&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4、应用相关"><a href="#4、应用相关" class="headerlink" title="4、应用相关"></a>4、应用相关</h2><h3 id="APP保活"><a href="#APP保活" class="headerlink" title="APP保活"></a>APP保活</h3><blockquote><p>推荐用乖巧模式的规则来 KEEP 想保持的服务</p><p>以下貌似没用，可以开启电池不优化试试</p></blockquote><figure class="highlight yaml"><figcaption><span>APP保活 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP保活&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;应用停止运行时重启应用进程，全局变量 apps&quot;</span></span><br><span class="line"><span class="comment">#  APP 后台不优化</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$apps.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.launchProcessForPackage(pkgName)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉保活app&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="APP休眠"><a href="#APP休眠" class="headerlink" title="APP休眠"></a>APP休眠</h3><figure class="highlight yaml"><figcaption><span>APP休眠 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;APP休眠&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;后台应用休眠，全局变量 idle&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$idle.contains(from)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;activity.setInactive(from)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、Data-相关"><a href="#5、Data-相关" class="headerlink" title="5、Data 相关"></a>5、Data 相关</h2><h3 id="Data自动开启"><a href="#Data自动开启" class="headerlink" title="Data自动开启"></a>Data自动开启</h3><figure class="highlight yaml"><figcaption><span>Data自动开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Data自动开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用打开移动数据，全局变量 data&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$data.contains(to) &amp;&amp; !hw.isWifiEnabled() &amp;&amp; !data.isDataEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;data.setDataEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉打开移动数据&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="6、亮度相关"><a href="#6、亮度相关" class="headerlink" title="6、亮度相关"></a>6、亮度相关</h2><h3 id="自动亮度关闭"><a href="#自动亮度关闭" class="headerlink" title="自动亮度关闭"></a>自动亮度关闭</h3><figure class="highlight yaml"><figcaption><span>自动亮度关闭 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度关闭&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用关闭自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bright.contains(to) &amp;&amp; power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(false)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉关闭自动亮度&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="自动亮度开启"><a href="#自动亮度开启" class="headerlink" title="自动亮度开启"></a>自动亮度开启</h3><figure class="highlight yaml"><figcaption><span>自动亮度开启 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;自动亮度开启&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用打开自动亮度，全局变量 bright&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bright.contains(pkgName) &amp;&amp; !power.isAutoBrightnessEnabled()&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setAutoBrightnessEnabled(true)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;power.setBrightness(power.getBrightness())&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉开启自动亮度&quot;)&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、状态栏图标相关"><a href="#7、状态栏图标相关" class="headerlink" title="7、状态栏图标相关"></a>7、状态栏图标相关</h2><blockquote><p>隐藏状态栏图标的 shell 命令：</p><p>settings put secure icon_blacklist 「args」</p><p>自行修改 「args」 参数</p></blockquote><h3 id="状态栏图标隐藏"><a href="#状态栏图标隐藏" class="headerlink" title="状态栏图标隐藏"></a>状态栏图标隐藏</h3><figure class="highlight yaml"><figcaption><span>状态栏图标隐藏 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标隐藏&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;打开应用隐藏状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;frontPkgChanged &amp;&amp; globalVarOf$bar.contains(to)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,clock,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉隐藏状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="状态栏图标显示"><a href="#状态栏图标显示" class="headerlink" title="状态栏图标显示"></a>状态栏图标显示</h3><figure class="highlight yaml"><figcaption><span>状态栏图标显示 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;状态栏图标显示&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;停止应用显示状态栏图标,全局变量 bar&quot;</span></span><br><span class="line"><span class="attr">priority:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">condition:</span> <span class="string">&quot;pkgKilled &amp;&amp; globalVarOf$bar.contains(pkgName)&quot;</span></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;sh.exe(&quot;settings put secure icon_blacklist volte,vowifi,rotate,zen,battery,vpn&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ui.showShortToast(&quot;🎉显示状态栏图标&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;情景模式简单理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候，干什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么时候就是触发条件（condition）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;干什么就是动作（actions）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文分享自用的情景模式，不定期更新~&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="Thanox" scheme="http://blog.sukiu.top/tags/Thanox/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://blog.sukiu.top/Language/Go-Module/"/>
    <id>http://blog.sukiu.top/Language/Go-Module/</id>
    <published>2021-11-17T00:54:42.000Z</published>
    <updated>2021-12-02T01:04:13.524Z</updated>
    
    <content type="html"><![CDATA[<p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。</p><p>一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://time.geekbang.org/column/article/429941">06｜构建模式：Go是怎么解决包依赖管理问题的？ (geekbang.org)</a></p></blockquote><h2 id="1、Go-Module-构建模式"><a href="#1、Go-Module-构建模式" class="headerlink" title="1、Go Module 构建模式"></a>1、Go Module 构建模式</h2><h3 id="语义导入版本机制"><a href="#语义导入版本机制" class="headerlink" title="语义导入版本机制"></a>语义导入版本机制</h3><p>在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/468323b3294cce2ea7f4c1da3699c5a2.png" alt="语义版本号规范" style="zoom: 50%;" /><p>按照语义版本规范，</p><ul><li><strong>主版本号不同</strong>的两个版本是相互<strong>不兼容</strong>的；</li><li>在主版本号相同的情况下，次版本号大都是<strong>向后兼容</strong>次版本号小的版本；</li><li>补丁版本号也不影响兼容性。</li></ul><p>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本</span></span><br><span class="line"><span class="comment">// 假如这是 v1.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus&quot;</span> </span><br><span class="line"><span class="comment">// 如果要导入 v2.x.x 版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line"><span class="comment">// 甚至可以同时依赖一个包的两个不兼容版本</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">    logv2 <span class="string">&quot;github.com/sirupsen/logrus/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径</p></blockquote><h3 id="最小版本选择原则"><a href="#最小版本选择原则" class="headerlink" title="最小版本选择原则"></a>最小版本选择原则</h3><p>依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/49eb7aa0458d8ec6131d9e5661155f1b.jpeg" alt="复杂情况" style="zoom: 33%;" /><p>当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 <code>v1.7.0</code>。</p><p>不过，Go 会在该项目依赖项的所有版本中，选出<strong>符合项目整体要求</strong>的“最小版本”</p><p>这个例子中，<code>C v1.3.0</code> 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 <code>C v1.3.0</code>，而不是最新最大的 <code>C v1.7.0</code>。</p><h2 id="2、Go-module-版本管理"><a href="#2、Go-module-版本管理" class="headerlink" title="2、Go module 版本管理"></a>2、Go module 版本管理</h2><h3 id="（1）Go-Module-创建"><a href="#（1）Go-Module-创建" class="headerlink" title="（1）Go Module 创建"></a>（1）Go Module 创建</h3><p>创建一个 Go Module，通常有如下几个步骤：</p><ol><li><p>通过 <code>go mod init</code> 创建 go.mod 文件，将当前项目变为一个 Go Module；</p></li><li><p>通过 <code>go mod tidy</code> 命令自动更新当前 module 的依赖信息；</p></li><li><p>执行 <code>go build</code>，执行新 module 的构建。</p></li></ol><h3 id="（2）为当前-module-添加一个依赖"><a href="#（2）为当前-module-添加一个依赖" class="headerlink" title="（2）为当前 module 添加一个依赖"></a>（2）为当前 module 添加一个依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/google/uuid</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动添加</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go mod tidy</span></span><br></pre></td></tr></table></figure><h3 id="（3）升级-降级依赖的版本"><a href="#（3）升级-降级依赖的版本" class="headerlink" title="（3）升级 / 降级依赖的版本"></a>（3）升级 / 降级依赖的版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选定指定版本即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">go get github.com/sirupsen/logrus@v1.7.0</span></span><br></pre></td></tr></table></figure><h3 id="（4）移除一个依赖"><a href="#（4）移除一个依赖" class="headerlink" title="（4）移除一个依赖"></a>（4）移除一个依赖</h3><p>仅从源码中删除对依赖项的导入语句还不够，还得用 <code>go mod tidy</code> 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。</p><p><code>go mod tidy</code> 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。</p><h3 id="（5）vendor"><a href="#（5）vendor" class="headerlink" title="（5）vendor"></a>（5）vendor</h3><p>vendor 机制可以对 vendor 目录下缓存的依赖包进行自动管理。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非 go build 传入 <code>-mod=mod</code> 的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">go mod vendor</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tree -LF 2 vendor</span></span><br><span class="line">vendor</span><br><span class="line">├── github.com/</span><br><span class="line">│   ├── google/</span><br><span class="line">│   ├── magefile/</span><br><span class="line">│   └── sirupsen/</span><br><span class="line">├── golang.org/</span><br><span class="line">│   └── x/</span><br><span class="line">└── modules.txt</span><br></pre></td></tr></table></figure><h3 id="3、空导入"><a href="#3、空导入" class="headerlink" title="3、空导入"></a>3、空导入</h3><p>像下面代码这样的包导入方式被称为“空导入”：<code>import _ &quot;foo&quot;</code></p><p>空导入也是导入，意味着我们将依赖foo这个路径下的包。</p><p>由于是空导入，我们并没有显式使用这个包中的任何语法元素。</p><p>通常实践中空导入意味着期望依赖包的init函数得到执行，这个init函数中有我们需要的逻辑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。&lt;/p&gt;
&lt;p&gt;在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。&lt;/p&gt;
&lt;p&gt;一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。&lt;/p&gt;
&lt;p&gt;go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="http://blog.sukiu.top/categories/Language/"/>
    
    
    <category term="Go" scheme="http://blog.sukiu.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>主流开源协议</title>
    <link href="http://blog.sukiu.top/Mixed/Open-Source-License/"/>
    <id>http://blog.sukiu.top/Mixed/Open-Source-License/</id>
    <published>2021-11-12T10:49:27.000Z</published>
    <updated>2021-12-02T01:05:05.675Z</updated>
    
    <content type="html"><![CDATA[<p>常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：</p><ul><li>宽松自由软件许可协议 <em>Permissive free software licence</em></li><li>著佐权许可证 <em>copyleft license</em></li></ul><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/19568896">主流开源协议之间有何异同？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p></blockquote><h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><ul><li><p>Permissive free software licence ：</p><p>  一种对软件的使用、修改、传播等方式采用最低限制的自由软件许可协议条款类型。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。</p></li><li><p>Copyleft License ：</p><p>  在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件不得用于商业目的，且不得闭源，那么后续的衍生子软件也必须得遵循该条款。</p></li></ul><p>两者最大的差别在于：在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。</p><p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。</p><h2 id="2、常见开源许可证"><a href="#2、常见开源许可证" class="headerlink" title="2、常见开源许可证"></a>2、常见开源许可证</h2><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free_software_licenses.png" alt="常见许可证" style="zoom:50%;" /><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。应用案例有：JQuery、Rails 等。</p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p><em>Berkeley Software Distribution license</em></p><p>BSD 许可证与 MIT 差不多。</p><p>事实上，BSD 许可证被认为是 copycenter（中间著作权），介乎标准的 copyright 与 GPL 的 copyleft 之间。</p><p>可以说，GPL 强迫后续版本必须一样是自由软件，BSD 的后续版本可以选择要继续是 BSD 或其他自由软件条款或闭源软件等等。</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 2 的效力与 MIT 近似，区别主要在于前者额外提供了一份简易的专利许可授权，明确禁止商标使用权以及要求明确指明所有修改过的文件（state changes）。</p><p>Apache 许可证要求被授权者保留著作权和放弃权利的声明，但它不是一个反著作权的许可证。此许可证最新版本为 “版本2”，于 2004 年 1 月发布。</p><p>Apache 许可证是宽松的，因为它不会强制派生和修改作品使用相同的许可证进行发布。</p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。</p><p>由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用此作为类库和二次开发的基础。</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/7149baf878e23293b9bd57df076b6e41_r.jpg" alt="简明对比"></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>更宽松的GPL协议。</p><p>与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。</p><p>调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见的开源许可证主要有 Apache、MIT、BSD、GPL、LGPL、MPL、SSPL 等，可以大致分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宽松自由软件许可协议 &lt;em&gt;Permissive free software licence&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;著佐权许可证 &lt;em&gt;copyleft license&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。&lt;/p&gt;</summary>
    
    
    
    <category term="Mixed" scheme="http://blog.sukiu.top/categories/Mixed/"/>
    
    
    <category term="License" scheme="http://blog.sukiu.top/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree 二叉搜索树</title>
    <link href="http://blog.sukiu.top/Data-structure/Binary-Search-Tree/"/>
    <id>http://blog.sukiu.top/Data-structure/Binary-Search-Tree/</id>
    <published>2021-11-12T02:42:46.000Z</published>
    <updated>2021-12-02T01:03:10.264Z</updated>
    
    <content type="html"><![CDATA[<p>简称 BST，也称二叉排序树或二叉查找树。</p><p>特点：</p><ul><li>任一结点 &gt; 其左子树的所有结点，<br>  并且&lt; 其右子树的所有结点；</li><li>结点的左、右子树，也是二叉排序树；</li><li>每个结点键值唯一（不能重复）</li></ul><p>重要性质：</p><ul><li><strong>中序遍历二叉排序树得到递增序列</strong></li></ul><p>所以判断 1 棵二叉树是否是二叉排序树？<br>只要中序遍历，得到递增序列才是。</p><span id="more"></span><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li>若当前树为空，则新结点为根</li><li>若当前树不空，<br>  将待插入 x 与根比较；<ul><li>若 x 等于根，不用插入</li><li>若 x 大于根，则去右子树(找位置)；</li><li>若 x 小于根，则去左子树(找位置)；</li></ul></li></ul><p>可以总结为：</p><p>插入之前，先查找：</p><ul><li>若找到，不用插入</li><li>若找不到，则在到达的空位置处，放入 x；</li></ul><p>所以最新插入的结点，一定是叶子；</p><img src="https://img-blog.csdnimg.cn/20200512170217478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" width="50%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>从根结点开始，如果树为空，则返回 NULL</p></li><li><p>如果非空，从根结点开始，比较待检索的键值</p><ul><li><p>若相等，则成功；</p></li><li><p>若小于根，<br>  则去根的左子树；</p></li><li><p>若大于根，<br>  则去根的右子树，</p></li></ul></li></ul><figure class="highlight go"><figcaption><span>迭代</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>考虑三种情况：</p><ul><li>① 要删除叶子结点<br>  直接删除，并将父结点指针置为 NULL</li></ul><img src="https://img-blog.csdnimg.cn/20200512170832794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="40%"><ul><li>② 删除只有 1 个孩子的结点<br>  将父结点指针指向要删除结点的孩子结点</li></ul><img src="https://img-blog.csdnimg.cn/20200512170956215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><ul><li>③ 删除有左右子树的结点<br>  用另一个结点替代删除的结点：<ul><li>右子树的最小元素 或者 左子树的最大元素</li></ul></li></ul><img src="https://img-blog.csdnimg.cn/20200512171205732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70" width="45%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">        root.Left = deleteNode(root.Left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">        root.Right = deleteNode(root.Right, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 1 : 以下两个 if 已经处理</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 左</span></span><br><span class="line">        <span class="keyword">return</span> root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 情况 2 右</span></span><br><span class="line">        <span class="keyword">return</span> root.Left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 3 ： 使用右子树最小元素</span></span><br><span class="line">    minNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> minNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        minNode = minNode.Left</span><br><span class="line">    &#125;</span><br><span class="line">    root.Val = minNode.Val</span><br><span class="line">    root.Right = deleteNode(root.Right, minNode.Val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平均检索长度-ASL"><a href="#平均检索长度-ASL" class="headerlink" title="平均检索长度 ASL"></a>平均检索长度 ASL</h2><p>比较次数：不大于树的深度</p><p>最坏平均查找长度 ASL：(n+1)/2</p><p>最好 ASL：$log2(n)$ (参考二分查找)</p><p><strong>所有操作的复杂度都是 $O(logn)$</strong></p><img src="https://img-blog.csdnimg.cn/2020051217150614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQwMDA5,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" >]]></content>
    
    
    <summary type="html">&lt;p&gt;简称 BST，也称二叉排序树或二叉查找树。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任一结点 &amp;gt; 其左子树的所有结点，&lt;br&gt;  并且&amp;lt; 其右子树的所有结点；&lt;/li&gt;
&lt;li&gt;结点的左、右子树，也是二叉排序树；&lt;/li&gt;
&lt;li&gt;每个结点键值唯一（不能重复）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中序遍历二叉排序树得到递增序列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以判断 1 棵二叉树是否是二叉排序树？&lt;br&gt;只要中序遍历，得到递增序列才是。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——系统管理</title>
    <link href="http://blog.sukiu.top/Linux/Linux-System-Management/"/>
    <id>http://blog.sukiu.top/Linux/Linux-System-Management/</id>
    <published>2021-11-07T14:50:41.000Z</published>
    <updated>2021-12-03T08:39:20.110Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中常用的系统工作命令以及系统状态检测命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、常用系统工作命令"><a href="#1、常用系统工作命令" class="headerlink" title="1、常用系统工作命令"></a>1、常用系统工作命令</h2><h3 id="echo-：在终端输出字符串或变量提取后的值"><a href="#echo-：在终端输出字符串或变量提取后的值" class="headerlink" title="echo ：在终端输出字符串或变量提取后的值"></a>echo ：在终端输出字符串或变量提取后的值</h3><p>命令描述：echo命令用于在终端输出字符串或变量提取后的值。</p><p>命令格式：<code>echo [字符串 | $变量]</code></p><p>命令用法示例：</p><p><strong>显示普通字符串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p><strong>显示变量</strong><br>首先在shell环境中定义一个临时变量name，<br>使用echo命令将变量name的值显示到终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> name=<span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure><p><strong>显示结果定向至文件</strong><br>以下命令会将文本This is a test text.输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中&gt;符号表示输出重定向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test text.&quot;</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用&gt;&gt;输出追加重定向符号。</p><p><strong>显示命令执行结果</strong><br>以下命令将会在终端显示当前的工作路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure><p>注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。<br>使用<code>$(command)</code>形式可以达到相同效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h3 id="date-：显示和设置系统的时间和日期"><a href="#date-：显示和设置系统的时间和日期" class="headerlink" title="date ：显示和设置系统的时间和日期"></a>date ：显示和设置系统的时间和日期</h3><p>命令描述：date命令用于显示和设置系统的时间和日期。</p><p>命令格式：<code>date [选项] [+格式]</code></p><p>其中，时间格式的部分控制字符解释如下：</p><table class=""><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.25da70089Mos0m">字符</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.25da70089Mos0m">%a</td><td>当地时间的星期名缩写（例如： 日，代表星期日）</td></tr><tr><td>%A</td><td>当地时间的星期名全称 （例如：星期日）</td></tr><tr><td>%b</td><td>当地时间的月名缩写 （例如：一，代表一月）</td></tr><tr><td>%B</td><td>当地时间的月名全称 （例如：一月）</td></tr><tr><td>%c</td><td>当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）</td></tr><tr><td>%C</td><td>世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）</td></tr><tr><td>%d</td><td>按月计的日期（例如：01）</td></tr><tr><td>%D</td><td>按月计的日期；等于%m/%d/%y</td></tr><tr><td>%F</td><td>完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td>%j</td><td>按年计的日期（001-366）</td></tr><tr><td>%p</td><td>按年计的日期（001-366）</td></tr><tr><td>%r</td><td>当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）</td></tr><tr><td>%R</td><td>24 小时时间的时和分，等价于 %H:%M</td></tr><tr><td>%s</td><td>自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</td></tr><tr><td>%T</td><td>时间，等于%H:%M:%S</td></tr><tr><td>%U</td><td>一年中的第几周，以周日为每星期第一天（00-53）</td></tr><tr><td>%x</td><td>当地时间下的日期描述 （例如：12/31/99）</td></tr><tr><td>%X</td><td>当地时间下的时间描述 （例如：23:13:48）</td></tr><tr><td>%w</td><td>一星期中的第几日（0-6），0 代表周一</td></tr><tr><td>%W</td><td>一年中的第几周，以周一为每星期第一天（00-53）</td></tr></tbody></table><p>命令用法示例：</p><p><strong>按照默认格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p><strong>按照指定格式查看当前系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><p><strong>查看今天是当年中的第几天</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date <span class="string">&quot;+%j&quot;</span></span><br></pre></td></tr></table></figure><p><strong>将系统的当前时间设置为2020年02月20日20点20分20秒</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="string">&quot;20200220 20:20:20&quot;</span></span><br></pre></td></tr></table></figure><p><strong>校正系统时间，与网络时间同步</strong><br>a. 安装ntp校时工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure><p>b. 用ntpdate从时间服务器更新时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><h3 id="wget-：在终端中下载文件"><a href="#wget-：在终端中下载文件" class="headerlink" title="wget ：在终端中下载文件"></a>wget ：在终端中下载文件</h3><p>命令描述：在终端中下载文件。</p><p>命令格式：<code>wget [参数] 下载地址</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i24.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大重试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><p>命令使用示例：</p><p><strong>下载一张图片到路径/root/static/img/中，-p参数默认值为当前路径，如果指定路径不存在会自动创建。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /root/static/img/ http://img.alicdn.com/tfs/TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png</span><br></pre></td></tr></table></figure><h3 id="ps-：查看系统中的进程状态"><a href="#ps-：查看系统中的进程状态" class="headerlink" title="ps ：查看系统中的进程状态"></a>ps ：查看系统中的进程状态</h3><p>命令描述：ps命令用于查看系统中的进程状态。</p><p>命令格式：<code>ps [参数]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i27.25da70089Mos0m">参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i26.25da70089Mos0m">-u</td><td>以用户为主的格式来显示程序状况</td></tr><tr><td>-x</td><td>显示没有控制终端的进程，同时显示各个命令的具体路径</td></tr><tr><td>-e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示当前所有的进程</td></tr><tr><td>-t</td><td>指定终端机编号，并列出属于该终端机的程序的状况</td></tr></tbody></table><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure><h3 id="top-：动态地监视进程活动与系统负载等信息"><a href="#top-：动态地监视进程活动与系统负载等信息" class="headerlink" title="top ：动态地监视进程活动与系统负载等信息"></a>top ：动态地监视进程活动与系统负载等信息</h3><p>命令描述：top命令动态地监视进程活动与系统负载等信息。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/top.png" alt="top"><br>命令输出参数解释：</p><p>以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。</p><ul><li>统计信息区<ul><li>第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li><li>第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li><li>第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li><li>第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</li><li>第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。</li></ul></li><li>进程信息区<pre><code>&lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;colgroup&gt;&lt;col&gt;&lt;col&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th data-spm-anchor-id=&quot;a2c6h.13858378.0.i35.25da70089Mos0m&quot;&gt;列名&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PID&lt;/td&gt;&lt;td&gt;进程ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USER&lt;/td&gt;&lt;td&gt;进程所有者的用户名&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PR&lt;/td&gt;&lt;td&gt;进程优先级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NI&lt;/td&gt;&lt;td&gt;nice值。负值表示高优先级，正值表示低优先级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VIRT&lt;/td&gt;&lt;td&gt;进程使用的虚拟内存总量，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RES&lt;/td&gt;&lt;td&gt;进程使用的、未被换出的物理内存大小，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SHR&lt;/td&gt;&lt;td data-spm-anchor-id=&quot;a2c6h.13858378.0.i34.25da70089Mos0m&quot;&gt;共享内存大小，单位kb&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;进程状态&lt;ul&gt;&lt;li&gt;D：不可中断的睡眠状态&lt;/li&gt;&lt;li&gt;R：正在运行&lt;/li&gt;&lt;li&gt;S：睡眠&lt;/li&gt;&lt;li&gt;T：停止&lt;/li&gt;&lt;li&gt;Z：僵尸进程&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%CPU&lt;/td&gt;&lt;td&gt;上次更新到现在的CPU时间占用百分比&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;%MEM&lt;/td&gt;&lt;td&gt;进程使用的物理内存百分比&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME+&lt;/td&gt;&lt;td&gt;进程使用的CPU时间总计，单位1/100秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;COMMAND&lt;/td&gt;&lt;td&gt;命令名&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; 按 q 键退出监控页面。</code></pre></li></ul><h3 id="pidof-：查询指定服务进程的PID值"><a href="#pidof-：查询指定服务进程的PID值" class="headerlink" title="pidof ：查询指定服务进程的PID值"></a>pidof ：查询指定服务进程的PID值</h3><p>命令描述：pidof命令用于查询指定服务进程的PID值。</p><p>命令格式：<code>pidof [服务名称]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>仅返回一个进程号</td></tr><tr><td>-c</td><td>只显示运行在root目录下的进程，这个选项只对root用户有效</td></tr><tr><td>-o</td><td>忽略指定进程号的进程</td></tr><tr><td>-x</td><td>显示由脚本开启的进程</td></tr></tbody></table><p>命令使用示例：</p><p><strong>查询出crond服务下的所有进程ID。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof crond</span><br></pre></td></tr></table></figure><h3 id="kill-：终止指定PID的服务进程"><a href="#kill-：终止指定PID的服务进程" class="headerlink" title="kill ：终止指定PID的服务进程"></a>kill ：终止指定PID的服务进程</h3><p>命令描述：kill命令用于终止指定PID的服务进程。</p><p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。</p><p>命令格式：<code>kill [参数] [进程PID]</code></p><p>命令使用示例：</p><p><strong>删除pid为1247的进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 1247</span><br></pre></td></tr></table></figure><h3 id="killall-：终止指定名称的服务对应的全部进程"><a href="#killall-：终止指定名称的服务对应的全部进程" class="headerlink" title="killall ：终止指定名称的服务对应的全部进程"></a>killall ：终止指定名称的服务对应的全部进程</h3><p>命令描述：killall命令用于终止指定名称的服务对应的全部进程。</p><p>命令格式：<code>killall [进程名称]</code></p><p>命令使用示例：</p><p><strong>删除crond服务下的所有进程。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall crond</span><br></pre></td></tr></table></figure><h3 id="reboot-：重启系统"><a href="#reboot-：重启系统" class="headerlink" title="reboot ：重启系统"></a>reboot ：重启系统</h3><p>命令描述：reboot命令用来重启系统。</p><p>命令格式：<code>reboot [-n] [-w] [-d] [-f] [-i]</code></p><p>命令参数说明：</p><ul><li>-n：保存数据后再重新启动系统。</li><li>-w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。</li><li>-d：重新启动时不把数据写入记录文件/var/tmp/wtmp。</li><li>-f：强制重新开机，不调用shutdown指令的功能。</li><li>-i：关闭网络设置之后再重新启动系统。</li></ul><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="poweroff-：关闭系统"><a href="#poweroff-：关闭系统" class="headerlink" title="poweroff ：关闭系统"></a>poweroff ：关闭系统</h3><p>命令描述：poweroff命令用来关闭系统。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><h2 id="2、系统状态检测命令"><a href="#2、系统状态检测命令" class="headerlink" title="2、系统状态检测命令"></a>2、系统状态检测命令</h2><h3 id="ifconfig-：获取网卡配置与网络状态等信息"><a href="#ifconfig-：获取网卡配置与网络状态等信息" class="headerlink" title="ifconfig ：获取网卡配置与网络状态等信息"></a>ifconfig ：获取网卡配置与网络状态等信息</h3><p>命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。</p><p>命令示例：</p><p><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/ifconfig.png" alt="ifconfig"><br>命令输出说明：</p><ul><li>第一部分的第一行显示网卡状态信息。<ul><li>eth0表示第一块网卡。</li><li>UP代表网卡开启状态。</li><li>RUNNING代表网卡的网线被接上。</li><li>MULTICAST表示支持组播。</li></ul></li><li>第二行显示网卡的网络信息。<ul><li>inet（IP地址）：172.16.132.195。</li><li>broadcast（广播地址）：172.16.143.255。</li><li>netmask（掩码地址）：255.255.240.0。</li><li>RX表示接收数据包的情况，TX表示发送数据包的情况。</li><li>lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。</li></ul></li></ul><h3 id="uname-：查看系统内核与系统版本等信息"><a href="#uname-：查看系统内核与系统版本等信息" class="headerlink" title="uname ：查看系统内核与系统版本等信息"></a>uname ：查看系统内核与系统版本等信息</h3><p>命令描述：uname命令用于查看系统内核与系统版本等信息。</p><p>命令语法：<code>uname [-amnrsv][--help][--version]</code></p><p>命令使用示例：</p><p><strong>显示系统信息。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>显示当前系统的硬件架构。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -i</span><br></pre></td></tr></table></figure><p><strong>显示操作系统发行编号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><strong>显示操作系统名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -s</span><br></pre></td></tr></table></figure><p><strong>显示主机名称。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -n</span><br></pre></td></tr></table></figure><h3 id="uptime-：查看系统的负载信息"><a href="#uptime-：查看系统的负载信息" class="headerlink" title="uptime ：查看系统的负载信息"></a>uptime ：查看系统的负载信息</h3><p>命令描述：uptime 用于查看系统的负载信息。</p><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/uptime.png" alt="uptime"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i55.25da70089Mos0m">负载信息</th><th data-spm-anchor-id="a2c6h.13858378.0.i54.25da70089Mos0m">命令输出值</th></tr></thead><tbody><tr><td>当前服务器时间</td><td>14:20:27</td></tr><tr><td>当前服务器运行时长</td><td>2 min</td></tr><tr><td>当前用户数</td><td>2 users</td></tr><tr><td>当前负载情况</td><td><code>load average: 0.03, 0.04, 0.02</code>（分别取1min，5min，15min的均值）</td></tr></tbody></table><h3 id="free-：显示当前系统中内存的使用量信息"><a href="#free-：显示当前系统中内存的使用量信息" class="headerlink" title="free ：显示当前系统中内存的使用量信息"></a>free ：显示当前系统中内存的使用量信息</h3><p>命令描述：free用于显示当前系统中内存的使用量信息。</p><p>命令语法：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i59.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以Byte为单位显示内存使用情况</td></tr><tr><td>-k</td><td>以KB为单位显示内存使用情况</td></tr><tr><td>-m</td><td>以MB为单位显示内存使用情况</td></tr><tr><td>-h</td><td>以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</td></tr></tbody></table><p>命令使用示例：<br><img src="https://picgo-1303870432.cos.ap-shanghai.myqcloud.com/img/free.png" alt="free"><br>命令输出说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i64.25da70089Mos0m">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i63.25da70089Mos0m">total</td><td>物理内存总数</td></tr><tr><td>used</td><td>已经使用的内存数</td></tr><tr><td>free</td><td>空间的内存数</td></tr><tr><td>share</td><td>多个进程共享的内存总额</td></tr><tr><td>buff/cache</td><td>应用使用内存数</td></tr><tr><td>available</td><td>可用的内存数</td></tr><tr><td>Swap</td><td>虚拟内存（阿里云ECS服务器默认不开启虚拟内存）</td></tr></tbody></table><h3 id="who-：显示关于当前在本地系统上的所有用户的信息"><a href="#who-：显示关于当前在本地系统上的所有用户的信息" class="headerlink" title="who ：显示关于当前在本地系统上的所有用户的信息"></a>who ：显示关于当前在本地系统上的所有用户的信息</h3><p>命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。</p><p>命令使用示例：</p><p><strong>显示当前登录系统的用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure><p><strong>显示用户登录来源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -l -H</span><br></pre></td></tr></table></figure><p><strong>只显示当前用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -m -H</span><br></pre></td></tr></table></figure><p><strong>精简模式显示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -q</span><br></pre></td></tr></table></figure><h3 id="last-：显示用户最近登录信息"><a href="#last-：显示用户最近登录信息" class="headerlink" title="last ：显示用户最近登录信息"></a>last ：显示用户最近登录信息</h3><p>命令描述： last 命令用于显示用户最近登录信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><h3 id="history-：显示历史执行过的命令"><a href="#history-：显示历史执行过的命令" class="headerlink" title="history ：显示历史执行过的命令"></a>history ：显示历史执行过的命令</h3><p>命令描述：history命令用于显示历史执行过的命令。</p><p>bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。</p><p>命令使用示例：</p><p><strong>显示最新10条执行过的命令。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> 10</span><br></pre></td></tr></table></figure><p><strong>清除历史记录。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux中常用的系统工作命令以及系统状态检测命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文本处理</title>
    <link href="http://blog.sukiu.top/Linux/Linux-Text-Processing/"/>
    <id>http://blog.sukiu.top/Linux/Linux-Text-Processing/</id>
    <published>2021-11-07T14:38:28.000Z</published>
    <updated>2021-12-03T08:40:46.684Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文本编辑工具Vim"><a href="#1、文本编辑工具Vim" class="headerlink" title="1、文本编辑工具Vim"></a>1、文本编辑工具Vim</h2><p>vim的三种操作模式：</p><ul><li>命令模式（Command mode）</li><li>输入模式（Insert mode）</li><li>底线命令模式（Last line mode）</li></ul><p>三种模式切换快捷键：</p><table><thead><tr><th>模式</th><th>快捷键</th></tr></thead><tbody><tr><td>命令模式</td><td>ESC</td></tr><tr><td>输入模式</td><td>i或a</td></tr><tr><td>底线命令模式</td><td><strong>:</strong></td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。</p><p>使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p><p>以下是在命令模式中常用的快捷操作：</p><table class="" style="width: 100%;" data-spm-anchor-id="a2c6h.13858378.0.i12.31941d111Dv71Z"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i11.31941d111Dv71Z">操作</th><th>快捷键</th></tr></thead><tbody><tr><td>光标左移</td><td>h</td></tr><tr><td>光标右移</td><td>l（小写L）</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i13.31941d111Dv71Z">光标上移</td><td>k</td></tr><tr><td>光标下移</td><td>j</td></tr><tr><td>光标移动到下一个单词</td><td>w</td></tr><tr><td>光标移动到上一个单词</td><td>b</td></tr><tr><td>移动游标到第n行</td><td>nG</td></tr><tr><td>移动游标到第一行</td><td>gg</td></tr><tr><td>移动游标到最后一行</td><td>G</td></tr><tr><td>快速回到上一次光标所在位置</td><td>Ctrl+o</td></tr><tr><td>删除当前字符</td><td>x</td></tr><tr><td>删除前一个字符</td><td>X</td></tr><tr><td>删除整行</td><td>dd</td></tr><tr><td>删除一个单词</td><td>dw或daw</td></tr><tr><td>删除至行尾</td><td>d$或D</td></tr><tr><td>删除至行首</td><td>d^</td></tr><tr><td>删除到文档末尾</td><td>dG</td></tr><tr><td>删除至文档首部</td><td>d1G</td></tr><tr><td>删除n行</td><td>ndd</td></tr><tr><td>删除n个连续字符</td><td>nx</td></tr><tr><td>将光标所在位置字母变成大写或小写</td><td>~</td></tr><tr><td>复制游标所在的整行</td><td>yy（3yy表示复制3行）</td></tr><tr><td>粘贴至光标后（下）</td><td>p</td></tr><tr><td>粘贴至光标前（上）</td><td>P</td></tr><tr><td>剪切</td><td>dd</td></tr><tr><td>交换上下行</td><td>ddp</td></tr><tr><td>替换整行，即删除游标所在行并进入插入模式</td><td>cc</td></tr><tr><td>撤销一次或n次操作</td><td>u{n}</td></tr><tr><td>撤销当前行的所有修改</td><td>U</td></tr><tr><td>恢复撤销操作</td><td>Ctrl+r</td></tr><tr><td>整行将向右缩进</td><td>&gt;&gt;</td></tr><tr><td>整行将向左退回</td><td>&lt;&lt;</td></tr><tr><td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td><td>ZZ</td></tr></tbody></table><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按:键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p><p>以下是底线命令模式中常用的快捷操作：</p><table class="" style="width: 100%;"><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i19.31941d111Dv71Z">操作</th><th>命令</th></tr></thead><tbody><tr><td>保存</td><td>:w</td></tr><tr><td>退出</td><td>:q</td></tr><tr><td>保存并退出</td><td>:wq（<code>:wq!</code>表示强制保存退出）</td></tr><tr><td>将文件另存为其他文件名</td><td>:w new_filename</td></tr><tr><td>显示行号</td><td>:set nu</td></tr><tr><td>取消行号</td><td>:set nonu</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i18.31941d111Dv71Z">使本行内容居中</td><td>:ce</td></tr><tr><td>使本行文本靠右</td><td>:ri</td></tr><tr><td>使本行内容靠左</td><td>:le</td></tr><tr><td>向光标之下寻找一个名称为word的字符串</td><td>:/word</td></tr><tr><td>向光标之上寻找一个字符串名称为word的字符串</td><td>:?word</td></tr><tr><td>重复前一个搜寻的动作</td><td>:n</td></tr><tr><td>从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td><td><code>:1,$s/word1/word2/g</code> 或 <code><span>&nbsp;</span>:%s/word1/word2/g</code></td></tr></tbody></table><h2 id="2、文本文件查看命令"><a href="#2、文本文件查看命令" class="headerlink" title="2、文本文件查看命令"></a>2、文本文件查看命令</h2><h3 id="cat-：查看内容较少的纯文本文件"><a href="#cat-：查看内容较少的纯文本文件" class="headerlink" title="cat ：查看内容较少的纯文本文件"></a>cat ：查看内容较少的纯文本文件</h3><p>命令描述：cat命令用于查看内容较少的纯文本文件。</p><p>命令格式：<code>cat [选项] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i26.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n或--number</td><td>显示行号</td></tr><tr><td>-b或--number-nonblank</td><td>显示行号，但是不对空白行进行编号</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i25.31941d111Dv71Z">-s或--squeeze-blank</td><td>当遇到有连续两行以上的空白行，只显示一行的空白行</td></tr></tbody></table><h3 id="more-：从前向后分页显示文件内容"><a href="#more-：从前向后分页显示文件内容" class="headerlink" title="more ：从前向后分页显示文件内容"></a>more ：从前向后分页显示文件内容</h3><p>命令描述：more命令从前向后分页显示文件内容。</p><p>常用操作命令：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i31.31941d111Dv71Z">操作</th><th>作用</th></tr></thead><tbody><tr><td>Enter</td><td>向下n行，n需要定义，默认为1行</td></tr><tr><td>Ctrl+F或空格键（Space）</td><td>向下滚动一页</td></tr><tr><td>Ctrl+B</td><td>向上滚动一页</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>!命令</td><td>调用Shell执行命令</td></tr><tr><td>q</td><td>退出more</td></tr></tbody></table><h3 id="less-：对文件或其它输出进行分页显示"><a href="#less-：对文件或其它输出进行分页显示" class="headerlink" title="less ：对文件或其它输出进行分页显示"></a>less ：对文件或其它输出进行分页显示</h3><p>命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。</p><p>命令格式：<code>less [参数] 文件</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i33.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e</td><td>当文件显示结束后，自动离开</td></tr><tr><td>-m</td><td data-spm-anchor-id="a2c6h.13858378.0.i32.31941d111Dv71Z">显示类似more命令的百分比</td></tr><tr><td>-N</td><td>显示每行的行号</td></tr><tr><td>-s</td><td>显示连续空行为一行</td></tr></tbody></table><p>命令常用操作：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i34.31941d111Dv71Z">/字符串</td><td>向下搜索字符串</td></tr><tr><td>?字符串</td><td>向上搜索字符串</td></tr><tr><td>n</td><td>重复前一个搜索</td></tr><tr><td>N</td><td>反向重复前一个搜索</td></tr><tr><td>b或<code>pageup</code>键</td><td>向上翻一页</td></tr><tr><td>空格键或<code>pagedown</code>键</td><td>向下翻一页</td></tr><tr><td>u</td><td>向前翻半页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>y</td><td>向前滚动一行</td></tr><tr><td>回车键</td><td>向后滚动一行</td></tr><tr><td>q</td><td>退出less命令</td></tr></tbody></table><p>命令使用示例：</p><p>查看命令历史使用记录并通过less分页显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure><h3 id="head-：查看文件开头指定行数的内容"><a href="#head-：查看文件开头指定行数的内容" class="headerlink" title="head ：查看文件开头指定行数的内容"></a>head ：查看文件开头指定行数的内容</h3><p>命令描述：head命令用于查看文件开头指定行数的内容。</p><p>命令格式：<code>head [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i38.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-n [行数]</td><td>显示开头指定行的文件内容，默认为10</td></tr><tr><td>-c [字符数]</td><td>显示开头指定个数的字符数</td></tr><tr><td>-q</td><td>不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名</td></tr></tbody></table><p>命令使用示例：</p><p>查看/etc/passwd文件的前5行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -5 /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="tail-：查看文档的后N行或持续刷新内容"><a href="#tail-：查看文档的后N行或持续刷新内容" class="headerlink" title="tail ：查看文档的后N行或持续刷新内容"></a>tail ：查看文档的后N行或持续刷新内容</h3><p>命令描述：tail命令用于查看文档的后N行或持续刷新内容。</p><p>命令格式：<code>tail [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i41.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>显示文件最新追加的内容</td></tr><tr><td>-q</td><td>当有多个文件参数时，不输出各个文件名</td></tr><tr><td>-v</td><td>当有多个文件参数时，总是输出各个文件名</td></tr><tr><td>-c [字节数]</td><td>显示文件的尾部n个字节内容</td></tr><tr><td>-n [行数]</td><td>显示文件的尾部n行内容</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f -n 10 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="stat-：显示文件的详细信息"><a href="#stat-：显示文件的详细信息" class="headerlink" title="stat ：显示文件的详细信息"></a>stat ：显示文件的详细信息</h3><p>命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。</p><p>命令使用示例：</p><p>查看/etc/passwd文件的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="wc-：统计指定文本的行数、字数、字节数"><a href="#wc-：统计指定文本的行数、字数、字节数" class="headerlink" title="wc ：统计指定文本的行数、字数、字节数"></a>wc ：统计指定文本的行数、字数、字节数</h3><p>命令描述：wc命令用于统计指定文本的行数、字数、字节数。</p><p>命令格式：<code>wc [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i46.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><p>命令使用示例：</p><p>统计/etc/passwd文件的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="file-：辨识文件类型"><a href="#file-：辨识文件类型" class="headerlink" title="file ：辨识文件类型"></a>file ：辨识文件类型</h3><p>命令描述： file命令用于辨识文件类型。</p><p>命令格式：<code>file [参数] [文件]</code></p><p>命令参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i48.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td data-spm-anchor-id="a2c6h.13858378.0.i47.31941d111Dv71Z">-b</td><td>列出辨识结果时，不显示文件名称</td></tr><tr><td>-c</td><td>详细显示指令执行过程，便于排错或分析程序执行的情形</td></tr><tr><td>-f [文件]</td><td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</td></tr><tr><td>-L</td><td>直接显示符号连接所指向的文件类别</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages文件的文件类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><h3 id="diff-：比较文件的差异"><a href="#diff-：比较文件的差异" class="headerlink" title="diff ：比较文件的差异"></a>diff ：比较文件的差异</h3><p>命令描述：diff命令用于比较文件的差异。</p><p>命令格式：<code>diff [文件] [文件]</code></p><h2 id="3、文本处理命令"><a href="#3、文本处理命令" class="headerlink" title="3、文本处理命令"></a>3、文本处理命令</h2><h3 id="grep-：查找文件里符合条件的字符串"><a href="#grep-：查找文件里符合条件的字符串" class="headerlink" title="grep ：查找文件里符合条件的字符串"></a>grep ：查找文件里符合条件的字符串</h3><p>命令描述：grep命令用于查找文件里符合条件的字符串。</p><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>在Shell脚本中，grep通过返回一个状态值来表示搜索的状态：</p><ul><li>0：匹配成功。</li><li>1：匹配失败。</li><li>2：搜索的文件不存在。</li></ul><p>命令格式：<code>grep [参数] [正则表达式] [文件]</code></p><p>命令常用参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i54.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c或--count</td><td>计算符合样式的列数</td></tr><tr><td>-d recurse或-r</td><td>指定要查找的是目录而非文件</td></tr><tr><td>-e [范本样式]</td><td>指定字符串做为查找文件内容的样式</td></tr><tr><td>-E 或 --extended-regexp</td><td>将样式为延伸的正则表达式来使用</td></tr><tr><td>-F 或 --fixed-regexp</td><td>将样式视为固定字符串的列表</td></tr><tr><td>-G 或 --basic-regexp</td><td>将样式视为普通的表示法来使用</td></tr><tr><td>-i 或 --ignore-case</td><td>忽略字符大小写的差别</td></tr><tr><td>-n 或 --line-number</td><td>在显示符合样式的那一行之前，标示出该行的列数编号</td></tr><tr><td>-v 或 --revert-match</td><td>显示不包含匹配文本的所有行</td></tr></tbody></table><p>命令使用示例：</p><p>查看sshd服务配置文件中监听端口配置所在行编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n Port /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure><p>查询字符串在文本中出现的行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c localhost /etc/hosts</span><br></pre></td></tr></table></figure><p>反向查找，不显示符合条件的行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br><span class="line">ps -ef | grep -v grep | grep sshd</span><br></pre></td></tr></table></figure><p>以递归的方式查找目录下含有关键字的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r *.sh /etc</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;ntp[0-9].aliyun.com&#x27;</span> /etc/ntp.conf</span><br></pre></td></tr></table></figure><h3 id="sed-：文本处理"><a href="#sed-：文本处理" class="headerlink" title="sed ：文本处理"></a>sed ：文本处理</h3><p>命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。</p><ol><li>处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。</li><li>接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</li><li>接着处理下一行，这样不断重复，直到文件末尾。</li></ol><p>注意：</p><p>sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。<br>如果要改变源文件，需要使用-i选项。<br>命令格式：<code>sed [参数] [动作] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i63.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-e [script]</td><td>执行多个script</td></tr><tr><td>-f [script文件]</td><td>执行指定script文件</td></tr><tr><td>-n</td><td>仅显示script处理后的结果</td></tr><tr><td>-i</td><td>输出到原文件，静默执行（修改原文件）</td></tr></tbody></table><p>动作说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i65.31941d111Dv71Z">动作</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>在行后面增加内容</td></tr><tr><td>c</td><td>替换行</td></tr><tr><td>d</td><td>删除行</td></tr><tr><td>i</td><td>在行前面插入</td></tr><tr><td>p</td><td>打印相关的行</td></tr><tr><td>s</td><td>替换内容</td></tr></tbody></table><p>命令使用示例：</p><p>删除第3行到最后一行内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>在最后一行新增行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;$a admin:x:1000:1000:admin:/home/admin:/bin/bash&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>替换内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/SELINUX=disabled/SELINUX=enforcing/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>替换行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;1c abcdefg&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="awk-：文本处理"><a href="#awk-：文本处理" class="headerlink" title="awk ：文本处理"></a>awk ：文本处理</h3><p>命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><p>命令格式：<code>awk [参数] [脚本] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i72.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-F fs</td><td>指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</td></tr><tr><td data-spm-anchor-id="a2c6h.13858378.0.i71.31941d111Dv71Z">-f file</td><td>读取awk脚本</td></tr><tr><td>-v val=val</td><td>在执行处理过程之前，设置一个变量var，并给其设置初始值为val</td></tr></tbody></table><p>内置变量：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i74.31941d111Dv71Z">变量</th><th>用途</th></tr></thead><tbody><tr><td>FS</td><td>字段分隔符</td></tr><tr><td>$n</td><td>指定分隔的第n个字段，如$1、$3分别表示第1、第三列</td></tr><tr><td>$0</td><td>当前读入的整行文本内容</td></tr><tr><td>NF</td><td>记录当前处理行的字段个数（列数）</td></tr><tr><td>NR</td><td>记录当前已读入的行数</td></tr><tr><td>FNR</td><td>当前行在源文件中的行号</td></tr></tbody></table><p>awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。</p><p>和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。</p><p>命令使用示例：</p><p>查看本机IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 |awk <span class="string">&#x27;/inet/&#123;print $2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看本机剩余磁盘容量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h |awk <span class="string">&#x27;/\/$/&#123;print $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>统计系统用户个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$3&lt;1000&#123;x++&#125; END&#123;print x&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;$7!~/nologin$/&#123;print $1,$7&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>输出/etc/passwd文件中前三行记录的用户名和用户uid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -3 /etc/passwd | awk  <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;;print &quot;name\tuid&quot;&#125;&#123;print $1,&quot;\t&quot;$3&#125;END&#123;print &quot;sum lines &quot;NR&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>查看tcp连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>关闭指定服务的所有的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | awk &#123;<span class="string">&#x27;print $2&#x27;</span>&#125; | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h3 id="cut-：切割字符串"><a href="#cut-：切割字符串" class="headerlink" title="cut ：切割字符串"></a>cut ：切割字符串</h3><p>命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。</p><p>命令格式：<code>cut [参数] [文件]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i81.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>以字节为单位进行分割</td></tr><tr><td>-c</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><h3 id="tr-：对来自标准输入的字符进行替换、压缩和删除"><a href="#tr-：对来自标准输入的字符进行替换、压缩和删除" class="headerlink" title="tr ：对来自标准输入的字符进行替换、压缩和删除"></a>tr ：对来自标准输入的字符进行替换、压缩和删除</h3><p>命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。</p><p>命令格式：<code>tr [参数] [文本]</code></p><p>参数说明：</p><table><caption></caption><colgroup><col><col></colgroup><thead><tr><th data-spm-anchor-id="a2c6h.13858378.0.i84.31941d111Dv71Z">参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>反选指定字符</td></tr><tr><td>-d</td><td>删除指定字符</td></tr><tr><td>-s</td><td>将重复的字符缩减成一个字符</td></tr><tr><td>-t [第一字符集] [第二字符集]</td><td>删除第一字符集较第二字符集多出的字符，使两个字符集长度相等</td></tr></tbody></table><p>命令使用示例：</p><p>将输入字符由大写转换为小写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;HELLO WORLD&quot;</span> | tr <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p>删除字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello 123 world 456&quot;</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p>压缩字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;thissss is      a text linnnnnnne.&quot;</span> | tr -s <span class="string">&#x27; sn&#x27;</span></span><br></pre></td></tr></table></figure><p>产生随机密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何使用Linux系统中的文本编辑工具Vim以及文本处理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令——文件与权限</title>
    <link href="http://blog.sukiu.top/Linux/Linux-Files-And-Permissions/"/>
    <id>http://blog.sukiu.top/Linux/Linux-Files-And-Permissions/</id>
    <published>2021-11-07T08:47:19.000Z</published>
    <updated>2021-12-02T01:26:19.798Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中常用的文件目录管理和文件权限管理命令。</p><span id="more"></span><blockquote><p>以下所有内容都来自 <a href="https://developer.aliyun.com/">https://developer.aliyun.com/</a>，仅供自己学习用。</p></blockquote><h2 id="1、文件目录管理命令"><a href="#1、文件目录管理命令" class="headerlink" title="1、文件目录管理命令"></a>1、文件目录管理命令</h2><h3 id="tree-：以树状图列出目录的内容"><a href="#tree-：以树状图列出目录的内容" class="headerlink" title="tree ：以树状图列出目录的内容"></a>tree ：以树状图列出目录的内容</h3><p>命令描述：tree命令用于以树状图列出目录的内容。</p><p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /usr/share/wallpapers/</span><br></pre></td></tr></table></figure><h3 id="ls-：显示指定工作目录下的内容"><a href="#ls-：显示指定工作目录下的内容" class="headerlink" title="ls ：显示指定工作目录下的内容"></a>ls ：显示指定工作目录下的内容</h3><p>注意是 L 的小写，不是大写 I</p><p>命令描述： ls命令用于显示指定工作目录下的内容。</p><p>命令格式：ls [参数] [目录名]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有文件及目录（包括隐藏文件）</td></tr><tr><td>-l</td><td>将文件的权限、拥有者、文件大小等详细信息列出（ll等同于ls -l）</td></tr><tr><td>-r</td><td>将文件反序列出（默认按英文字母正序）</td></tr><tr><td>-t</td><td>将文件按创建时间正序列出</td></tr><tr><td>-R</td><td>递归遍历目录下文件</td></tr></tbody></table><h3 id="pwd-：获取当前工作目录的绝对路径"><a href="#pwd-：获取当前工作目录的绝对路径" class="headerlink" title="pwd ：获取当前工作目录的绝对路径"></a>pwd ：获取当前工作目录的绝对路径</h3><p>命令描述：获取当前工作目录的绝对路径。</p><p>命令使用：<code>pwd</code></p><h3 id="cd-：切换工作目录"><a href="#cd-：切换工作目录" class="headerlink" title="cd ：切换工作目录"></a>cd ：切换工作目录</h3><p>命令描述：cd命令用于切换工作目录。</p><p>在路径表示中：</p><ul><li>一个半角句号（.）表示当前目录，例如路径./app/log等同于app/log。</li><li>两个半角句号（..）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。</li></ul><p>cd命令的默认参数为 ~ ，符号 ~ 表示当前用户的家目录，即在root用户登录时，命令cd、cd ~ 和cd /root执行效果相同。</p><h3 id="touch-：修改文件或者目录的时间属性"><a href="#touch-：修改文件或者目录的时间属性" class="headerlink" title="touch ：修改文件或者目录的时间属性"></a>touch ：修改文件或者目录的时间属性</h3><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>命令格式：touch [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>如果指定文件不存在，不会建立新文件</td></tr><tr><td>-r</td><td>使用参考文件的时间记录</td></tr><tr><td>-t</td><td>设置文件的时间记录</td></tr></tbody></table><h3 id="mkdir-：新建子目录"><a href="#mkdir-：新建子目录" class="headerlink" title="mkdir ：新建子目录"></a>mkdir ：新建子目录</h3><p>命令描述：mkdir命令用于新建子目录。-p 参数确保目录名称存在，不存在的就新建一个。</p><p>命令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p a/b/c</span><br></pre></td></tr></table></figure><h3 id="rm-：删除一个文件或者目录"><a href="#rm-：删除一个文件或者目录" class="headerlink" title="rm ：删除一个文件或者目录"></a>rm ：删除一个文件或者目录</h3><p>命令描述：rm命令用于删除一个文件或者目录。</p><p>命令格式：rm [参数] [文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>删除前逐一询问确认</td></tr><tr><td>-f</td><td>无需确认，直接删除</td></tr><tr><td>-r</td><td>删除目录下所有文件</td></tr></tbody></table><h3 id="cp-：复制文件或目录"><a href="#cp-：复制文件或目录" class="headerlink" title="cp ：复制文件或目录"></a>cp ：复制文件或目录</h3><p>命令描述： cp命令主要用于复制文件或目录。</p><p>命令格式：cp [参数] [源文件] [目标文件]</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>复制时保留链接</td></tr><tr><td>-f</td><td>覆盖已经存在的目标文件而不给出提示</td></tr><tr><td>-i</td><td>覆盖前询问</td></tr><tr><td>-p</td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td>-r</td><td>复制目录及目录内的所有项目</td></tr></tbody></table><h3 id="mv-：为文件或目录改名-将文件或目录移入其它位置"><a href="#mv-：为文件或目录改名-将文件或目录移入其它位置" class="headerlink" title="mv ：为文件或目录改名 / 将文件或目录移入其它位置"></a>mv ：为文件或目录改名 / 将文件或目录移入其它位置</h3><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>命令格式：mv [参数] [源文件] [目标文件]</p><p>参数说明：</p><p>参数    说明<br>-i    若指定目录已有同名文件，则先询问是否覆盖旧文件<br>-f    如果目标文件已经存在，不会询问而直接覆盖</p><h3 id="rename-：批量改变文件名"><a href="#rename-：批量改变文件名" class="headerlink" title="rename ：批量改变文件名"></a>rename ：批量改变文件名</h3><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p><p>命令格式：rename [原值] [替换值]</p><h2 id="2、文件权限管理"><a href="#2、文件权限管理" class="headerlink" title="2、文件权限管理"></a>2、文件权限管理</h2><p>ls命令可以查看Linux系统上的文件、目录和设备的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /boot/</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuYWxpY2RuLmNvbS90ZnMvVEIxMmdYY0hORDFnSzBqU1pGS1hYY0pyVlhhLTg2OS00MjAucG5n?x-oss-process=image/format,png#pic_center" alt="ls"><br>上述ls -l命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p><ul><li>第1位表示存档类型，d表示目录，-表示一般文件。</li><li>第2~4位表示当前用户的权限（属主权限）。</li><li>第5~7位表示同用户组的用户权限（属组权限）。</li><li>第8~10位表示不同用户组的用户权限（其他用户权限）。</li><li>第11位是一个半角句号.，表示SELinux安全标签。</li></ul><p>用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。</p><p>例如efi目录的root用户权限为drwxr-xr-x.。</p><ul><li>该目录对root用户具有读写和执行所有权限。</li><li>该目录对root组其他用户有读和执行权限。</li><li>该目录对其他用户有读和执行权限。</li></ul><p>所以该权限表示对应八进制权限表示为：</p><ul><li>属主权限：4+2+1=7。</li><li>属组权限：4+1=5。</li><li>其他用户权限：4+1=5。</li></ul><p>即755。</p><h3 id="chmod-：修改文件权限"><a href="#chmod-：修改文件权限" class="headerlink" title="chmod ：修改文件权限"></a>chmod ：修改文件权限</h3><p>chmod命令用于修改文件权限mode，-R参数以递归方式对子目录和文件进行修改。</p><p>将hello.sh文件增加属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件撤销属主的执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x hello.sh</span><br></pre></td></tr></table></figure><p>将hello.sh文件权限修改为八进制表示的744权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 hello.sh</span><br></pre></td></tr></table></figure><p><strong>u+x表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。</strong></p><h3 id="chown-：修改文件的属主和属组"><a href="#chown-：修改文件的属主和属组" class="headerlink" title="chown ：修改文件的属主和属组"></a>chown ：修改文件的属主和属组</h3><p>chown命令修改文件的属主和属组</p><ul><li>-R参数以递归方式对子目录和文件进行修改</li><li>ls -l命令显示的第三列和第四列就是文件的属主和属组信息。</li></ul><p>修改test.txt文件的属主用户为test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="built_in">test</span> test.txt</span><br></pre></td></tr></table></figure><p>修改test.txt文件的属主和属组为admin。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown admin:admin test.txt</span><br></pre></td></tr></table></figure><h3 id="chgrp-：修改文件的属组"><a href="#chgrp-：修改文件的属组" class="headerlink" title="chgrp ：修改文件的属组"></a>chgrp ：修改文件的属组</h3><p>chgrp命令用于修改文件的属组。</p><p>命令使用示例：</p><p>将test.txt文件的属组改为root。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp root test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux系统中常用的文件目录管理和文件权限管理命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://blog.sukiu.top/categories/Linux/"/>
    
    
    <category term="Shell" scheme="http://blog.sukiu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://blog.sukiu.top/Algorithm/Binary-Tree-Traversal/"/>
    <id>http://blog.sukiu.top/Algorithm/Binary-Tree-Traversal/</id>
    <published>2021-11-03T00:47:26.000Z</published>
    <updated>2021-12-02T01:03:37.563Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树遍历主要包括：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><span id="more"></span><blockquote><p>参考：</p><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">代码随想录 (programmercarl.com)</a></p></blockquote><h2 id="1、递归遍历"><a href="#1、递归遍历" class="headerlink" title="1、递归遍历"></a>1、递归遍历</h2><p><strong>递归三要素：</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>即 根-左-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> preOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    preOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        preOrder(root.Left)</span><br><span class="line">        preOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>即 左-根-右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.Left)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">        inOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>即 左-右-根</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    postorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.Left)</span><br><span class="line">        postorder(root.Right)</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、迭代遍历"><a href="#2、迭代遍历" class="headerlink" title="2、迭代遍历"></a>2、迭代遍历</h2><p><strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 通过这种标记法实现二叉树的统一迭代遍历。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif" alt="中序遍历"></p><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123; </span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; </span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack := list.New()</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">var</span> node *TreeNode</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        back := stack.Back()</span><br><span class="line">        stack.Remove(back)</span><br><span class="line">        <span class="keyword">if</span> back.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">            node = back.Value.(*TreeNode) <span class="comment">// interface 为 nil 无法 断言类型转换</span></span><br><span class="line">            stack.PushBack(node) <span class="comment">// 根</span></span><br><span class="line">            stack.PushBack(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Right) <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack.PushBack(node.Left) <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、层序遍历"><a href="#3、层序遍历" class="headerlink" title="3、层序遍历"></a>3、层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := list.New()</span><br><span class="line">    queue.PushBack(root)</span><br><span class="line">    t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        l := queue.Len()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">            node := queue.Remove(queue.Front()).(*TreeNode)</span><br><span class="line">            t = <span class="built_in">append</span>(t, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        t = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树遍历主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先遍历&lt;ul&gt;
&lt;li&gt;前序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;中序遍历（递归法，迭代法）&lt;/li&gt;
&lt;li&gt;后序遍历（递归法，迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广度优先遍历&lt;ul&gt;
&lt;li&gt;层次遍历（迭代法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.sukiu.top/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://blog.sukiu.top/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>常见容器底层</title>
    <link href="http://blog.sukiu.top/Data-structure/Common-Container/"/>
    <id>http://blog.sukiu.top/Data-structure/Common-Container/</id>
    <published>2021-11-02T01:10:23.000Z</published>
    <updated>2021-12-02T01:04:01.705Z</updated>
    
    <content type="html"><![CDATA[<p>各种语言下，常见容器底层整理。</p><span id="more"></span><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/834cc223bb57">C++ STL容器底层数据结构总结 - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/359878588">C++面试进阶（STL底层数据结构特点及实现） - 知乎 (zhihu.com)</a></p></blockquote><h2 id="1、C"><a href="#1、C" class="headerlink" title="1、C++"></a>1、C++</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>其底层数据结构是<strong>数组</strong>，由于能动态扩容，所以也称<strong>动态数组</strong></p><p><strong>特点：</strong></p><ul><li><p>随机访问：$O(1)$</p></li><li><p>随机插入删除： $O(n)$，中间插入会引起后面数据的拷贝，尾部可快速增删</p></li><li><p>扩容规则：</p><ul><li>新建时初始化一片空间</li><li>插入元素引起扩容的时候，gcc会申请2倍的空间，拷贝原有数据</li><li>释放原来空间</li></ul></li><li><p>在进行迭代器相关的修改操作时（包括扩容），<strong>所有迭代器和指针引用都会失效</strong></p></li></ul><h3 id="map-amp-multimap-amp-set-amp-multiset"><a href="#map-amp-multimap-amp-set-amp-multiset" class="headerlink" title="map &amp; multimap &amp; set &amp; multiset"></a>map &amp; multimap &amp; set &amp; multiset</h3><p>map提供一对一key-value的数据处理能力；set可以理解为关键字即值，即只保存关键字的容器。</p><p>与multi的区别在于，multi允许关键字重复，而上面2个不允许重复。</p><p>底层数据结构均为<strong>红黑树</strong>，可以参考[教你透彻了解红黑树](<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">The-Art-Of-Programming-By-July/03.01.md at master · julycoding/The-Art-Of-Programming-By-July (github.com)</a>)。</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(logn)$</li></ul><h3 id="unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset"><a href="#unordered-map-amp-unordered-multimap-amp-unordered-set-amp-unordered-mutiset" class="headerlink" title="unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset"></a>unordered_map &amp; unordered_multimap &amp; unordered_set &amp; unordered_mutiset</h3><p>顾名思义，以上容器是无序的，所以底层实现为<strong>哈希表</strong>，因此其查找时间复杂度理论上达到了<strong>O(n)</strong></p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$，但是实际上要考虑碰撞的问题</li></ul><h2 id="2、Go"><a href="#2、Go" class="headerlink" title="2、Go"></a>2、Go</h2><p>Go 语言不添加其他包的话，只提供了一个 map 容器，不过其他容器适配器之类可以用万能的数组切片实现</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>底层数据结构是哈希表</p><p><strong>特点：</strong></p><ul><li>访问、查找、删除：$O(1)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;各种语言下，常见容器底层整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Container" scheme="http://blog.sukiu.top/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>Priority Queue Go 优先队列</title>
    <link href="http://blog.sukiu.top/Data-structure/Priority-Queue/"/>
    <id>http://blog.sukiu.top/Data-structure/Priority-Queue/</id>
    <published>2021-11-01T14:13:03.000Z</published>
    <updated>2021-12-02T01:05:16.887Z</updated>
    
    <content type="html"><![CDATA[<p><em>论如何在 Go 语言中使用优先队列。</em></p><span id="more"></span><blockquote><p>参考：</p><p><a href="http://cngolib.com/container-heap.html">Go标准库中文文档 (cngolib.com)</a></p></blockquote><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Go 提供了 <a href="https://golang.org/pkg/container/heap/">container/heap</a> 这个包来实现堆的操作。堆实际上是一个树的结构，每个元素的值都是它的子树中最小的，因此根节点 <code>index = 0</code> 的值是最小的，即最小堆。</p><p>堆也是实现优先队列 Priority Queue 的常用方式。</p><p>堆中元素的类型需要实现 <code>heap.Interface</code> 这个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <a href="https://golang.org/pkg/sort/#Interface">sort.Interface</a> 包括 <code>Len()</code>, <code>Less</code>, <code>Swap</code> 方法。</p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap [][<span class="number">2</span>]<span class="keyword">int</span> <span class="comment">// 0 key 1 value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i][<span class="number">1</span>] &lt; h[j][<span class="number">1</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.([<span class="number">2</span>]<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 347. 前 K 个高频元素</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/top-k-frequent-elements/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        m[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">        heap.Push(h, [<span class="number">2</span>]<span class="keyword">int</span>&#123;key, value&#125;)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        k--</span><br><span class="line">        ans[k] = heap.Pop(h).([<span class="number">2</span>]<span class="keyword">int</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;论如何在 Go 语言中使用优先队列。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data structure" scheme="http://blog.sukiu.top/categories/Data-structure/"/>
    
    
    <category term="Queue" scheme="http://blog.sukiu.top/tags/Queue/"/>
    
  </entry>
  
</feed>
